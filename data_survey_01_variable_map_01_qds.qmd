---
title: "Create Variable Map - QDS"
date: "2022-10-02 <br> Updated: `r Sys.Date()`"
format: pdf
editor: 
  markdown: 
    wrap: sentence
---

# ⭐️Overview 🔴 - TO BE EDITED

This file is used to import the Link2Care follow-up visit survey data and do some initial data cleaning.
It drops SPSS calculated variables, recreates these dropped variables, and creates a variable map.

[Notes on cleaning individual L2C data sets for merging](https://github.com/brad-cannell/link2care_public/wiki/Notes-on-cleaning-individual-L2C-data-sets-for-merging)

Notes and guide for how to use **variable map** functions, with examples found in: guide_01_variable_map_functions.qmd

# 📦Load packages & Functions

```{r message=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(purrr, warn.conflicts = FALSE)
library(haven, warn.conflicts = FALSE)
library(here, warn.conflicts = FALSE)
library(tidyverse, warn.conflicts = FALSE)
library(readr, warn.conflicts = FALSE)
library(readxl, warn.conflicts = FALSE)
```

```{r}
source(here("R", "standardize_col_names.R"))
source(here("R", "flag_unmatching_variables.R"))
source(here("R", "vm_make_source_map.R"))
source(here("R", "vm_check.R"))
source(here("R", "vm_create_for_instrument.R"))
source(here("R", "vm_join_inst_section.R"))
source(here("R", "vm_join_sections.R"))
source(here("R", "vm_add_variable.R"))
source(here("R", "vm_delete_variable.R"))
source(here("R", "vm_process_source_df.R"))
source(here("R", "vm_process_many_source.R"))
```

## Notes

1.  This file creates a **variable map**.
    This variable map is used to facilitate batch processing of the Link2Care variables.
    Notes on the structure and use of a variable map, including descriptions and examples of the variable map functions, is located in "guide_01_variable_map_functions.qmd".

2.  The columns in the data are not arranged in the order that they exist in the actual QDS survey for some reason.
    This makes the data harder to work with, and it will make the codebook we eventually create difficult to use.
    So, we are going to reorder them in the order that they appear in the Link2Care appendix (`codebooks/from_qds/Link2Care_Appendix.pdf`).
    We create a **variable map** to facilitate the variable ordering process.

-   The Link2Care appendix is organized by section, then instrument, then individual items within an instrument.
    Ordering of the variables in the combined data should mirror this as closely and reasonably as possible.

-   Some variables in the data do not belong to an instrument in the Link2Care appendix.
    For example, the questions about COVID vaccines.
    We will order them after the columns that do appear in the Link2Care appendix following the base logic of the Link2Care appendix.

-   The **variable map** structure will facilitate future changes to the order of variables.

3.  Each data set has different names for the same variables, including unique typos.

-   The **variable map** contains 6 variables reflecting this standardization for the QDS data sets.

4.  We want to re-create variables that were calculated in SPSS, rather than relying on their imported values.

-   The map organization system allows us to insert variables to ensure a human-readable ordering.

### 🕒 Change Log 

**2023-10-06**, the process was revised to eliminate the use of numerical assignment of variable order, repetition of code, and failure to throw explicit errors in the case of variable names or content changing in the source data sets. The plan for the full modification pipeline was revised. The new plan will divide the process into three distinct steps. First will be creation of the variable map "choke point" for all source data sets. The second will involve processing the source data, and merging into a new combined data set based on this variable map. The third will involve the creation/recreation of variables originally calculated in SPSS with R, utilizing this aggregate data set. This should yield a robust process flow that isolates any potential changes required if the source data were to change variable names, structures, or otherwise. 

**2023-09-27**, the original .RMD version of this file was modified and updated for changing priorities. The new QMD version prioritizes human readability for tracing from QDS data to final data, facilitation of point-fixes, and creation of calculated variables from processing in R rather than SPSS.

On **2021-06-10**, VISIT_TYPE was added to QDS. This change affects V1-V5.

On **2021-06-05**, Joe Waring found a discrepancy between the way Tobacco 26 was being asked in QDS and REDCap. 

In QDS, T26_V1, T26_V3, T26_V4, and T26_V5 read:

Which option would give you the best chance for quitting smoking?
1	=	Medications
2	=	Counseling
3	=	Both medications and counseling
4	=	Smartphone app
5	=	Both smartphone app and medications
6	=	Quitting "cold turkey" - without counseling or medications
9	=	skipped

And only one answer choice was possible.

In REDCap, t26_v1 reads:

If you were to try to quit smoking, which of the following would you prefer to receive: (select all that apply)

1 t26_v1___1 Medications
2 t26_v1___2 Group Counseling
3 t26_v1___3 Smartphone app
4 t26_v1___4 In person individual counseling
5 t26_v1___5 Helpline phone counseling
6 t26_v1___6 None of the above

Where multiple answers are possible and t26_v1___1 - t26_v1___6 are dummy variables.

On 2021-06-30 the QDS survey was changed to be more like the REDCap survey. The QDS data now has T26A_V1, T26A_V1A, T26A_V1B, T26A_V1C, T26A_V1D, T26A_V1E, and T26A_V1F that correspond to t26_v1___1 - t26_v1___6 in REDCap.

Remember that because of a naming error with T3B_V1, T26_V1 was already manually changed to T27 in the QDS Word codebooks (e.g., L2C_V1 Codebook.docx) by MBC. Changing "T26_V1" (the name that appears in the outdated codebook) to "T26A_V1" (the name that actually appears in the data frame now).

This change affects V1, V3, V4, and V5.

#### 🔴🔴🔴 Notes for Brad from Morri (2023-10-06)

-   RE: Not keeping change log in final file

    -   I agree, it can either be deleted or moved to the Wiki once the files are "done"

-   RE: Mentioning the definition/goal of standardization

    -   I should have added something on this now: Create Initial Variable Map from QDS Sources \> Notes on Variable Standardization

-   RE: Need for clarify of variable map approach, structure, etc.

    -   I should have something that functions as a 101 walkthrough in the file "guide_01_variable_map_functions.qmd"

    -   The file has a full walkthrough demonstration of the variable map itself.
        It has *most* of the helper functions.

        -   I plan to refine it when I do my last "polish" of this project.
            Some of the helper functions were slightly modified between the creation of the guide and now, as I identify new challenges in this application (i.e., needing to have both "contains" and "starts_with" keys for both variables I want to include and exclude, etc.)

    -   For context, I came up with the idea because it mirrors how I think about interrelated concepts, the most basic being the mapping of concepts/definitions to vocabulary in multiple spoken languages.
        It's like taking a tiny piece of my overall "mental web" by maping a single set of connection points.
        I refined it into its existing structure from my (minor) experience working with SQL relational databases

-   RE: length of code lines

    -   I understand.
        I have the 80-char line in my RStudio, but I may have slightly misjudged if something was "just before" or "just after".
        I set it a little lower to give me more buffer, and this document should (hopefully) be fully compliant

-   RE: lots of repeated code

    -   This revised code should utilize helper functions more readily, and meet more of your desired structure.
        There may still appear to be a large amount of repetition because this process follows a "formula". I found there to be too many potential outcomes of point-checks for replacing more of the formula to be more time/effort/work than it saves. 
        
-   RE: preference for one print/display per code chunk, identifying chunks that print more than one as a single 'DATA CHECK' with a comment in the chunk

    -   I understand the reason for and benefit of the preference. I should hopefully have achieved this to your standard.
    
-   RE: Avoiding setting order with numbers, desire for more stop errors if values change in the source data sets.

    -   The revised process should have achieved this. There are many opportunities for any potential change to stop processing, and raise informative errors.

# 📥 Import data

## QDS

-   Import all 5 QDS data frames.
-   These datasets were exported directly from QDS as SPSS files (.SAV), and they have already been run through an SPSS syntax file (`spss_syntax/Visit 1.sps`, `spss_syntax/Visit 2.sps`, etc.).
-   The data was exported from QDS by someone other than MBC.
-   The SPSS syntax files were created by someone other than MBC.

```{r}
qds_spss_path <- here("data", "qds")
qds_spss_paths <- paste0(qds_spss_path, "Visit_", 1:5, "_Data.SAV")
```

Check the most recent file modification dates and print for user when this file is being sourced.

```{r}
walk(
  .x = c(1:5),
  .f = function(x) {
    sav_nm <- paste0("Visit_", x, "_Data.SAV")
    path <- here(qds_spss_path, sav_nm)
    cat(
      sav_nm, "last modified on OneDrive", 
      as.character(file.info(path)$mtime), "\n"
    )
  }
)

# Visit_1_Data.SAV last modified on OneDrive 2023-08-25 10:55:05 
# Visit_2_Data.SAV last modified on OneDrive 2023-08-25 10:55:05 
# Visit_3_Data.SAV last modified on OneDrive 2023-08-25 10:55:05 
# Visit_4_Data.SAV last modified on OneDrive 2023-08-25 10:55:05 
# Visit_5_Data.SAV last modified on OneDrive 2023-08-25 10:55:05
```

Import the data

```{r}
walk(
  .x = c(1:5),
  .f = function(x) {
    new_nm <- paste0("v", x)
    sav_nm <- paste0("Visit_", x, "_Data.SAV")
    path <- here(qds_spss_path, sav_nm)
    assign(new_nm, read_sav(path), envir = .GlobalEnv)
  }
)
```

Print a message for when this file is being sourced

```{r}
walk(
  .x = c(1:5),
  .f = function(x) {
    df_nm <- paste0("v", x)
    df <- get(df_nm, envir = .GlobalEnv)
    # Print a message for when this file is being sourced
    cat(
      paste0(Sys.Date(), ":"),
      df_nm, "imported with", nrow(df), "rows and", ncol(df), "columns.\n"
    )
  }
)

# Data check:
# 2023-10-09: v1 imported with 442 rows and 810 columns.
# 2023-10-09: v2 imported with 406 rows and 213 columns.
# 2023-10-09: v3 imported with 273 rows and 542 columns.
# 2023-10-09: v4 imported with 207 rows and 598 columns.
# 2023-10-09: v5 imported with 178 rows and 649 columns.
```

## REDCap 

Several subjects completed visits within REDCap, rather than QDS.
We imported the REDCap data set.

```{r}
redcap_spss_path <- here("data", "redcap", "All_Visits_Redcap.sav")
```

Import the data.
Check the most recent file modification dates and print for user when this file is being sourced.

```{r message=FALSE}
redcap <- read_sav(redcap_spss_path)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "REDCap imported with", nrow(redcap), "rows and", ncol(redcap), "columns.\n"
)

# Check the most recent file modification dates and print for user when this
# file is being sourced.

cat(
      "REDCap data last modified on OneDrive", 
      as.character(file.info(redcap_spss_path)$mtime), "\n"
    )

# 2023-10-09: REDCap imported with 119 rows and 845 columns.
# REDCap data last modified on OneDrive 2023-08-25 10:56:25 
```

## Excel Master Log 

To ensure group assignment was consistent for subjects, we imported the subject and group assignments from the Excel Master log data.
Group membership was randomly assigned at Visit 2, but it is not recorded in QDS or REDCap until visit 3 and beyond.
Therefore, if we only rely on QDS or REDCap data, it appears as though many participants haven't been randomized to a group even though they have.
The study staff manually tracks group assignment in the Excel Master Log. We can use that data to cross-check and impute group membership when QDS and REDCap data are not otherwise sufficient. It is not ideal, but it seems to be the best option we have.
The Master Log also appears to be the only source of values for each subject's age.

```{r}
master_log_path  <- here("data", "master_log", "master_log.xlsx")
```

Import the data.
Check the most recent file modification dates and print for user when this file is being sourced.

```{r}
master_log <- read_excel(
  master_log_path, 
  sheet = "Screened In",
  col_names = c("id", "group", "age"),
  col_types = c(
    "text", rep("skip", 22), "text", rep("skip", 9), "text", rep("skip", 21)
                ),
  skip = 1
) %>% 
  # Coerce group to numeric so that it can be combined with the QDS data.
  mutate(
    group = case_when(
      group == "UCM"    ~ 1,
      group == "UCM+SP" ~ 2,
      group == "L2C"    ~ 3
    )
  ) %>%
  # Coerce age to a numeric
  mutate(age = as.numeric(age)) %>%
  # Remove empty rows
  filter(!is.na(id))

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Master log imported with", nrow(master_log), "rows and", ncol(master_log),
  "columns.\n"
)

# Check the most recent file modification dates and print for user when this
# file is being sourced.

cat(
      "Master log last modified on OneDrive", 
      as.character(file.info(master_log_path)$mtime), "\n"
    )

# 2023-10-11: Master log imported with 442 rows and 3 columns.
# Master log last modified on OneDrive 2023-09-28 11:52:59 
```

## Timeline Follow Back (TLFB)

All Timeline Follow Back (TLFB) section data was stored separately.

```{r}
tlfb_spss_path <- here("data", "tlfb", "TLFB_Database.sav")
```

Import the data.
Check the most recent file modification dates and print for user when this file is being sourced.

```{r message=FALSE}
tlfb <- read_sav(tlfb_spss_path)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "TLFB imported with", nrow(tlfb), "rows and", ncol(tlfb), "columns.\n"
)

# Check the most recent file modification dates and print for user when this
# file is being sourced.

cat(
      "TLFB data last modified on OneDrive", 
      as.character(file.info(tlfb_spss_path)$mtime), "\n"
    )

# 2023-10-11: TLFB imported with 1768 rows and 21 columns.
# TLFB data last modified on OneDrive 2023-08-25 10:56:58 
```

We removed containers that were no longer necessary.

```{r}
rm(qds_spss_path)
rm(qds_spss_paths)
rm(master_log_path)
rm(redcap_spss_path)
rm(tlfb_spss_path)
```

# Create Initial Variable Map

## Notes on Variable Standardization (Definition, Goals)

We have to make the column names match across visits so that we can merge all of the individual source data frames into one.

The QDS data has different variable names for the same item in each visit.
Not all items are present in each visit, and the order in the QDS data set differs from the order in the appendix (our desired order).

We chose to standardize our variable names.
Our overall end goal with standardization is to have all variables follow the same format:

-   A meaningful prefix indicating the source instrument (i.e., "sq\_" for screening instrument items)

-   Indicate order of the item, specifically order as it relates to the "pen and paper" version of the instrument in the Appendix, with a number (i.e., the second item of the screening instrument should be represented with "sq_2")

-   Subsections of a question, such as when a select-all-that apply is divided into dichotomous dummy variables, should be indicated with letters after the number.
    (i.e., if the second item in the screening instrument is a select all that apply, the record of the third option should be in variable "sq_2_c")

-   Alternative versions of a question may be represented with a letter suffix after the variable number, before any separating underscore.
    (i.e., "sq_4a" and "sq_4b")

We may later decide to rename variables to descriptive names after initial standardization has occurred.

Initial standardization is based on our helper function `standardize_col_names()`.
This function does not achieve all of our standardization goals, but significantly reduces the amount of manual standardization that must occur.

This function:

-   Removes \_v{1, 2, 3} and v{1, 2, 3} from column names Replaces spaces with underscores

-   Converts to lower case

-   Adds an underscore in-between the abbreviated tool name and question number

## Initializing Variables

### Lists of Variables to Exclude

We kept a running list of variables to exclude from each data set during processing.

```{r}
dropping <- list(
  'v1' = c(), 'v2' = c(), 'v3' = c(), 'v4' = c(), 'v5' = c(), 'redcap' = c()
  )
```

### Source List

The list of sources is used by the helper function `flag_unmatching_variables()`

```{r}
source_list <- list(
  'v1' = v1, 'v2' = v2, 'v3' = v3, 'v4' = v4, 'v5' = v5, 'redcap' = redcap
  )
```

### List of Section Maps

We initiated a list of our sections, which we would build in order, with an initial placeholder.
This placeholder entry would be removed prior to utilizing the list, but was named for easier removal.

```{r}
all_sections <- list("placeholder" = c())
```

## Administrative Section

The Administrative section is composed of the variables that primarily served administrative and/or bookkeeping purposes, such as subject ID, visit number, and group assignment.

It is not a specific instrument.

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "TODAY", "SUBJECT", "II", "VISIT", "TEST", "VISIT_TYPE", 
    "ENDTIME", "ETIME", "CTIME", "GROUP"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# "TODAY_V1"   "SUBJECT"    "SUBJECT1"   "II_V1"      "VISIT_TYPE" 
# "VISIT_V1"   "TEST_V1"    "ENDTIME1"  "ETIME_V1"   "CTIME_V1"  
```

We checked to see if any of these variables were only missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "SUBJECT1 is only missing values" "TEST_V1 is only missing values" 
```

We found that `SUBJECT1` and `TEST_V1` contained only missing values, and so they added to our list of variables to drop from the QDS V1 data set.

We manually explored and identified the pertinent REDCap variables for the Administrative Section.

```{r}
red_vars <- redcap %>%
  select(
    'record_id', 'visit_date', 'ii', 'group', 'visit', 'redcap_event_name',
    'ii_v1', 'visit_v1', 'email',
    'macarthur_major_discrimination_timestamp',
    'macarthur_major_discrimination_timestamp', 
    'macarthur_major_discrimination_complete',
    'perceived_stress_scale_timestamp', 
    'perceived_stress_scale_complete'
    ) %>%
  names()

red_vars

#  [1] "record_id"                               
#  [2] "visit_date"                              
#  [3] "ii"                                      
#  [4] "group"                                   
#  [5] "visit"                                   
#  [6] "redcap_event_name"                       
#  [7] "ii_v1"                                   
#  [8] "visit_v1"                                
#  [9] "email"                                   
# [10] "macarthur_major_discrimination_timestamp"
# [11] "macarthur_major_discrimination_complete" 
# [12] "perceived_stress_scale_timestamp"        
# [13] "perceived_stress_scale_complete"    
```

We checked to see if any of these REDCap variables were only missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "ii_v1 is only missing values"  "visit_v1 is only missing values"
# [3] "macarthur_major_discrimination_timestamp is only missing values"
```

All three of the Master Log variables were appropriate for this section.

```{r}
master_log_vars <- master_log %>%
  select(all_of(c(
    "id", "group", "age"
    ))
  ) %>%
  names()

master_log_vars

# [1] "id"    "group" "age"  
```

We identified the Timeline Follow Back variables appropriate for this section.

```{r}
tlfb_vars <- tlfb %>%
  select(all_of(c(
    "ParticipantID", "Visit", "Days_Followed", "Flag_OutofWindow"
    ))
  ) %>%
  names()

tlfb_vars

# [1] "ParticipantID"    "Visit"            "Days_Followed"   
# [4] "Flag_OutofWindow"
```

We set our initial desired order and standardization using the QDS variables, including a point-fix of a desired variable standardization. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
dropping[['v1']] <- c(dropping[['v1']], 'SUBJECT1', 'TEST_V1')

vars_v1 <- v1 %>%
  select(
    'SUBJECT', 'VISIT_V1', 'VISIT_TYPE', 'TODAY_V1', 
    'II_V1','CTIME_V1', 'ENDTIME1', "ETIME_V1"
    ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)
desired_vars[desired_vars == 'endtime_1'] <- 'endtime'

desired_vars

# [1] "subject"    "visit"      "visit_type" "today"      "ii"        
# [6] "ctime"      "endtime"    "etime"  
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "subject" in both REDCap and QDS corresponded to the item "Subject ID"). 

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: II_V1, II_V2
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: ii, ii_v1, 
# visit, visit_v1
# [1] "In source  v1 : SUBJECT1, TEST_V1, ENDTIME1"                         
# [2] "In source  v2 : II_V1, II_V2, TEST_V2, ENDTIME2"                     
# [3] "In source  v3 : TEST_V3, ENDTIME3, GROUP"                            
# [4] "In source  v4 : TEST_V4, ENDTIME4, GROUP"                            
# [5] "In source  v5 : TEST_V5, ENDTIME5, GROUP"                            
# [6] "In source  redcap : ii_v1, visit_date, visit_gender, visit_v1, group"
```

We checked if any of these flagged variables contained only empty values.

```{r}
# DATA CHECK: checking if variables only contain missing values.

missing_vars <- c()
message <- c()

for (source_name in unique(flagged_vars$source)){
  
  # Iterate through each source
  source_df <- source_list[[source_name]]
  # Iterate through the variables, print message if all empty.
    for (
      var in 
         flagged_vars[flagged_vars$source == source_name, ]$flagged_var
         ){
      if(sum(!is.na(source_df[,var])) == 0){
        missing_vars <- c(missing_vars, var)
        message <- c(message, 
                     paste(var,"in", source_name, "is only missing values"))
      }
    }
}
if (length(message)>0){
  print(message)
}

# [1] "SUBJECT1 in v1 is only missing values"    
# [2] "TEST_V1 in v1 is only missing values"     
# [3] "TEST_V2 in v2 is only missing values"     
# [4] "TEST_V3 in v3 is only missing values"     
# [5] "TEST_V5 in v5 is only missing values"     
# [6] "ii_v1 in redcap is only missing values"   
# [7] "visit_v1 in redcap is only missing values"
```

We identified variables to exclude:
-   The empty 'TEST' variables
-   The empty `SUBJECT1` variable
-   We manually checked TEST_V4 in the QDS Visit 4 data set, and determined it should be dropped as well.
-   We manually verified 'II_V1' and 'II_V2' in QDS Visit 2, and determined 'II_V1' was an erroneous addition to this data set (and thus dropped).

```{r}
dropping[['v1']] <- c(dropping[['v1']], 'TEST_V1', 'SUBJECT1')
dropping[['v2']] <- c(dropping[['v2']], 'II_V1', 'TEST_V2')
dropping[['v3']] <- c(dropping[['v3']], 'TEST_V3')
dropping[['v4']] <- c(dropping[['v4']], 'TEST_V4')
dropping[['v5']] <- c(dropping[['v5']], 'TEST_V5')

dropping[['redcap']] <- c(
  dropping[['redcap']], 'ii_v1', 'visit_v1'
)
```


We identified variables we wished to add to our desired variables:
-   The `group` variable was added from QDS Visit 3 onward 
-   The variables introduced in the REDCap data set
-   The `age` variable from the Master Log
-   The variables from the Timeline Follow Back data

The 'ENDTIME' variables simply violated the ability of our standardization function to correct, and thus it would have to be manually assigned from each data set.

```{r}
# QDS "group" variable
desired_vars <- append(desired_vars, 'group', 1)

# REDCAP variables
desired_vars <- append(desired_vars, 'redcap_event_name', 3)
desired_vars <- append(
  desired_vars, 
  c('maca_mdd_timestamp', 'maca_mdd_complete', 'ps_timestamp', 
    'ps_complete', 'email'), 
  length(desired_vars)
  )

# TLFB variables, excluding "ParticipantID" and "Visit" (already represented)
desired_vars <- append(
  desired_vars, 
  standardize_col_names(
    tlfb_vars[!(tlfb_vars %in% c("ParticipantID", "Visit"))]
    )
  )

# Master Log "age" variable
desired_vars <- append(desired_vars, 'age')

desired_vars

#  [1] "subject"           "group"             "visit"            
#  [4] "redcap_event_name" "visit_type"        "today"            
#  [7] "ii"                "ctime"             "endtime"          
# [10] "etime"             "maca_mdd_timestamp" "maca_mdd_complete" 
# [13] "ps_timestamp"      "ps_complete"       "email" 
```

We created our source maps, linking each source data set variable to the desired initially standardized variable name.

Each 'ENDTIME' variable in the QDS data required point-modification to ensure correct maping, as it evaded our standardization function.

As the REDCap, Master Log, and TLFB variable naming was significantly different from the QDS variable naming, we manually created our source map for these sets.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
      ) %>%
  mutate(variable = ifelse(variable == 'endtime_1', 'endtime', variable)
  ) %>%
  # V2
  full_join(vm_make_source_map(
    source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ) %>%
  mutate(variable = ifelse(variable == 'endtime_2', 'endtime', variable)
         ), 
  by = "variable"
  ) %>%
  # V3
  full_join(vm_make_source_map(
    source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ) %>%
  mutate(variable = ifelse(variable == 'endtime_3', 'endtime', variable)
         ),
  by = "variable"
  ) %>%
  # V4
  full_join(vm_make_source_map(
    source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ) %>%
  mutate(variable = ifelse(variable == 'endtime_4', 'endtime', variable)
         ),
  by = "variable"
  ) %>%
  # V5
  full_join(vm_make_source_map(
    source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ) %>%
  mutate(variable = ifelse(variable == 'endtime_5', 'endtime', variable)
         ),
  by = "variable"
  ) %>%
  # REDCAP
  full_join(tibble::tibble(
    'redcap' = (
      redcap %>%
        select(all_of(c(
            'ii', 'group', 'visit', 'redcap_event_name', 'visit_date', 
            'record_id', 'email',
            'macarthur_major_discrimination_timestamp',
            'macarthur_major_discrimination_complete',
            'perceived_stress_scale_timestamp', 
            'perceived_stress_scale_complete'
            ))
          ) %>%
        names()
    ),
    'variable' = c(
        'ii', 'group', 'visit', 'redcap_event_name', 'today', 
        'subject', 'email',
        'maca_mdd_timestamp',
        'maca_mdd_complete',
        'ps_timestamp', 
        'ps_complete'
        )
    ),
  by = "variable"
  ) %>%
  # Master Log
  full_join(tibble::tibble(
    'master_log' = (
      master_log %>%
        select(all_of(c(
          'id', 'group', 'age'
          ))
          ) %>%
        names()
    ),
    'variable' = c(
        'subject', 'group', 'age'
        )
    ),
  by = "variable"
  ) %>%
  # TLFB
  full_join(tibble::tibble(
    'tlfb' = (
      tlfb %>%
        select(all_of(c(
          'ParticipantID', 'Visit', 'Days_Followed', 'Flag_OutofWindow'
          ))
          ) %>%
        names()
    ),
    'variable' = c(
        'subject', 'visit', 
        standardize_col_names(c('Days_Followed', 'Flag_OutofWindow'))
        )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

All three values from the Master Log (`id`, `group`, `age`) would appropriately fit within this section. We added the `age` variable to the desired variable list, manually set the source_map for the Master Log, and added it to the source maps for this section.

```{r}
desired_vars <- append(desired_vars, 'age')

master_log_map <- tibble::tibble(
      'master_log' = colnames(master_log),
      'variable' = c('subject', 'group', 'age')
    )

source_maps <- full_join(source_maps, master_log_map, by = 'variable')
source_maps
```


We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument('Administrative', desired_vars) %>%
  left_join(source_maps, by = 'variable')

inst_map
```

### Joining Section

As the administrative section was a single instrument, we created our section.

```{r}
sec_map <- vm_join_inst_section('Administrative', list(inst_map))

sec_map
```

We added the section to our overall list, and purged the instrument & section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('admin' = sec_map))
rm(inst_map)
rm(sec_map)
```

## Screening Section

Screening was performed with 5 instruments: Screening Questionnaire, Mini-Mental State Exam, Rapid Estimate of Adult Literacy in Medicine (REALM), BiologicalMeasures/Anthropometrics, and a Locator Form.

We initiated an empty list of the instruments for this section, which we would build in order.
This placeholder would be removed prior to utilizing the list, but was named for easier removal.

```{r}
sec_instruments <- list("placeholder" = c())
```

### Screening Questionnaire

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "SQ"
  ), 
  'contains' = c("GENDER")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "SQ_2"   "SQ_3"   "SQ_4"   "SQ_5"   "SQ_6"   "SQ_7"   "SQ_7A" 
#  [8] "SQ_7B"  "SQ_7C"  "SQ_7D"  "SQ_8"   "SQ_9"   "SQ_9L"  "SQ_10" 
# [15] "SQ_11"  "SQ_12"  "SQ_13"  "SQ_14"  "SQ_15"  "SQ_16"  "SQ_17" 
# [22] "SQ_18"  "SQ_19"  "SQ_20"  "SQ_21"  "SQ_22"  "SQ_23"  "SQ_18A"
# [29] "SQ_18B" "SQ_18C" "SQ_18D" "SQ_18E" "SQ_18F" "SQ_18G" "SQ_18H"
# [36] "SQ_18I" "SQ_22A" "SQ_22B" "SQ_22C" "SQ_22D" "SQ_22E" "SQ_22F"
# [43] "SQ_22G" "SQ_22H" "GENDER"
```

We checked to see if any of these QDS variables were only missing values, and found none.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars

#  [1] "sq_2"         "sq_3"         "sq_4"         "sq_5"        
#  [5] "sq_6"         "sq_7"         "sq_7a"        "sq_7b1"      
#  [9] "sq_7b2"       "sq_7d"        "sq_8"         "sq_9"        
# [13] "sq_9l"        "sq_10"        "sq_11"        "sq_12"       
# [17] "sq_13"        "sq_14"        "sq_15"        "sq_16"       
# [21] "sq_17"        "sq_18___0"    "sq_18___1"    "sq_18___2"   
# [25] "sq_18___3"    "sq_18___4"    "sq_18___5"    "sq_18___6"   
# [29] "sq_18___7"    "sq_18___8"    "sq_19"        "sq_20"       
# [33] "sq_21"        "sq_22___0"    "sq_22___1"    "sq_22___2"   
# [37] "sq_22___3"    "sq_22___4"    "sq_22___5"    "sq_22___6"   
# [41] "sq_22___7"    "sq_23"        "visit_gender" "gender"  
```


We checked to see if any of these variables were only missing values in the REDCap. We found that 26 of our 44 variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}

print(message)

#  [1] "sq_2 is only missing values"   "sq_3 is only missing values"  
#  [3] "sq_4 is only missing values"   "sq_5 is only missing values"  
#  [5] "sq_6 is only missing values"   "sq_7 is only missing values"  
#  [7] "sq_7a is only missing values"  "sq_7b1 is only missing values"
#  [9] "sq_7b2 is only missing values" "sq_7d is only missing values" 
# [11] "sq_8 is only missing values"   "sq_9 is only missing values"  
# [13] "sq_9l is only missing values"  "sq_10 is only missing values" 
# [15] "sq_11 is only missing values"  "sq_12 is only missing values" 
# [17] "sq_13 is only missing values"  "sq_14 is only missing values" 
# [19] "sq_15 is only missing values"  "sq_16 is only missing values" 
# [21] "sq_17 is only missing values"  "sq_19 is only missing values" 
# [23] "sq_20 is only missing values"  "sq_21 is only missing values" 
# [25] "sq_23 is only missing values"  "gender is only missing values"
```

We set our initial desired order and standardization using the QDS variables.
We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'GENDER', 'SQ_2', 'SQ_3', 'SQ_4', 'SQ_5', 'SQ_6', 'SQ_7', 
  'SQ_7A', 'SQ_7B', 'SQ_7C', 'SQ_7D', 'SQ_8', 'SQ_9', 'SQ_9L', 
  'SQ_10', 'SQ_11', 'SQ_12', 'SQ_13', 'SQ_14', 'SQ_15', 'SQ_16', 
  'SQ_17', 'SQ_18', 'SQ_18A', 'SQ_18B', 'SQ_18C', 'SQ_18D', 'SQ_18E',
  'SQ_18F', 'SQ_18G', 'SQ_18H', 'SQ_18I', 'SQ_19', 'SQ_20', 'SQ_21', 
  'SQ_22', 'SQ_22A', 'SQ_22B', 'SQ_22C', 'SQ_22D', 'SQ_22E', 'SQ_22F',
  'SQ_22G', 'SQ_22H', 'SQ_23'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

#  [1] "gender" "sq_2"   "sq_3"   "sq_4"   "sq_5"   "sq_6"   "sq_7"  
#  [8] "sq_7a"  "sq_7b"  "sq_7c"  "sq_7d"  "sq_8"   "sq_9"   "sq_9l" 
# [15] "sq_10"  "sq_11"  "sq_12"  "sq_13"  "sq_14"  "sq_15"  "sq_16" 
# [22] "sq_17"  "sq_18"  "sq_18a" "sq_18b" "sq_18c" "sq_18d" "sq_18e"
# [29] "sq_18f" "sq_18g" "sq_18h" "sq_18i" "sq_19"  "sq_20"  "sq_21" 
# [36] "sq_22"  "sq_22a" "sq_22b" "sq_22c" "sq_22d" "sq_22e" "sq_22f"
# [43] "sq_22g" "sq_22h" "sq_23" 
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "sq_2" in both REDCap and QDS corresponded to the item "Are you Hispanic or Latino?"). 

We determined that QDS item `sq_7` corresponded to REDCap item `sq_7b2` and `sq_7b1` was an addition in the REDCap data, as the item was divided in the REDCap format. The dummy categorical variables for the select all that apply questions `sq_18` and `sq_22` would require manual renaming, as they were not compatible with our standardization function.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(
  source_list, 
  desired_vars, incl_keys, excl_keys
  )

# [1] "In source  v1 : "       
# [2] "In source  v2 : "      
# [3] "In source  v3 : "       
# [4] "In source  v4 : "    
# [5] "In source  v5 : " 
# [6] "In source  redcap : sq_7b1, sq_7b2, sq_18___0, sq_18___1, sq_18___2, 
# sq_18___3, sq_18___4, sq_18___5, sq_18___6, sq_18___7, sq_18___8, sq_22___0,
# sq_22___1, sq_22___2, sq_22___3, sq_22___4, sq_22___5, sq_22___6, sq_22___7,
# visit_gender"
```

We dropped the `gender` variable which only contained missing values, in favor of standardizing the `visit_gender` variable which did contain the pertinent values to `gender`. We added the new `sq_7b_1` variable to our list of desired variables after our QDS `sq_7b`, and planned to map the REDCap `sq_7b_2` to the QDS `sq_7b`. 

```{r}
dropping[['redcap']] <- c(
  dropping[['redcap']], 'gender'
)

desired_vars <- append(
  desired_vars, 'sq_7b_1', which(desired_vars == 'sq_7b')
                       )

desired_vars

#  [1] "gender"  "sq_2"    "sq_3"    "sq_4"    "sq_5"    "sq_6"   
#  [7] "sq_7"    "sq_7a"   "sq_7b"   "sq_7b_1" "sq_7c"   "sq_7d"  
# [13] "sq_8"    "sq_9"    "sq_9l"   "sq_10"   "sq_11"   "sq_12"  
# [19] "sq_13"   "sq_14"   "sq_15"   "sq_16"   "sq_17"   "sq_18"  
# [25] "sq_18a"  "sq_18b"  "sq_18c"  "sq_18d"  "sq_18e"  "sq_18f" 
# [31] "sq_18g"  "sq_18h"  "sq_18i"  "sq_19"   "sq_20"   "sq_21"  
# [37] "sq_22"   "sq_22a"  "sq_22b"  "sq_22c"  "sq_22d"  "sq_22e" 
# [43] "sq_22f"  "sq_22g"  "sq_22h"  "sq_23"  
```

We created our source maps, including the required point-fixes.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(vm_make_source_map(
    source_list, dropping, 6, 'redcap', incl_keys, excl_keys
    ) %>%
    mutate(variable = case_when(
      variable == 'visit_gender' ~ 'gender',
      variable == 'sq_7b_2' ~ 'sq_7b',
      variable == 'sq_18_0' ~ 'sq_18a',
      variable == 'sq_18_1' ~ 'sq_18b',
      variable == 'sq_18_2' ~ 'sq_18c',
      variable == 'sq_18_3' ~ 'sq_18d',
      variable == 'sq_18_4' ~ 'sq_18e',
      variable == 'sq_18_5' ~ 'sq_18f',
      variable == 'sq_18_6' ~ 'sq_18g',
      variable == 'sq_18_7' ~ 'sq_18h',
      variable == 'sq_18_8' ~ 'sq_18i',
      variable == 'sq_22_0' ~ 'sq_22a',
      variable == 'sq_22_1' ~ 'sq_22b',
      variable == 'sq_22_2' ~ 'sq_22c',
      variable == 'sq_22_3' ~ 'sq_22d',
      variable == 'sq_22_4' ~ 'sq_22e',
      variable == 'sq_22_5' ~ 'sq_22f',
      variable == 'sq_22_6' ~ 'sq_22g',
      variable == 'sq_22_7' ~ 'sq_22h',
      TRUE ~ variable
    )
  ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Screening Instrument', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('screening' = inst_map))

rm(inst_map)
```

### Mini-Mental State Exam

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "MMS", "RECAL", "COUNT", "NUM", "OBJECT", "PAPER"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "MMS_1A"       "MMS_1B"       "MMS_1C"       "MMS_1D"      
#  [5] "MMS_1E"       "MMS_1"        "MMS_2A"       "MMS_2B"      
#  [9] "MMS_2C"       "MMS_2D"       "MMS_2E"       "MMS_2"       
# [13] "MMS_3"        "MMS_4"        "MMS4V"        "MMS_5"       
# [17] "MMS_6"        "MMS_7"        "MMS_8"        "MMS_9"       
# [21] "MMS_10"       "MMS_11"       "MMS_S"        "MMS_3G"      
# [25] "MMS_3H"       "MMS_3I"       "MMS_3J"       "MMS_4A"      
# [29] "MMS_4B"       "MMS_4C"       "MMS_4D"       "MMS_4E"      
# [33] "MMS_4F"       "MMS4VA"       "MMS4VB"       "MMS4VC"      
# [37] "MMS4VD"       "MMS4VE"       "MMS4VF"       "MMS_5A"      
# [41] "MMS_5B"       "MMS_5C"       "MMS_5D"       "MMS_6A"      
# [45] "MMS_6B"       "MMS_6C"       "MMS_8A"       "MMS_8B"      
# [49] "MMS_8C"       "MMS_8D"       "mms_score"    "MMS_total"   
# [53] "MMS_severity" "RECAL1"       "RECAL2"       "COUNT"       
# [57] "NUM"          "OBJECT"       "PAPER"   
```

We checked to see if any of these variables were only missing values, and found none.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "mms_1a"    "mms_1b"    "mms_1c"    "mms_1d"    "mms_1e"   
#  [6] "mms_2a"    "mms_2b"    "mms_2c"    "mms_2d"    "mms_2e"   
# [11] "mms_3___1" "mms_3___2" "mms_3___3" "mms_3___0" "mms_4___0"
# [16] "mms_4___1" "mms_4___2" "mms_4___3" "mms_4___4" "mms_4___5"
# [21] "mms4v___1" "mms4v___2" "mms4v___3" "mms4v___4" "mms4v___5"
# [26] "mms4v___0" "mms_5___1" "mms_5___2" "mms_5___3" "mms_5___0"
# [31] "mms_6___1" "mms_6___2" "mms_6___0" "mms_7"     "mms_8___1"
# [36] "mms_8___2" "mms_8___3" "mms_8___0" "mms_9"     "mms_10"   
# [41] "mms_11"
```

We checked to see if any of these variables were only missing values in the REDCap. We found that 14 of our 41 variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

#  [1] "mms_1a is only missing values" "mms_1b is only missing values"
#  [3] "mms_1c is only missing values" "mms_1d is only missing values"
#  [5] "mms_1e is only missing values" "mms_2a is only missing values"
#  [7] "mms_2b is only missing values" "mms_2c is only missing values"
#  [9] "mms_2d is only missing values" "mms_2e is only missing values"
# [11] "mms_7 is only missing values"  "mms_9 is only missing values" 
# [13] "mms_10 is only missing values" "mms_11 is only missing values"
```

We set our initial desired order and standardization using the QDS variables.
We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'MMS_1', 'MMS_1A', 'MMS_1B', 'MMS_1C', 'MMS_1D', 'MMS_1E', 'MMS_2',
  'MMS_2A', 'MMS_2B', 'MMS_2C', 'MMS_2D', 'MMS_2E', 'MMS_3', 'MMS_3G',
  'MMS_3H', 'MMS_3I', 'MMS_3J', 'RECAL1', 'MMS_4', 'MMS_4A', 'MMS_4B',
  'MMS_4C', 'MMS_4D', 'MMS_4E', 'MMS_4F', 'COUNT', 'MMS4V', 'MMS4VA',
  'MMS4VB', 'MMS4VC', 'MMS4VD', 'MMS4VE', 'MMS4VF', 'NUM', 'MMS_5', 'MMS_5A',
  'MMS_5B', 'MMS_5C', 'MMS_5D', 'RECAL2', 'MMS_6', 'MMS_6A', 'MMS_6B',
  'MMS_6C', 'OBJECT', 'MMS_7', 'MMS_8', 'MMS_8A', 'MMS_8B', 'MMS_8C',
  'MMS_8D', 'PAPER', 'MMS_9', 'MMS_10', 'MMS_11', 'MMS_S'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

#  [1] "mms_1"   "mms_1a"  "mms_1b"  "mms_1c"  "mms_1d"  "mms_1e" 
#  [7] "mms_2"   "mms_2a"  "mms_2b"  "mms_2c"  "mms_2d"  "mms_2e" 
# [13] "mms_3"   "mms_3g"  "mms_3h"  "mms_3i"  "mms_3j"  "recal_1"
# [19] "mms_4"   "mms_4a"  "mms_4b"  "mms_4c"  "mms_4d"  "mms_4e" 
# [25] "mms_4f"  "count"   "mms_4v"  "mms_4va" "mms_4vb" "mms_4vc"
# [31] "mms_4vd" "mms_4ve" "mms_4vf" "num"     "mms_5"   "mms_5a" 
# [37] "mms_5b"  "mms_5c"  "mms_5d"  "recal_2" "mms_6"   "mms_6a" 
# [43] "mms_6b"  "mms_6c"  "object"  "mms_7"   "mms_8"   "mms_8a" 
# [49] "mms_8b"  "mms_8c"  "mms_8d"  "paper"   "mms_9"   "mms_10" 
# [55] "mms_11"  "mms_s"  
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "mms_1a" in both REDCap and QDS corresponded to the item "What year is it?"). 

We identified `mms_score`, `MMS_total`, and `MMS_severity` as SPSS calculated variables we wished to drop. We also found variable name variations in both QDS Visit 5 and the REDCap data which evaded our standardization function, and would require manual assignment.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: MMS_4_V5, 
# MMS4_V5, MMS_4_V5A, MMS4_V5A, MMS_4_V5B, MMS4_V5B, MMS_4_V5C, MMS4_V5C, 
# MMS_4_V5D, MMS4_V5D, MMS_4_V5E, MMS4_V5E, MMS_4_V5F, MMS4_V5F
# [1] "In source  v1 : mms_score, MMS_total, MMS_severity"          
# [2] "In source  v2 : "                         
# [3] "In source  v3 : "  
# [4] "In source  v4 : "   
# [5] "In source  v5 : MMS_1D_5, MMS_4_V5, MMS4_V5, MMS_4_V5A, MMS_4_V5B, 
# MMS_4_V5C, MMS_4_V5D, MMS_4_V5E, MMS_4_V5F, MMS4_V5A, MMS4_V5B, MMS4_V5C, 
# MMS4_V5D, MMS4_V5E, MMS4_V5F, mms_score_V5, MMS_total_V5, MMS_severity_V5"
# [6] "In source  redcap : mms_3___1, mms_3___2, mms_3___3, mms_3___0, 
# mms_4___0, mms_4___1, mms_4___2, mms_4___3, mms_4___4, mms_4___5, mms4v___1,
# mms4v___2, mms4v___3, mms4v___4, mms4v___5, mms4v___0, mms_5___1, mms_5___2,
# mms_5___3, mms_5___0, mms_6___1, mms_6___2, mms_6___0, mms_8___1, mms_8___2,
# mms_8___3, mms_8___0"
```

We checked if any of these flagged variables contained only empty values, and found none.

```{r}
# DATA CHECK: checking if variables only contain missing values.

missing_vars <- c()
message <- c()

for (source_name in unique(flagged_vars$source)){
  
  # Iterate through each source
  source_df <- source_list[[source_name]]
  # Iterate through the variables, print message if all empty.
    for (
      var in 
         flagged_vars[flagged_vars$source == source_name, ]$flagged_var
         ){
      if(sum(!is.na(source_df[,var])) == 0){
        missing_vars <- c(missing_vars, var)
        message <- c(message, 
                     paste(var,"in", source_name, "is only missing values"))
      }
    }
}
if (length(message)>0){
  print(message)
}
```

We dropped the SPSS calculated variables `mms_score`, `MMS_total`, and `MMS_severity`.

```{r}
dropping[['v1']] <- c(
  dropping[['v2']], 'mms_score', 'MMS_total', 'MMS_severity'
  )
dropping[['v5']] <- c(
  dropping[['v5']], 'mms_score_V5', 'MMS_total_V5', 'MMS_severity_V5')
```

We created our source maps, linking each source data set variable to the desired initially standardized variable name.

Several of the QDS Visit 5 and REDCap variables required point-corrections due to the unique naming issues evading our standardization function.

```{r, warning=FALSE}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
    source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ),
  by = "variable"
  ) %>%
  # V3
  full_join(vm_make_source_map(
    source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ),
  by = "variable"
  ) %>%
  # V4
  full_join(vm_make_source_map(
    source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ),
  by = "variable"
  ) %>%
  # V5
  full_join(vm_make_source_map(
    source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
    variable == 'mms_1d_5' ~ 'mms_1d',
    variable == 'MMS_4_V5' ~ 'mms_4v',
    variable == 'MMS4_V5' ~ 'mms_4',
    variable == 'MMS_4_V5A' ~ 'mms_4a',
    variable == 'MMS_4_V5B' ~ 'mms_4b',
    variable == 'MMS_4_V5C' ~ 'mms_4c',
    variable == 'MMS_4_V5D' ~ 'mms_4d',
    variable == 'MMS_4_V5E' ~ 'mms_4e',
    variable == 'MMS_4_V5F' ~ 'mms_4f',
    variable == 'MMS4_V5A' ~ 'mms_4va',
    variable == 'MMS4_V5B' ~ 'mms_4vb',
    variable == 'MMS4_V5C' ~ 'mms_4vc',
    variable == 'MMS4_V5D' ~ 'mms_4vd',
    variable == 'MMS4_V5E' ~ 'mms_4ve',
    variable == 'MMS4_V5F' ~ 'mms_4vf',
    TRUE ~ variable)
         ),
  by = "variable"
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'mms_3_1' ~ 'mms_3g',
      variable == 'mms_3_2' ~ 'mms_3h',
      variable == 'mms_3_3' ~ 'mms_3i',
      variable == 'mms_3_0' ~ 'mms_3j',
      variable == 'mms_4_1' ~ 'mms_4a',
      variable == 'mms_4_2' ~ 'mms_4b',
      variable == 'mms_4_3' ~ 'mms_4c',
      variable == 'mms_4_4' ~ 'mms_4d',
      variable == 'mms_4_5' ~ 'mms_4e',
      variable == 'mms_4_0' ~ 'mms_4f',
      variable == 'mms_4v_1' ~ 'mms_4va',
      variable == 'mms_4v_2' ~ 'mms_4vb',
      variable == 'mms_4v_3' ~ 'mms_4vc',
      variable == 'mms_4v_4' ~ 'mms_4vd',
      variable == 'mms_4v_5' ~ 'mms_4ve',
      variable == 'mms_4v_0' ~ 'mms_4vf',
      variable == 'mms_5_1' ~ 'mms_5a',
      variable == 'mms_5_2' ~ 'mms_5b',
      variable == 'mms_5_3' ~ 'mms_5c',
      variable == 'mms_5_0' ~ 'mms_5d',
      variable == 'mms_6_1' ~ 'mms_6a',
      variable == 'mms_6_2' ~ 'mms_6b',
      variable == 'mms_6_0' ~ 'mms_6c',
      variable == 'mms_8_1' ~ 'mms_8a',
      variable == 'mms_8_2' ~ 'mms_8b',
      variable == 'mms_8_3' ~ 'mms_8c',
      variable == 'mms_8_0' ~ 'mms_8d',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Mini-Mental State Exam (MMSE)', desired_vars
  ) %>%
  left_join(source_maps, by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('mmse' = inst_map))

rm(inst_map)
```

### Rapid Estimate of Adult Literacy in Medicine (REALM)

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "REALM"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

 # [1] "REALM"   "REALM_S" "REALMA"  "REALMB"  "REALMC"  "REALMD" 
 # [7] "REALME"  "REALMF"  "REALMG"  "REALMH"  "REALMI"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "realm___0"   "realm___1"   "realm___2"   "realm___3"  
 # [5] "realm___4"   "realm___5"   "realm___6"   "realm___7"  
 # [9] "realm___8"   "realm_score"
```

We checked to see if any of these variables were only missing values in the REDCap. We found that the variable `realm_score` only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "realm_score is only missing values"
```

We set our initial desired order and standardization based on the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'REALM', 'REALMA', 'REALMB', 'REALMC', 'REALMD', 'REALME', 'REALMF',
    'REALMG', 'REALMH', 'REALMI', 'REALM_S'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

 # [1] "realm"   "realma"  "realmb"  "realmc"  "realmd"  "realme" 
 # [7] "realmf"  "realmg"  "realmh"  "realmi"  "realm_s"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "realm_a" in QDS and "ream_0" in REDCap corresponded to the item "Fat"). We found that our REDCap variables all escaped our standardization function.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                                    
# [2] "In source  v2 : "                                    
# [3] "In source  v3 : "                                    
# [4] "In source  v4 : "                                    
# [5] "In source  v5 : "                               
# [6] "In source  redcap : realm___0, realm___1, realm___2, realm___3, 
# realm___4, realm___5, realm___6, realm___7, realm___8, realm_score"
```

We created our source maps, including the required manual assignment of variable names for the REDCap data sets.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'realm_0' ~ 'realma',
      variable == 'realm_1' ~ 'realmb',
      variable == 'realm_2' ~ 'realmc',
      variable == 'realm_3' ~ 'realmd',
      variable == 'realm_4' ~ 'realme',
      variable == 'realm_5' ~ 'realmf',
      variable == 'realm_6' ~ 'realmg',
      variable == 'realm_7' ~ 'realmh',
      variable == 'realm_8' ~ 'realmi',
      variable == 'realm_score' ~ 'realm_s',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Rapid Estimate of Adult Literacy in Medicine (REALM)', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('realm' = inst_map))

rm(inst_map)
```

### Anthropometrics

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "HEIGHT", "CO", "READ", "WAIST_C", "BMI"
  ), 
  'contains' = c(
    "WEIGHT", "BMI", "OBESE"
    )
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c("COUNT"),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()


vars_v1

#  [1] "HEIGHT"             "height_meter_V1"    "height_meter_sq_V1"
#  [4] "CO_V1"              "READ1_V1"           "READ2_V1"          
#  [7] "READ3_V5"           "WAIST_C"            "BMI_V1"            
# [10] "WEIGHT"             "weight_kg_V1"       "weight_status_V1"  
# [13] "obese_V1"           "ovrwt_obese_V1"    
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "read1_v1" "read2_v1" "read3_v5"
```

We checked to see if any of these variables were only missing values in the REDCap. We found that all three of our variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "read1_v1 is only missing values" "read2_v1 is only missing values"
# [3] "read3_v5 is only missing values"
```

We set our initial desired order and standardization utilizing the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

The SPSS calculated variables `weight_kg_V1`, `weight_status_V1`, `height_meter_V1`, `height_meter_sq_V1`, `BMI_V1`, `obese_V1`, and `ovrwt_obese_V1` were excluded.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'WEIGHT', 'HEIGHT', 'WAIST_C', 'CO_V1', 'READ1_V1', 'READ2_V1',
    'READ3_V5'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

# [1] "weight"  "height"  "waist_c" "co"      "read_1"  "read_2" 
# [7] "read_3" 
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "read_1" in both REDCap and QDS corresponded to the item "Do you use reading glasses?"). 

We identified the variations of the SPSS calculated variables we wished to drop, and naming conventions which escaped our standardizing function.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : HEIGHT, height_meter_V1, height_meter_sq_V1, CO_V1, 
# READ1_V1, READ2_V1, READ3_V5, WAIST_C, BMI_V1, WEIGHT, weight_kg_V1, 
# weight_status_V1, obese_V1, ovrwt_obese_V1"      
# [2] "In source  v2 : READ1_V2, READ2_V2, READ3_V2"     
# [3] "In source  v3 : HEIGHT_3, height_meter_V3, height_meter_sq_V3, CO_V3, 
# READ1_V3, READ2_V3, READ3_V3, WAIST_C3, BMI_V3, WEIGHT_3, weight_kg_V3, 
# weight_status_V3, obese_V3, ovrwt_obese_V3" 
# [4] "In source  v4 : HEIGHT, height_meter_V4, height_meter_sq_V4, CO_V4, 
# READ1_V4, READ2_V4, READ3_V4, WAIST_C4, BMI_V4, WEIGHT_4, weight_kg_V4, 
# weight_status_V4, obese_V4, ovrwt_obese_V4"   
# [5] "In source  v5 : HEIGHT_V5, height_meter_V5, height_meter_sq_V5, CO_V5, 
# READ1_V5, READ2_V5, READ3_V5, WAIST_C5, BMI_V5, WEIGHT_5, weight_kg_V5, 
#weight_status_V5, obese_V5, ovrwt_obese_V5"
# [6] "In source  redcap : "     
```

We dropped our SPSS calculated variables from all data sets.

```{r}
dropping[['v1']] <- c(
  dropping[['v1']], 'weight_kg_V1', 'weight_status_V1', 'height_meter_V1',
  'height_meter_sq_V1', 'BMI_V1', 'obese_V1', 'ovrwt_obese_V1'
  )
dropping[['v3']] <- c(
  dropping[['v3']], 'weight_kg_V3', 'weight_status_V3', 'height_meter_V3',
  'height_meter_sq_V3', 'BMI_V3', 'obese_V3', 'ovrwt_obese_V3'
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'weight_kg_V4', 'weight_status_V4', 'height_meter_V4',
  'height_meter_sq_V4', 'BMI_V4', 'obese_V4', 'ovrwt_obese_V4'
  )
dropping[['v5']] <- c(
  dropping[['v5']], 'weight_kg_V5', 'weight_status_V5', 'height_meter_V5',
  'height_meter_sq_V5', 'BMI_V5', 'obese_V5', 'ovrwt_obese_V5'
  )
```

We created our source maps, with point-fixes to the variables that escaped our standardizing function

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'waist_c_3' ~ 'waist_c',
        variable == 'height_3' ~ 'height',
        variable == 'weight_3' ~'weight',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'waist_c_4' ~ 'waist_c',
        variable == 'weight_4' ~'weight',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'waist_c_5' ~ 'waist_c',
        variable == 'weight_5' ~'weight',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Anthropometrics', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('anthrop' = inst_map))

rm(inst_map)
```

### Locator Form 🔴 - PLACEHOLDER

### Joining Section

We purged the placeholder from our section-wise list of instruments, and joined our section map.

```{r}
sec_instruments <- sec_instruments[names(sec_instruments) != "placeholder"]

sec_map <- vm_join_inst_section(
  'Screening', sec_instruments
  )

sec_map
```

We added the section to our overall list of sections, and purged the section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('screening' = sec_map))

rm(sec_map)
```

## Socioeconomic Status/Demographics/Homelessness/Criminal History Section

The section of Sociodemographics contained 3 instruments: Demographic/Background Information Questionnaire, Brief Homelessness Questionnaire, and the MacArthur Scale of Subjective Social Status.

We initiated an empty list of the instruments for this section, which we would build in order.
This placeholder would be removed prior to utilizing the list, but was named for easier removal.

```{r}
sec_instruments <- list("placeholder" = c())
```

### Demographic Questionnaire

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "DEM", "DME"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "DEM1V1"   "DEM2V1"   "DEM3V1"   "DEM4V1"   "DEM5V1"   "DEM5AV1" 
#  [7] "DEM6V1"   "DEM6AV1"  "DEM7V1"   "DEM8V1"   "DEM9V1"   "DEM10V1" 
# [13] "DEM11V1"  "DEM12V1"  "DEM13V1"  "DEM13AV1" "DEM13BV1" "DEM13CV1"
# [19] "DEM13DV1" "DEM13EV1" "DEM13FV1" "DEM13GV1" "DEM13HV1" "DEM14V1" 
# [25] "DEM14AV1" "DEM14BV1" "DEM14CV1" "DEM14DV1" "DEM14EV1" "DEM14FV1"
# [31] "DEMO16G"  "DEM15V1"  "DEM16V1"  "DEM17V1"  "DEM18V1"  "DEM4V1A" 
# [37] "DEM4V1B"  "DEM4V1C"  "DEM4V1D"  "DEM4V1E"  "DEM4V1F"  "DEM7V1A" 
# [43] "DEM7V1B"  "DEM7V1C"  "DEM7V1D"  "DEM7V1E"  "DEM12V1A" "DEM12V1B"
# [49] "DEM12V1C" "DEM12V1D" "DEM12V1E" "DEM12V1F" "DEM12V1G" "DEM12V1H"
# [55] "DEM12V1I" "DEM12V1J" "DEM12V1K" "DEM12V1L" "DME6BV1" 
```

We checked to see if any of these variables were only missing values in Visit 1.

While `DEM13EV1` and `DEM14EV1` only contained empty values, we kept these variables for placement and completeness of the data.

```{r}
# DATA CHECK: checking if variable only contains missing values.
missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "DEM13EV1 is only missing values" "DEM14EV1 is only missing values"
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "dem1v1"       "dem2v1"       "dem3v1"       "dem4v1___1"  
#  [5] "dem4v1___2"   "dem4v1___3"   "dem4v1___4"   "dem4v1___5"  
#  [9] "dem4v1___6"   "dem5v1"       "dem5av1"      "dem6v1"      
# [13] "dem6av1"      "dem7v1___1"   "dem7v1___2"   "dem7v1___3"  
# [17] "dem7v1___4"   "dem7v1___5"   "dem8v1"       "dem9v1"      
# [21] "dem10v1"      "dem11v1"      "dem12v1___1"  "dem12v1___2" 
# [25] "dem12v1___3"  "dem12v1___4"  "dem12v1___5"  "dem12v1___6" 
# [29] "dem12v1___7"  "dem12v1___8"  "dem12v1___9"  "dem12v1___10"
# [33] "dem12v1___11" "dem12v1___12" "dem13v1"      "dem13av1"    
# [37] "dem13bv1"     "dem13cv1"     "dem13dv1"     "dem13ev1"    
# [41] "dem13fv1"     "dem13gv1"     "dem13hv1"     "dem14v1"     
# [45] "dem14av1"     "dem14bv1"     "dem14cv1"     "dem14dv1"    
# [49] "dem14ev1"     "dem14fv1"     "dem14gv1"     "dem15v1"     
# [53] "dem16v1"      "dem17v1"      "dem18v1"      "dme6bv3"   
```

We checked to see if any of these variables were only missing values in the REDCap. We found that 12 of our 56 variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

#  [1] "dem13av1 is only missing values" "dem13bv1 is only missing values"
#  [3] "dem13cv1 is only missing values" "dem13dv1 is only missing values"
#  [5] "dem13ev1 is only missing values" "dem13fv1 is only missing values"
#  [7] "dem13gv1 is only missing values" "dem13hv1 is only missing values"
#  [9] "dem14dv1 is only missing values" "dem14ev1 is only missing values"
# [11] "dem14fv1 is only missing values" "dem14gv1 is only missing values"
```

We set our initial desired order and standardization based on the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'DEM1V1', 'DEM2V1', 'DEM3V1', 'DEM4V1', 'DEM4V1A', 'DEM4V1B', 'DEM4V1C',
  'DEM4V1D', 'DEM4V1E', 'DEM4V1F', 'DEM5V1', 'DEM5AV1', 'DEM6V1', 'DEM6AV1',
  'DME6BV1', 'DEM7V1', 'DEM7V1A', 'DEM7V1B', 'DEM7V1C', 'DEM7V1D',
  'DEM7V1E', 'DEM8V1', 'DEM9V1', 'DEM10V1', 'DEM11V1', 'DEM12V1',
  'DEM12V1A', 'DEM12V1B', 'DEM12V1C', 'DEM12V1D', 'DEM12V1E', 'DEM12V1F',
  'DEM12V1G', 'DEM12V1H', 'DEM12V1I', 'DEM12V1J', 'DEM12V1K', 'DEM12V1L',
  'DEM13V1', 'DEM13AV1', 'DEM13BV1', 'DEM13CV1', 'DEM13DV1', 'DEM13EV1',
  'DEM13FV1', 'DEM13GV1', 'DEM13HV1', 'DEM14V1', 'DEM14AV1', 'DEM14BV1',
  'DEM14CV1', 'DEM14DV1', 'DEM14EV1', 'DEM14FV1', 'DEMO16G', 'DEM15V1',
  'DEM16V1', 'DEM17V1', 'DEM18V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

#  [1] "dem_1"    "dem_2"    "dem_3"    "dem_4"    "dem_4a"   "dem_4b"  
#  [7] "dem_4c"   "dem_4d"   "dem_4e"   "dem_4f"   "dem_5"    "dem_5a"  
# [13] "dem_6"    "dem_6a"   "dme_6b"   "dem_7"    "dem_7a"   "dem_7b"  
# [19] "dem_7c"   "dem_7d"   "dem_7e"   "dem_8"    "dem_9"    "dem_10"  
# [25] "dem_11"   "dem_12"   "dem_12a"  "dem_12b"  "dem_12c"  "dem_12d" 
# [31] "dem_12e"  "dem_12f"  "dem_12g"  "dem_12h"  "dem_12i"  "dem_12j" 
# [37] "dem_12k"  "dem_12l"  "dem_13"   "dem_13a"  "dem_13b"  "dem_13c" 
# [43] "dem_13d"  "dem_13e"  "dem_13f"  "dem_13g"  "dem_13h"  "dem_14"  
# [49] "dem_14a"  "dem_14b"  "dem_14c"  "dem_14d"  "dem_14e"  "dem_14f" 
# [55] "demo_16g" "dem_15"   "dem_16"   "dem_17"   "dem_18"  
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "dem_1" in both REDCap and QDS corresponded to the item "What is your present marital status?"). 

We manually verified this values and found that: 

- `DEMO16G` in QDS Visit 1 was mislabeled, and should map to `dem_14g` along with `DEM14GV3`, `DEM14GV4`, and `DEM14GV5` 

- `DEMO14HV3`, `DEMO14HV4`, and `DEMO14HV5` should map to `dem_14h`, as they correspond to an item that was first present in QDS Visit 3.

- Many of the REDCap variables failed to standardize.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                                                    
# [2] "In source  v2 : "                                                      
# [3] "In source  v3 : DEM14GV3, DEM14HV3" 
# [4] "In source  v4 : DEM14GV4, DEM14HV4"             
# [5] "In source  v5 : DEM14GV5, DEM14HV5"   
# [6] "In source  redcap : dem4v1___1, dem4v1___2, dem4v1___3, dem4v1___4, 
# dem4v1___5, dem4v1___6, dem7v1___1, dem7v1___2, dem7v1___3, dem7v1___4, 
# dem7v1___5, dem12v1___1, dem12v1___2, dem12v1___3, dem12v1___4, dem12v1___5,
# dem12v1___6, dem12v1___7, dem12v1___8, dem12v1___9, dem12v1___10, 
# dem12v1___11, dem12v1___12, dem14gv1"
```

We made the required point-modifications to our desired variable list.

```{r}
desired_vars[desired_vars == 'demo_16g'] <- 'dem_14g'

desired_vars <- append(
  desired_vars, 'dem_14h', after=which(desired_vars == 'dem_14g')
  )

desired_vars

#  [1] "dem_1"   "dem_2"   "dem_3"   "dem_4"   "dem_4a"  "dem_4b" 
#  [7] "dem_4c"  "dem_4d"  "dem_4e"  "dem_4f"  "dem_5"   "dem_5a" 
# [13] "dem_6"   "dem_6a"  "dme_6b"  "dem_7"   "dem_7a"  "dem_7b" 
# [19] "dem_7c"  "dem_7d"  "dem_7e"  "dem_8"   "dem_9"   "dem_10" 
# [25] "dem_11"  "dem_12"  "dem_12a" "dem_12b" "dem_12c" "dem_12d"
# [31] "dem_12e" "dem_12f" "dem_12g" "dem_12h" "dem_12i" "dem_12j"
# [37] "dem_12k" "dem_12l" "dem_13"  "dem_13a" "dem_13b" "dem_13c"
# [43] "dem_13d" "dem_13e" "dem_13f" "dem_13g" "dem_13h" "dem_14" 
# [49] "dem_14a" "dem_14b" "dem_14c" "dem_14d" "dem_14e" "dem_14f"
# [55] "dem_14g" "dem_14h" "dem_15"  "dem_16"  "dem_17"  "dem_18" 
```

We created our source maps, including the necessary point-mutations to ensure our desired mapping.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
    ) %>%
  mutate(variable = case_when(
        variable == 'demo_16g' ~ 'dem_14g',
        TRUE ~ variable
        )
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'dem_4_1' ~ 'dem_4a',
      variable == 'dem_4_2' ~ 'dem_4b',
      variable == 'dem_4_3' ~ 'dem_4c',
      variable == 'dem_4_4' ~ 'dem_4d',
      variable == 'dem_4_5' ~ 'dem_4e',
      variable == 'dem_4_6' ~ 'dem_4f',
      variable == 'dem_7_1' ~ 'dem_7a',
      variable == 'dem_7_2' ~ 'dem_7b',
      variable == 'dem_7_3' ~ 'dem_7c',
      variable == 'dem_7_4' ~ 'dem_7d',
      variable == 'dem_7_5' ~ 'dem_7e',
      variable == 'dem_12_1' ~ 'dem_12a',
      variable == 'dem_12_2' ~ 'dem_12b',
      variable == 'dem_12_3' ~ 'dem_12c',
      variable == 'dem_12_4' ~ 'dem_12d',
      variable == 'dem_12_5' ~ 'dem_12e',
      variable == 'dem_12_6' ~ 'dem_12f',
      variable == 'dem_12_7' ~ 'dem_12g',
      variable == 'dem_12_8' ~ 'dem_12h',
      variable == 'dem_12_9' ~ 'dem_12i',
      variable == 'dem_12_10' ~ 'dem_12j',
      variable == 'dem_12_11' ~ 'dem_12k',
      variable == 'dem_12_12' ~ 'dem_12l',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Demographic Questionnaire', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('demo' = inst_map))

rm(inst_map)
```

### Brief Homelessness Questionnaire

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "BH"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "BH1V1"    "BH2V1"    "BH3V1"    "BH4V1"    "BH5V1"    "BH6V1"   
#  [7] "BH7V1"    "BH8V1"    "BH9V1"    "BH10V1"   "BH11AV1"  "BH12AV1" 
# [13] "BH13AV1"  "BH13BV1"  "BH13CV1"  "BH14V1"   "BH14BV1"  "BH15V1"  
# [19] "BH15AV1"  "BH16V1"   "BH17V1"   "BH18V1"   "BH18BV1"  "BH18B1V1"
# [25] "BH19V1"   "BH20V1"   "BH1V1Y"   "BH1V1M"   "BH1V1D"   "BH4V1Y"  
# [31] "BH4V1M"   "BH4V1D"   "BH7V1Y"   "BH7V1M"   "BH7V1W"   "BH12AV1A"
# [37] "BH12AV1B" "BH12AV1C" "BH12AV1D" "BH12AV1E" "BH12AV1F" "BH12AV1G"
# [43] "BH12AV1H" "BH12AV1I" "BH12AV1J" "BH12AV1K" "BH12AV1L" "BH13AV1A"
# [49] "BH13AV1B" "BH13AV1C" "BH13AV1D" "BH13AV1E" "BH13AV1F" "BH13BV1A"
# [55] "BH13BV1B" "BH13BV1C" "BH13BV1D" "BH13BV1E" "BH13BV1F" "BH13BV1G"
# [61] "BH13BV1H" "BH13CV1A" "BH13CV1B" "BH13CV1C" "BH13CV1D" "BH13CV1E"
# [67] "BH13CV1F" "BH13CV1G" "BH13CV1H" "BH14BV1Y" "BH14BV1M" "BH14BV1W"
# [73] "BH17V1Y"  "BH17V1M"  "BH17V1W"  "BH18BV1A" "BH18BV1B" "BH18BV1C"
# [79] "BH18BV1D" "BH18BV1E" "BH18BV1F" "BH18BV1G" "BH18BV1H"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "bh1v1y"       "bh1v1m"       "bh1v1d"       "bh2v1"       
#  [5] "bh3v1"        "bh4v1y"       "bh4v1m"       "bh4v1d"      
#  [9] "bh5v1"        "bh6v1"        "bh7v1y"       "bh7v1m"      
# [13] "bh7v1w"       "bh8v1"        "bh9v1"        "bh10v1"      
# [17] "bh11av1"      "bh12av1___1"  "bh12av1___2"  "bh12av1___3" 
# [21] "bh12av1___4"  "bh12av1___5"  "bh12av1___6"  "bh12av1___7" 
# [25] "bh12av1___8"  "bh12av1___9"  "bh12av1___10" "bh12av1___11"
# [29] "bh12av1___12" "bh13av1___1"  "bh13av1___2"  "bh13av1___3" 
# [33] "bh13av1___4"  "bh13av1___5"  "bh13av1___6"  "bh13bv1___1" 
# [37] "bh13bv1___2"  "bh13bv1___3"  "bh13bv1___4"  "bh13bv1___5" 
# [41] "bh13bv1___6"  "bh13bv1___7"  "bh13bv1___8"  "bh13cv1___1" 
# [45] "bh13cv1___2"  "bh13cv1___3"  "bh13cv1___4"  "bh13cv1___5" 
# [49] "bh13cv1___6"  "bh13cv1___7"  "bh13cv1___8"  "bh14v1"      
# [53] "bh14bv1y"     "bh14bv1m"     "bh14bv1w"     "bh14bv3d"    
# [57] "bh15v1"       "bh15av1"      "bh16v1"       "bh17v1y"     
# [61] "bh17v1m"      "bh17v1w"      "bh18v1"       "bh18bv1___1" 
# [65] "bh18bv1___2"  "bh18bv1___3"  "bh18bv1___4"  "bh18bv1___5" 
# [69] "bh18bv1___6"  "bh18bv1___7"  "bh18bv1___8"  "bh18b1v1"    
# [73] "bh19v1"       "bh20v"     
```


We checked to see if any of these variables were only missing values in the REDCap. We found that `bh18b1v1` only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "bh18b1v1 is only missing values"
```

We set our initial desired order and standardization using the QDS Variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'BH1V1', 'BH1V1Y', 'BH1V1M', 'BH1V1D', 'BH2V1', 'BH3V1', 'BH4V1',
    'BH4V1Y', 'BH4V1M', 'BH4V1D', 'BH5V1', 'BH6V1', 'BH7V1', 'BH7V1Y',
    'BH7V1M', 'BH7V1W', 'BH8V1', 'BH9V1', 'BH10V1', 'BH11AV1', 'BH12AV1',
    'BH12AV1A', 'BH12AV1B', 'BH12AV1C', 'BH12AV1D', 'BH12AV1E', 'BH12AV1F',
    'BH12AV1G', 'BH12AV1H', 'BH12AV1I', 'BH12AV1J', 'BH12AV1K', 'BH12AV1L',
    'BH13AV1', 'BH13AV1A', 'BH13AV1B', 'BH13AV1C', 'BH13AV1D', 'BH13AV1E',
    'BH13AV1F', 'BH13BV1', 'BH13BV1A', 'BH13BV1B', 'BH13BV1C', 'BH13BV1D',
    'BH13BV1E', 'BH13BV1F', 'BH13BV1G', 'BH13BV1H', 'BH13CV1', 
    'BH13CV1A', 'BH13CV1B', 'BH13CV1C', 'BH13CV1D', 'BH13CV1E', 'BH13CV1F',
    'BH13CV1G', 'BH13CV1H', 'BH14V1', 'BH14BV1', 'BH14BV1Y', 'BH14BV1M',
    'BH14BV1W', 'BH15V1', 'BH15AV1', 'BH16V1', 'BH17V1', 'BH17V1Y',
    'BH17V1M', 'BH17V1W', 'BH18V1', 'BH18BV1', 'BH18BV1A', 'BH18BV1B',
    'BH18BV1C', 'BH18BV1D', 'BH18BV1E', 'BH18BV1F', 'BH18BV1G', 'BH18BV1H',
    'BH18B1V1', 'BH19V1', 'BH20V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

#  [1] "bh_1"    "bh_1y"   "bh_1m"   "bh_1d"   "bh_2"    "bh_3"   
#  [7] "bh_4"    "bh_4y"   "bh_4m"   "bh_4d"   "bh_5"    "bh_6"   
# [13] "bh_7"    "bh_7y"   "bh_7m"   "bh_7w"   "bh_8"    "bh_9"   
# [19] "bh_10"   "bh_11a"  "bh_12a"  "bh_12aa" "bh_12ab" "bh_12ac"
# [25] "bh_12ad" "bh_12ae" "bh_12af" "bh_12ag" "bh_12ah" "bh_12ai"
# [31] "bh_12aj" "bh_12ak" "bh_12al" "bh_13a"  "bh_13aa" "bh_13ab"
# [37] "bh_13ac" "bh_13ad" "bh_13ae" "bh_13af" "bh_13b"  "bh_13ba"
# [43] "bh_13bb" "bh_13bc" "bh_13bd" "bh_13be" "bh_13bf" "bh_13bg"
# [49] "bh_13bh" "bh_13c"  "bh_13ca" "bh_13cb" "bh_13cc" "bh_13cd"
# [55] "bh_13ce" "bh_13cf" "bh_13cg" "bh_13ch" "bh_14"   "bh_14b" 
# [61] "bh_14by" "bh_14bm" "bh_14bw" "bh_15"   "bh_15a"  "bh_16"  
# [67] "bh_17"   "bh_17y"  "bh_17m"  "bh_17w"  "bh_18"   "bh_18b" 
# [73] "bh_18ba" "bh_18bb" "bh_18bc" "bh_18bd" "bh_18be" "bh_18bf"
# [79] "bh_18bg" "bh_18bh" "bh_18b1" "bh_19"   "bh_20"  
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "bh_1" in both REDCap and QDS corresponded to the item "What is the total amount of time you have been homeless in your lifetime? (for example 3 and a half years would be 3 years and 6 months)"). 

We manually verified these variables and determined:

-   `BH14BV3D`, `BH14BV4D`, and `BH14BV3D` should map to `bh_14bd`, which was added in Visit 3.

-   `BH18BVA` should map to `bh_18ba`, but escaped our standardization function due to a typographical error.

-   Many of the REDCap variables escaped our standardization.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                                  
# [2] "In source  v2 : "                                       
# [3] "In source  v3 : BH14BV3D"                             
# [4] "In source  v4 : BH14BV4D"                               
# [5] "In source  v5 : BH14BV5D, BH18BVA"                                   
# [6] "In source  redcap : bh12av1___1, bh12av1___2, bh12av1___3, bh12av1___4,
# bh12av1___5, bh12av1___6, bh12av1___7, bh12av1___8, bh12av1___9, 
# bh12av1___10, bh12av1___11, bh12av1___12, bh13av1___1, bh13av1___2, 
# bh13av1___3, bh13av1___4, bh13av1___5, bh13av1___6, bh13bv1___1, 
# bh13bv1___2, bh13bv1___3, bh13bv1___4, bh13bv1___5, bh13bv1___6, 
# bh13bv1___7, bh13bv1___8, bh13cv1___1, bh13cv1___2, bh13cv1___3, 
# bh13cv1___4, bh13cv1___5, bh13cv1___6, bh13cv1___7, bh13cv1___8, bh14bv3d, 
# bh18bv1___1, bh18bv1___2, bh18bv1___3, bh18bv1___4, bh18bv1___5, 
# bh18bv1___6, bh18bv1___7, bh18bv1___8, bh20v"
```

We made the required point-modification to our desired variable list.

```{r}
desired_vars <- append(
  desired_vars, 'bh_14bd', after=which(desired_vars == 'bh_14bw')
  )

desired_vars

#  [1] "bh_1"     "bh_1y"    "bh_1m"    "bh_1d"    "bh_2"     "bh_3"    
#  [7] "bh_4"     "bh_4y"    "bh_4m"    "bh_4d"    "bh_5"     "bh_6"    
# [13] "bh_7"     "bh_7y"    "bh_7m"    "bh_7w"    "bh_8"     "bh_9"    
# [19] "bh_10"    "bh_11a"   "bh_12a"   "bh_12aa"  "bh_12ab"  "bh_12ac" 
# [25] "bh_12ad"  "bh_12ae"  "bh_12af"  "bh_12ag"  "bh_12ah"  "bh_12ai" 
# [31] "bh_12aj"  "bh_12ak"  "bh_12al"  "bh_13a"   "bh_13aa"  "bh_13ab" 
# [37] "bh_13ac"  "bh_13ad"  "bh_13ae"  "bh_13af"  "bh_13b"   "bh_13ba" 
# [43] "bh_13bb"  "bh_13bc"  "bh_13bd"  "bh_13be"  "bh_13bf"  "bh_13bg" 
# [49] "bh_13bh"  "bh_13c"   "bh_13ca"  "bh_13cb"  "bh_13cc"  "bh_13cd" 
# [55] "bh_13ce"  "bh_13cf"  "bh_13cg"  "bh_13ch"  "bh_14"    "bh_14b"  
# [61] "bh_14by"  "bh_14bm"  "bh_14bw"  "bh_14bd" "bh_15"    "bh_15a"  
# [67] "bh_16"    "bh_17"    "bh_17y"   "bh_17m"   "bh_17w"   "bh_18"   
# [73] "bh_18b"   "bh_18ba"  "bh_18bb"  "bh_18bc"  "bh_18bd"  "bh_18be" 
# [79] "bh_18bf"  "bh_18bg"  "bh_18bh"  "bh_18b1"  "bh_19"    "bh_20"
```

We created our source maps, including the required point-modifications.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'bh_18bva' ~ 'bh_18ba',
        variable == 'weight_5' ~'weight',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
  vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'bh_12a_1' ~ 'bh_12aa',
      variable == 'bh_12a_2' ~ 'bh_12ab',
      variable == 'bh_12a_3' ~ 'bh_12ac',
      variable == 'bh_12a_4' ~ 'bh_12ad',
      variable == 'bh_12a_5' ~ 'bh_12ae',
      variable == 'bh_12a_6' ~ 'bh_12af',
      variable == 'bh_12a_7' ~ 'bh_12ag',
      variable == 'bh_12a_8' ~ 'bh_12ah',
      variable == 'bh_12a_9' ~ 'bh_12ai',
      variable == 'bh_12a_10' ~ 'bh_12aj',
      variable == 'bh_12a_11' ~ 'bh_12ak',
      variable == 'bh_12a_12' ~ 'bh_12al',
      variable == 'bh_13a_1' ~ 'bh_13aa',
      variable == 'bh_13a_2' ~ 'bh_13ab',
      variable == 'bh_13a_3' ~ 'bh_13ac',
      variable == 'bh_13a_4' ~ 'bh_13ad',
      variable == 'bh_13a_5' ~ 'bh_13ae',
      variable == 'bh_13a_6' ~ 'bh_13af',
      variable == 'bh_13b_1' ~ 'bh_13ba',
      variable == 'bh_13b_2' ~ 'bh_13bb',
      variable == 'bh_13b_3' ~ 'bh_13bc',
      variable == 'bh_13b_4' ~ 'bh_13bd',
      variable == 'bh_13b_5' ~ 'bh_13be',
      variable == 'bh_13b_6' ~ 'bh_13bf',
      variable == 'bh_13b_7' ~ 'bh_13bg',
      variable == 'bh_13b_8' ~ 'bh_13bh',
      variable == 'bh_13c_1' ~ 'bh_13ca',
      variable == 'bh_13c_2' ~ 'bh_13cb',
      variable == 'bh_13c_3' ~ 'bh_13cc',
      variable == 'bh_13c_4' ~ 'bh_13cd',
      variable == 'bh_13c_5' ~ 'bh_13ce',
      variable == 'bh_13c_6' ~ 'bh_13cf',
      variable == 'bh_13c_7' ~ 'bh_13cg',
      variable == 'bh_13c_8' ~ 'bh_13ch',
      variable == 'bh_18b_1' ~ 'bh_18ba',
      variable == 'bh_18b_2' ~ 'bh_18bb',
      variable == 'bh_18b_3' ~ 'bh_18bc',
      variable == 'bh_18b_4' ~ 'bh_18bd',
      variable == 'bh_18b_5' ~ 'bh_18be',
      variable == 'bh_18b_6' ~ 'bh_18bf',
      variable == 'bh_18b_7' ~ 'bh_18bg',
      variable == 'bh_18b_8' ~ 'bh_18bh',
      variable == 'bh_20v' ~ 'bh_20',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'The Brief Homelessness Questionnaire', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('brief_hl' = inst_map))

rm(inst_map)
```

### MacAurthor Scale of Subjective Social Status

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "SSS", "WELL_BEING"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "SSS1_V1" "SSS2_V1"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "sss1_v1"     "sss2_v1"     "well_being1" "well_being2" "well_being3"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'SSS1_V1', 'SSS2_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

# [1] "sss_1" "sss_2"
```


We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "sss_1" in both REDCap and QDS corresponded to the item "Community Ladder"). 

We manually verified these variables and determined the `well_being` values were separate but related questions added after Visit 1. 

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                                                      
# [2] "In source  v2 : WELL_BEING1, WELL_BEING2, WELL_BEING3"                 
# [3] "In source  v3 : "                                                     
# [4] "In source  v4 : "                                                      # [5] "In source  v5 : WELL_BEING1, WELL_BEING2, WELL_BEING3"                 
# [6] "In source  redcap : well_being1, well_being2, well_being3"
```

We made the required point-modification to our desired variable list.

```{r}
desired_vars <- append(
  desired_vars, 
  standardize_col_names(c('WELL_BEING1', 'WELL_BEING2', 'WELL_BEING3')) 
  )

desired_vars

# [1] "sss_1"        "sss_2"        "well_being_1" "well_being_2"
# [5] "well_being_3"
```

We created our source maps.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'MacArthur Scale of Subjective Social Status', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('maca_sss' = inst_map))

rm(inst_map)
```

### Joining Section

We purged the placeholder from our section-wise list of instruments, and joined our section map.

```{r}
sec_instruments <- sec_instruments[names(sec_instruments) != "placeholder"]

sec_map <- vm_join_inst_section(
  'Demographics', sec_instruments
  )

sec_map
```

We added the section to our overall list of sections, and purged the section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('demos' = sec_map))

rm(sec_map)
```

## Health, Mental Health, and Health Behaviors

The section of Health contained 17 instruments: Patient Health Questionnaire, SF12 Health Survey, Health Related Quality of Life, Self-Rated Health, TCU Drug Screen 5, Primary Care PTSD Screen (PC-PTSD), BRFSS Adverse Childhood Experience (ACE) Module, Tobacco History, Heaviness of Smoking Index, Behavioral Risk Factor Surveillance System (BRFSS) Inadequate Sleep, Alcohol Quantity and Frequency Questionnaire, Alcohol and Drug Timeline Follow-Back (TLFB), Personality Beliefs Questionnaire, USDA Food Security Survey, Meal Survey, TCU CJ Client Evaluation of Self and Treatment (CJ CEST), and Sexual Behaviors.

We initiated an empty list of the instruments for this section, which we would build in order.
This placeholder would be removed prior to utilizing the list, but was named for easier removal.

```{r}
sec_instruments <- list("placeholder" = c())
```

### Patient Health Questionnaire (PHQ)

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "PHQ"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "PHQ1_V1"              "PHQ2_V1"             
#  [3] "PHQ3_V1"              "PHQ4_V1"             
#  [5] "PHQ5_V1"              "PHQ6_V1"             
#  [7] "PHQ7_V1"              "PHQ8_V1"             
#  [9] "PHQ9_V1"              "PHQ10_V1"            
# [11] "PHQ11_V1"             "PHQ12_V1"            
# [13] "PHQ13_V1"             "PHQ14_V1"            
# [15] "PHQ15_V1"             "PHQ1_V1_dichot"      
# [17] "PHQ2_V1_dichot"       "PHQ3_V1_dichot"      
# [19] "PHQ4_V1_dichot"       "PHQ5_V1_dichot"      
# [21] "PHQ6_V1_dichot"       "PHQ7_V1_dichot"      
# [23] "PHQ8_V1_dichot"       "PHQ_dep_dichot_total"
# [25] "PHQ_symp_V1"          "PHQ_mdd_V1"          
# [27] "PHQ_gad_V1"  
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "phq1_v1"  "phq2_v1"  "phq3_v1"  "phq4_v1"  "phq5_v1"  "phq6_v1" 
#  [7] "phq7_v1"  "phq8_v1"  "phq9_v1"  "phq10_v1" "phq11_v1" "phq12_v1"
# [13] "phq13_v1" "phq14_v1" "phq15_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

The SPSS calculated variables that included "dichot", "symp", "gad", "mdd", and/or "total" were selected to drop.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'PHQ1_V1', 'PHQ2_V1', 'PHQ3_V1', 'PHQ4_V1', 'PHQ5_V1', 'PHQ6_V1',
  'PHQ7_V1', 'PHQ8_V1', 'PHQ9_V1', 'PHQ10_V1', 'PHQ11_V1', 'PHQ12_V1',
  'PHQ13_V1', 'PHQ14_V1', 'PHQ15_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

#  [1] "phq_1"  "phq_2"  "phq_3"  "phq_4"  "phq_5"  "phq_6"  "phq_7" 
#  [8] "phq_8"  "phq_9"  "phq_10" "phq_11" "phq_12" "phq_13" "phq_14"
# [15] "phq_15" 
```

We dropped our SPSS calculated variables from all QDS data sets.

```{r}
dropping[['v1']] <- c(
  dropping[['v1']], 'PHQ1_V1_dichot', 'PHQ2_V1_dichot', 'PHQ3_V1_dichot',
  'PHQ4_V1_dichot', 'PHQ5_V1_dichot', 'PHQ6_V1_dichot',
  'PHQ7_V1_dichot', 'PHQ8_V1_dichot', 'PHQ_dep_dichot_total',
  'PHQ_symp_V1', 'PHQ_mdd_V1', 'PHQ_gad_V1'
  )

dropping[['v3']] <- c(
  dropping[['v3']], 'PHQ1_V3_dichot', 'PHQ2_V3_dichot', 'PHQ3_V3_dichot',
  'PHQ4_V3_dichot', 'PHQ5_V3_dichot', 'PHQ6_V3_dichot',
  'PHQ7_V3_dichot', 'PHQ8_V3_dichot', 'PHQ_dep_dichot_total_V3', 
  'PHQ_symp_V3', 'PHQ_mdd_V3', 'PHQ_gad_V3' 
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'PHQ1_V4_dichot', 'PHQ2_V4_dichot', 'PHQ3_V4_dichot',
  'PHQ4_V4_dichot', 'PHQ5_V4_dichot', 'PHQ6_V4_dichot',
  'PHQ7_V4_dichot', 'PHQ8_V4_dichot', 'PHQ_dep_dichot_total', 
  'PHQ_symp_V4', 'PHQ_mdd_V4', 'PHQ_gad_V4'
  )
dropping[['v5']] <- c(
  dropping[['v5']], 'PHQ1_V5_dichot', 'PHQ2_V5_dichot', 'PHQ3_V5_dichot',
  'PHQ4_V5_dichot', 'PHQ5_V5_dichot', 'PHQ6_V5_dichot',
  'PHQ7_V5_dichot', 'PHQ8_V5_dichot', 'PHQ_dep_dichot_total', 
  'PHQ_symp_V5', 'PHQ_mdd_V5', 'PHQ_gad_V5'
  )
```

We checked for any variables that would either standardize differently, or were absent from the QDS Visit 1 source data set.

The only variables found were the calculated variables in the QDS visit data sets.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : PHQ1_V1_dichot, PHQ2_V1_dichot, PHQ3_V1_dichot, PHQ4_V1_dichot, PHQ5_V1_dichot, PHQ6_V1_dichot, PHQ7_V1_dichot, PHQ8_V1_dichot, PHQ_dep_dichot_total, PHQ_symp_V1, PHQ_mdd_V1, PHQ_gad_V1" 
# [2] "In source  v2 : "            
# [3] "In source  v3 : PHQ1_V3_dichot, PHQ2_V3_dichot, PHQ3_V3_dichot, PHQ4_V3_dichot, PHQ5_V3_dichot, PHQ6_V3_dichot, PHQ7_V3_dichot, PHQ8_V3_dichot, PHQ_dep_dichot_total_V3, PHQ_symp_V3, PHQ_mdd_V3, PHQ_gad_V3"
# [4] "In source  v4 : PHQ1_V4_dichot, PHQ2_V4_dichot, PHQ3_V4_dichot, PHQ4_V4_dichot, PHQ5_V4_dichot, PHQ6_V4_dichot, PHQ7_V4_dichot, PHQ8_V4_dichot, PHQ_dep_dichot_total_V4, PHQ_symp_V4, PHQ_mdd_V4, PHQ_gad_V4"
# [5] "In source  v5 : PHQ1_V5_dichot, PHQ2_V5_dichot, PHQ3_V5_dichot, PHQ4_V5_dichot, PHQ5_V5_dichot, PHQ6_V5_dichot, PHQ7_V5_dichot, PHQ8_V5_dichot, PHQ_dep_dichot_total_V5, PHQ_symp_V5, PHQ_mdd_V5, PHQ_gad_V5"
# [6] "In source  redcap : "     
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Patient Health Questionnaire (PHQ)', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('phq' = inst_map))

rm(inst_map)
```

### SF12 Health Survey

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "HS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c("HSI"),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "HS1_V1"             "HS2_V1"             "HS3_V1"            
#  [4] "HS4_V1"             "HS5_V1"             "HS6_V1"            
#  [7] "HS7_V1"             "HS8_V1"             "HS9_V1"            
# [10] "HS10_V1"            "HS11_V1"            "HS12_V1"           
# [13] "HS1_V1_dichotomous"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We set our initial desired order and standardization.
We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.
The SPSS calculated variables that included "dichot" were selected to drop.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'HS1_V1', 'HS2_V1', 'HS3_V1', 'HS4_V1', 'HS5_V1', 'HS6_V1', 
    'HS7_V1', 'HS8_V1', 'HS9_V1', 'HS10_V1', 'HS11_V1', 'HS12_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

 # [1] "hs_1"  "hs_2"  "hs_3"  "hs_4"  "hs_5"  "hs_6"  "hs_7"  "hs_8" 
 # [9] "hs_9"  "hs_10" "hs_11" "hs_12"
```

We dropped our SPSS calculated variables from all data sets.

```{r}
dropping[['v1']] <- c(
  dropping[['v1']], 'HS1_V1_dichotomous'
  )

dropping[['v3']] <- c(
  dropping[['v3']], 'HS1_V3_dichotomous'
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'HS1_V4_dichotomous'
  )
dropping[['v5']] <- c(
  dropping[['v5']], 'HS1_V5_dichotomous'
  )
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "hs_1" in both REDCap and QDS corresponded to the item "In general, would you say your health is:"). 
We only identified the SPSS calculated variables that were already identified to drop.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : HS1_V1_dichotomous"
# [2] "In source  v2 : "                  
# [3] "In source  v3 : HS1_V3_dichotomous"
# [4] "In source  v4 : HS1_V4_dichotomous"
# [5] "In source  v5 : HS1_V5_dichotomous"
# [6] "In source  redcap : "
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'SF12 Health Survey', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('sf12' = inst_map))

rm(inst_map)
```

### Health Related Quality of Life

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "HRQ"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "HRQ1_V1" "HRQ2_V1" "HRQ3_V1"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "hrq1_v1" "hrq2_v1" "hrq3_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'HRQ1_V1', 'HRQ2_V1', 'HRQ3_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

# [1] "hrq_1" "hrq_2" "hrq_3"
```

We checked for any variables that would either standardize differently, or were absent from the QDS Visit 1 source data set, and found none.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Health Related Quality of Life', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('hrq' = inst_map))

rm(inst_map)
```

### Self-Rated Health

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "S"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(
    "SQ", "SSS", "SUBJECT", "SUBSTANCE", "SPOUSE", "SB", "STAFF"
    ),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#   [1] "S2_V1"    "SR3A_V1"  "SR3B_V1"  "SR3C_V1"  "SR3D_V1"  "SR3E_V1" 
#   [7] "SR3F_V1"  "S3_V1"    "S4_V1"    "S5_V1"    "S6_V1"    "S7_V1"   
#  [13] "S8_V1"    "S9_V1"    "S10_V1"   "S11_V1"   "S12_V1"   "S13_V1"  
#  [19] "S14_V1"   "S15_V1"   "S16_V1"   "S17_V1"   "S18_V1"   "S19_V1"  
#  [25] "S20_V1"   "S21_V1"   "S22_V1"   "S23_V1"   "S24_V1"   "S25A_V1" 
#  [31] "S26A_V1"  "S25B_V1"  "S26B_V1"  "S25C_V1"  "S26C_V1"  "S25D_V1" 
#  [37] "S26D_V1"  "S25E_V1"  "S26E_V1"  "S27_V1"   "S28_V1"   "S29_V1"  
#  [43] "S30_V1"   "S31_V1"   "S32_V1"   "S33_V1"   "S34_V1"   "S35_V1"  
#  [49] "S36_V1"   "S37_V1"   "S38_V1"   "S39A_V1"  "S39B_V1"  "S40_V1"  
#  [55] "S41_V1"   "S42_V1"   "S43_V1"   "S2_V1A"   "S2_V1B"   "S2_V1C"  
#  [61] "S2_V1D"   "S2_V1E"   "S2_V1F"   "S2_V1G"   "S2_V1H"   "S4_V1A"  
#  [67] "S4_V1B"   "S4_V1C"   "S4_V1D"   "S4_V1E"   "S4_V1F"   "S4_V1G"  
#  [73] "S4_V1H"   "S7_V1A"   "S7_V1B"   "S7_V1C"   "S7_V1D"   "S7_V1E"  
#  [79] "S7_V1F"   "S7_V1G"   "S8_V1A"   "S8_V1B"   "S8_V1C"   "S8_V1D"  
#  [85] "S8_V1E"   "S8_V1F"   "S8_V1G"   "S9_V1A"   "S9_V1B"   "S9_V1C"  
#  [91] "S9_V1D"   "S9_V1E"   "S9_V1F"   "S9_V1G"   "S9_V1H"   "S9_V1I"  
#  [97] "S9_V1J"   "S9_V1K"   "S9_V1L"   "S9_V1M"   "S9_V1N"   "S9_V1O"  
# [103] "S9_V1P"   "S9_V1Q"   "S9_V1R"   "S14_V1A"  "S14_V1B"  "S14_V1C" 
# [109] "S14_V1D"  "S18_V1A"  "S18_V1B"  "S18_V1C"  "S18_V1D"  "S18_V1E" 
# [115] "S18_V1F"  "S18_V1G"  "S18_V1H"  "S18_V1I"  "S18_V1J"  "S18_V1K" 
# [121] "S18_V1L"  "S24_V1A"  "S24_V1B"  "S24_V1C"  "S24_V1D"  "S24_V1E" 
# [127] "S24_V1F"  "S26A_V1A" "S26A_V1B" "S26A_V1C" "S26A_V1D" "S26A_V1E"
# [133] "S26A_V1F" "S26A_V1G" "S26B_V1A" "S26B_V1B" "S26B_V1C" "S26B_V1D"
# [139] "S26B_V1E" "S26B_V1F" "S26B_V1G" "S26C_V1A" "S26C_V1B" "S26C_V1C"
# [145] "S26C_V1D" "S26C_V1E" "S26C_V1F" "S26C_V1G" "S26D_V1A" "S26D_V1B"
# [151] "S26D_V1C" "S26D_V1D" "S26D_V1E" "S26D_V1F" "S26D_V1G" "S26E_V1A"
# [157] "S26E_V1B" "S26E_V1C" "S26E_V1D" "S26E_V1E" "S26E_V1F" "S26E_V1G"
# [163] "S30_V1A"  "S30_V1B"  "S30_V1C"  "S30_V1D"  "S30_V1E"  "S30_V1F" 
# [169] "S30_V1G"  "S32_V1A"  "S32_V1B"  "S32_V1C"  "S32_V1D"  "S32_V1E" 
# [175] "S32_V1F"  "S32_V1G"  "S32_V1H"  "S32_V1I"  "S43_V1A"  "S43_V1B" 
# [181] "S43_V1C"  "S43_V1D"  "S43_V1E"  "S43_V1F"  "S43_V1G"  "S43_V1H" 
# [187] "S43_V1I" 
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#   [1] "s2_v1___1"    "s2_v1___2"    "s2_v1___3"    "s2_v1___4"   
#   [5] "s2_v1___5"    "s2_v1___6"    "s2_v1___7"    "s2_v1___8"   
#   [9] "sr3a_v1"      "sr3b_v1"      "sr3c_v1"      "sr3d_v1"     
#  [13] "sr3e_v1"      "sr3f_v1"      "s3_v1"        "s4_v1___1"   
#  [17] "s4_v1___2"    "s4_v1___3"    "s4_v1___4"    "s4_v1___5"   
#  [21] "s4_v1___6"    "s4_v1___7"    "s4_v1___8"    "s5_v1"       
#  [25] "s6_v1"        "s7_v1___1"    "s7_v1___2"    "s7_v1___3"   
#  [29] "s7_v1___4"    "s7_v1___5"    "s7_v1___6"    "s7_v1___7"   
#  [33] "s8_v1___1"    "s8_v1___2"    "s8_v1___3"    "s8_v1___4"   
#  [37] "s8_v1___5"    "s8_v1___6"    "s8_v1___7"    "s9_v1___1"   
#  [41] "s9_v1___2"    "s9_v1___3"    "s9_v1___4"    "s9_v1___5"   
#  [45] "s9_v1___6"    "s9_v1___7"    "s9_v1___8"    "s9_v1___9"   
#  [49] "s9_v1___10"   "s9_v1___11"   "s9_v1___12"   "s9_v1___13"  
#  [53] "s9_v1___14"   "s9_v1___15"   "s9_v1___16"   "s9_v1___17"  
#  [57] "s9_v1___18"   "s10_v1"       "s11_v1"       "s12_v1"      
#  [61] "s13_v1"       "s14_v1___1"   "s14_v1___2"   "s14_v1___3"  
#  [65] "s14_v1___4"   "s15_v1"       "s16_v1"       "s17_v1"      
#  [69] "s18_v1___1"   "s18_v1___2"   "s18_v1___3"   "s18_v1___4"  
#  [73] "s18_v1___5"   "s18_v1___6"   "s18_v1___7"   "s18_v1___8"  
#  [77] "s18_v1___9"   "s18_v1___10"  "s18_v1___11"  "s18_v1___12" 
#  [81] "s19_v1"       "s20_v1"       "s21_v1"       "s22_v1"      
#  [85] "s23_v1"       "s24_v1___1"   "s24_v1___2"   "s24_v1___3"  
#  [89] "s24_v1___4"   "s24_v1___5"   "s24_v1___6"   "s25a_v1"     
#  [93] "s26a_v1___1"  "s26a_v1___2"  "s26a_v1___3"  "s26a_v1___4" 
#  [97] "s26a_v1___5"  "s26a_v1___6"  "s26a_v1___7"  "s25b_v1"     
# [101] "s26b_v1___1"  "s26b_v1___2"  "s26b_v1___3"  "s26b_v1___4" 
# [105] "s26b_v1___5"  "s26b_v1___6"  "s26b_v1___7"  "s25c_v1"     
# [109] "s26c_v1___1"  "s26c_v1___2"  "s26c_v1___3"  "s26c_v1___4" 
# [113] "s26c_v1___5"  "s26c_v1___6"  "s26c_v1___7"  "s25d_v1"     
# [117] "s26d_v1___1"  "s26d_v1___2"  "s26d_v1___3"  "s26d_v1___4" 
# [121] "s26d_v1___5"  "s26d_v1___6"  "s26d_v1___7"  "s25e_v1"     
# [125] "s26e_v1___1"  "s26e_v1___2"  "s26e_v1___3"  "s26e_v1___4" 
# [129] "s26e_v1___5"  "s26e_v1___6"  "s26e_v1___7"  "s27_v1"      
# [133] "s28_v1"       "s29_v1"       "s30_v1___1"   "s30_v1___2"  
# [137] "s30_v1___3"   "s30_v1___4"   "s30_v1___5"   "s30_v1___6"  
# [141] "s30_v1___7"   "s31_v1"       "s32_v1___1"   "s32_v1___2"  
# [145] "s32_v1___3"   "s32_v1___4"   "s32_v1___5"   "s32_v1___6"  
# [149] "s32_v1___7"   "s32_v1___8"   "s32_v1___9"   "s33_v1"      
# [153] "s34_v1"       "s35_v1"       "s36_v1"       "s37_v1"      
# [157] "s38_v1"       "s39a_v1"      "s39b_v1"      "s40_v1"      
# [161] "s41_v1"       "s42_v1"       "s43_v1___1"   "s43_v1___2"  
# [165] "s43_v1___3"   "s43_v1___4"   "s43_v1___5"   "s43_v1___6"  
# [169] "s43_v1___7"   "s43_v1___8"   "s43_v1___9"   
```

We checked to see if any of these variables were only missing values in the REDCap. We found that `s36_v1` only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "s36_v1 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'S2_V1', 'S2_V1A', 'S2_V1B', 'S2_V1C', 'S2_V1D', 'S2_V1E', 
    'S2_V1F', 'S2_V1G', 'S2_V1H', 'SR3A_V1', 'SR3B_V1', 'SR3C_V1',
    'SR3D_V1', 'SR3E_V1', 'SR3F_V1', 'S3_V1', 'S4_V1', 'S4_V1A', 
    'S4_V1B', 'S4_V1C', 'S4_V1D', 'S4_V1E', 'S4_V1F', 'S4_V1G', 
    'S4_V1H', 'S5_V1', 'S6_V1', 'S7_V1', 'S7_V1A', 'S7_V1B', 'S7_V1C',
    'S7_V1D', 'S7_V1E', 'S7_V1F', 'S7_V1G', 'S8_V1', 'S8_V1A', 
    'S8_V1B', 'S8_V1C', 'S8_V1D', 'S8_V1E', 'S8_V1F', 'S8_V1G', 
    'S9_V1', 'S9_V1A', 'S9_V1B', 'S9_V1C', 'S9_V1D', 'S9_V1E', 
    'S9_V1F', 'S9_V1G', 'S9_V1H', 'S9_V1I', 'S9_V1J', 'S9_V1K', 
    'S9_V1L', 'S9_V1M', 'S9_V1N', 'S9_V1O', 'S9_V1P', 'S9_V1Q', 
    'S9_V1R', 'S10_V1', 'S11_V1', 'S12_V1', 'S13_V1', 'S14_V1', 
    'S14_V1A', 'S14_V1B', 'S14_V1C', 'S14_V1D', 'S15_V1', 'S16_V1',
    'S17_V1', 'S18_V1', 'S18_V1A', 'S18_V1B', 'S18_V1C', 'S18_V1D',
    'S18_V1E', 'S18_V1F', 'S18_V1G', 'S18_V1H', 'S18_V1I', 'S18_V1J',
    'S18_V1K', 'S18_V1L', 'S19_V1', 'S20_V1', 'S21_V1', 'S22_V1', 
    'S23_V1', 'S24_V1', 'S24_V1A', 'S24_V1B', 'S24_V1C', 'S24_V1D',
    'S24_V1E', 'S24_V1F', 'S25A_V1', 'S26A_V1', 'S26A_V1A', 'S26A_V1B',
    'S26A_V1C', 'S26A_V1D', 'S26A_V1E', 'S26A_V1F', 'S26A_V1G', 
    'S25B_V1', 'S26B_V1', 'S26B_V1A', 'S26B_V1B', 'S26B_V1C', 'S26B_V1D',
    'S26B_V1E', 'S26B_V1F', 'S26B_V1G', 'S25C_V1', 'S26C_V1', 'S26C_V1A',
    'S26C_V1B', 'S26C_V1C', 'S26C_V1D', 'S26C_V1E', 'S26C_V1F', 
    'S26C_V1G', 'S25D_V1', 'S26D_V1', 'S26D_V1A', 'S26D_V1B', 'S26D_V1C',
    'S26D_V1D', 'S26D_V1E', 'S26D_V1F', 'S26D_V1G', 'S25E_V1', 'S26E_V1',
    'S26E_V1A', 'S26E_V1B', 'S26E_V1C', 'S26E_V1D', 'S26E_V1E', 
    'S26E_V1F', 'S26E_V1G', 'S27_V1', 'S28_V1', 'S29_V1', 'S30_V1',
    'S30_V1A', 'S30_V1B', 'S30_V1C', 'S30_V1D', 'S30_V1E', 'S30_V1F',
    'S30_V1G', 'S31_V1', 'S32_V1', 'S32_V1A', 'S32_V1B', 'S32_V1C',
    'S32_V1D', 'S32_V1E', 'S32_V1F', 'S32_V1G', 'S32_V1H', 'S32_V1I',
    'S33_V1', 'S34_V1', 'S35_V1', 'S36_V1', 'S37_V1', 'S38_V1', 'S39A_V1',
    'S39B_V1', 'S40_V1', 'S41_V1', 'S42_V1', 'S43_V1', 'S43_V1A',
    'S43_V1B', 'S43_V1C', 'S43_V1D', 'S43_V1E', 'S43_V1F', 'S43_V1G',
    'S43_V1H', 'S43_V1I'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

#   [1] "s_2"    "s_2a"   "s_2b"   "s_2c"   "s_2d"   "s_2e"   "s_2f"  
#   [8] "s_2g"   "s_2h"   "sr_3a"  "sr_3b"  "sr_3c"  "sr_3d"  "sr_3e" 
#  [15] "sr_3f"  "s_3"    "s_4"    "s_4a"   "s_4b"   "s_4c"   "s_4d"  
#  [22] "s_4e"   "s_4f"   "s_4g"   "s_4h"   "s_5"    "s_6"    "s_7"   
#  [29] "s_7a"   "s_7b"   "s_7c"   "s_7d"   "s_7e"   "s_7f"   "s_7g"  
#  [36] "s_8"    "s_8a"   "s_8b"   "s_8c"   "s_8d"   "s_8e"   "s_8f"  
#  [43] "s_8g"   "s_9"    "s_9a"   "s_9b"   "s_9c"   "s_9d"   "s_9e"  
#  [50] "s_9f"   "s_9g"   "s_9h"   "s_9i"   "s_9j"   "s_9k"   "s_9l"  
#  [57] "s_9m"   "s_9n"   "s_9o"   "s_9p"   "s_9q"   "s_9r"   "s_10"  
#  [64] "s_11"   "s_12"   "s_13"   "s_14"   "s_14a"  "s_14b"  "s_14c" 
#  [71] "s_14d"  "s_15"   "s_16"   "s_17"   "s_18"   "s_18a"  "s_18b" 
#  [78] "s_18c"  "s_18d"  "s_18e"  "s_18f"  "s_18g"  "s_18h"  "s_18i" 
#  [85] "s_18j"  "s_18k"  "s_18l"  "s_19"   "s_20"   "s_21"   "s_22"  
#  [92] "s_23"   "s_24"   "s_24a"  "s_24b"  "s_24c"  "s_24d"  "s_24e" 
#  [99] "s_24f"  "s_25a"  "s_26a"  "s_26aa" "s_26ab" "s_26ac" "s_26ad"
# [106] "s_26ae" "s_26af" "s_26ag" "s_25b"  "s_26b"  "s_26ba" "s_26bb"
# [113] "s_26bc" "s_26bd" "s_26be" "s_26bf" "s_26bg" "s_25c"  "s_26c" 
# [120] "s_26ca" "s_26cb" "s_26cc" "s_26cd" "s_26ce" "s_26cf" "s_26cg"
# [127] "s_25d"  "s_26d"  "s_26da" "s_26db" "s_26dc" "s_26dd" "s_26de"
# [134] "s_26df" "s_26dg" "s_25e"  "s_26e"  "s_26ea" "s_26eb" "s_26ec"
# [141] "s_26ed" "s_26ee" "s_26ef" "s_26eg" "s_27"   "s_28"   "s_29"  
# [148] "s_30"   "s_30a"  "s_30b"  "s_30c"  "s_30d"  "s_30e"  "s_30f" 
# [155] "s_30g"  "s_31"   "s_32"   "s_32a"  "s_32b"  "s_32c"  "s_32d" 
# [162] "s_32e"  "s_32f"  "s_32g"  "s_32h"  "s_32i"  "s_33"   "s_34"  
# [169] "s_35"   "s_36"   "s_37"   "s_38"   "s_39a"  "s_39b"  "s_40"  
# [176] "s_41"   "s_42"   "s_43"   "s_43a"  "s_43b"  "s_43c"  "s_43d" 
# [183] "s_43e"  "s_43f"  "s_43g"  "s_43h"  "s_43i" 
```

We checked for any variables that would either standardize differently, or were absent from the QDS Visit 1 source data set.We manually verified that similar variables corresponded to the same question (i.e. "s_2" in both REDCap and QDS corresponded to the item "Which of the following apply to you? (Check all that apply)").  We found many of the REDCap variables had a different naming convention which escaped our standardization function.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "   
# [2] "In source  v2 : "          
# [3] "In source  v3 : "      
# [4] "In source  v4 : "     
# [5] "In source  v5 : "      
# [6] "In source  redcap : s2_v1___1, s2_v1___2, s2_v1___3, s2_v1___4, 
# s2_v1___5, s2_v1___6, s2_v1___7, s2_v1___8, s4_v1___1, s4_v1___2, s4_v1___3,
# s4_v1___4, s4_v1___5, s4_v1___6, s4_v1___7, s4_v1___8, s7_v1___1, s7_v1___2,
# s7_v1___3, s7_v1___4, s7_v1___5, s7_v1___6, s7_v1___7, s8_v1___1, s8_v1___2,
# s8_v1___3, s8_v1___4, s8_v1___5, s8_v1___6, s8_v1___7, s9_v1___1, s9_v1___2,
# s9_v1___3, s9_v1___4, s9_v1___5, s9_v1___6, s9_v1___7, s9_v1___8, s9_v1___9,
# s9_v1___10, s9_v1___11, s9_v1___12, s9_v1___13, s9_v1___14, s9_v1___15, 
# s9_v1___16, s9_v1___17, s9_v1___18, s14_v1___1, s14_v1___2, s14_v1___3, 
# s14_v1___4, s18_v1___1, s18_v1___2, s18_v1___3, s18_v1___4, s18_v1___5, 
# s18_v1___6, s18_v1___7, s18_v1___8, s18_v1___9, s18_v1___10, s18_v1___11, 
# s18_v1___12, s24_v1___1, s24_v1___2, s24_v1___3, s24_v1___4, s24_v1___5, 
# s24_v1___6, s26a_v1___1, s26a_v1___2, s26a_v1___3, s26a_v1___4, s26a_v1___5,
# s26a_v1___6, s26a_v1___7, s26b_v1___1, s26b_v1___2, s26b_v1___3, 
# s26b_v1___4, s26b_v1___5, s26b_v1___6, s26b_v1___7, s26c_v1___1, 
# s26c_v1___2, s26c_v1___3, s26c_v1___4, s26c_v1___5, s26c_v1___6, 
# s26c_v1___7, s26d_v1___1, s26d_v1___2, s26d_v1___3, s26d_v1___4, 
# s26d_v1___5, s26d_v1___6, s26d_v1___7, s26e_v1___1, s26e_v1___2, 
# s26e_v1___3, s26e_v1___4, s26e_v1___5, s26e_v1___6, s26e_v1___7, s30_v1___1,
# s30_v1___2, s30_v1___3, s30_v1___4, s30_v1___5, s30_v1___6, s30_v1___7, 
# s32_v1___1, s32_v1___2, s32_v1___3, s32_v1___4, s32_v1___5, s32_v1___6, 
# s32_v1___7, s32_v1___8, s32_v1___9, s43_v1___1, s43_v1___2, s43_v1___3, 
# s43_v1___4, s43_v1___5, s43_v1___6, s43_v1___7, s43_v1___8, s43_v1___9"
```

We created our source maps, including required point modifications

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 's_2_1' ~ 's_2a',
      variable == 's_2_2' ~ 's_2b',
      variable == 's_2_3' ~ 's_2c',
      variable == 's_2_4' ~ 's_2d',
      variable == 's_2_5' ~ 's_2e',
      variable == 's_2_6' ~ 's_2f',
      variable == 's_2_7' ~ 's_2g',
      variable == 's_2_8' ~ 's_2h',
      variable == 's_4_1' ~ 's_4a',
      variable == 's_4_2' ~ 's_4b',
      variable == 's_4_3' ~ 's_4c',
      variable == 's_4_4' ~ 's_4d',
      variable == 's_4_5' ~ 's_4e',
      variable == 's_4_6' ~ 's_4f',
      variable == 's_4_7' ~ 's_4g',
      variable == 's_4_8' ~ 's_4h',
      variable == 's_7_1' ~ 's_7a',
      variable == 's_7_2' ~ 's_7b',
      variable == 's_7_3' ~ 's_7c',
      variable == 's_7_4' ~ 's_7d',
      variable == 's_7_5' ~ 's_7e',
      variable == 's_7_6' ~ 's_7f',
      variable == 's_7_7' ~ 's_7g',
      variable == 's_8_1' ~ 's_8a',
      variable == 's_8_2' ~ 's_8b',
      variable == 's_8_3' ~ 's_8c',
      variable == 's_8_4' ~ 's_8d',
      variable == 's_8_5' ~ 's_8e',
      variable == 's_8_6' ~ 's_8f',
      variable == 's_8_7' ~ 's_8g',
      variable == 's_9_1' ~ 's_9a',
      variable == 's_9_2' ~ 's_9b',
      variable == 's_9_3' ~ 's_9c',
      variable == 's_9_4' ~ 's_9d',
      variable == 's_9_5' ~ 's_9e',
      variable == 's_9_6' ~ 's_9f',
      variable == 's_9_7' ~ 's_9g',
      variable == 's_9_8' ~ 's_9h',
      variable == 's_9_9' ~ 's_9i',
      variable == 's_9_10' ~ 's_9j',
      variable == 's_9_11' ~ 's_9k',
      variable == 's_9_12' ~ 's_9l',
      variable == 's_9_13' ~ 's_9m',
      variable == 's_9_14' ~ 's_9n',
      variable == 's_9_15' ~ 's_9o',
      variable == 's_9_16' ~ 's_9p',
      variable == 's_9_17' ~ 's_9q',
      variable == 's_9_18' ~ 's_9r',
      variable == 's_14_1' ~ 's_14a',
      variable == 's_14_2' ~ 's_14b',
      variable == 's_14_3' ~ 's_14c',
      variable == 's_14_4' ~ 's_14d',
      variable == 's_18_1' ~ 's_18a',
      variable == 's_18_2' ~ 's_18b',
      variable == 's_18_3' ~ 's_18c',
      variable == 's_18_4' ~ 's_18d',
      variable == 's_18_5' ~ 's_18e',
      variable == 's_18_6' ~ 's_18f',
      variable == 's_18_7' ~ 's_18g',
      variable == 's_18_8' ~ 's_18h',
      variable == 's_18_9' ~ 's_18i',
      variable == 's_18_10' ~ 's_18j',
      variable == 's_18_11' ~ 's_18k',
      variable == 's_18_12' ~ 's_18l',
      variable == 's_24_1' ~ 's_24a',
      variable == 's_24_2' ~ 's_24b',
      variable == 's_24_3' ~ 's_24c',
      variable == 's_24_4' ~ 's_24d',
      variable == 's_24_5' ~ 's_24e',
      variable == 's_24_6' ~ 's_24f',
      variable == 's_26a_1' ~'s_26aa',
      variable == 's_26a_2' ~'s_26ab',
      variable == 's_26a_3' ~'s_26ac',
      variable == 's_26a_4' ~'s_26ad',
      variable == 's_26a_5' ~'s_26ae',
      variable == 's_26a_6' ~'s_26af',
      variable == 's_26a_7' ~'s_26ag',
      variable == 's_26b_1' ~'s_26ba',
      variable == 's_26b_2' ~'s_26bb',
      variable == 's_26b_3' ~'s_26bc',
      variable == 's_26b_4' ~'s_26bd',
      variable == 's_26b_5' ~'s_26be',
      variable == 's_26b_6' ~'s_26bf',
      variable == 's_26b_7' ~'s_26bg',
      variable == 's_26c_1' ~'s_26ca',
      variable == 's_26c_2' ~'s_26cb',
      variable == 's_26c_3' ~'s_26cc',
      variable == 's_26c_4' ~'s_26cd',
      variable == 's_26c_5' ~'s_26ce',
      variable == 's_26c_6' ~'s_26cf',
      variable == 's_26c_7' ~'s_26cg',
      variable == 's_26d_1' ~'s_26da',
      variable == 's_26d_2' ~'s_26db',
      variable == 's_26d_3' ~'s_26dc',
      variable == 's_26d_4' ~'s_26dd',
      variable == 's_26d_5' ~'s_26de',
      variable == 's_26d_6' ~'s_26df',
      variable == 's_26d_7' ~'s_26dg',
      variable == 's_26e_1' ~'s_26ea',
      variable == 's_26e_2' ~'s_26eb',
      variable == 's_26e_3' ~'s_26ec',
      variable == 's_26e_4' ~'s_26ed',
      variable == 's_26e_5' ~'s_26ee',
      variable == 's_26e_6' ~'s_26ef',
      variable == 's_26e_7' ~'s_26eg',
      variable == 's_30_1' ~ 's_30a',
      variable == 's_30_2' ~ 's_30b',
      variable == 's_30_3' ~ 's_30c',
      variable == 's_30_4' ~ 's_30d',
      variable == 's_30_5' ~ 's_30e',
      variable == 's_30_6' ~ 's_30f',
      variable == 's_30_7' ~ 's_30g',
      variable == 's_32_1' ~ 's_32a',
      variable == 's_32_2' ~ 's_32b',
      variable == 's_32_3' ~ 's_32c',
      variable == 's_32_4' ~ 's_32d',
      variable == 's_32_5' ~ 's_32e',
      variable == 's_32_6' ~ 's_32f',
      variable == 's_32_7' ~ 's_32g',
      variable == 's_32_8' ~ 's_32h',
      variable == 's_32_9' ~ 's_32i',
      variable == 's_43_1' ~ 's_43a',
      variable == 's_43_2' ~ 's_43b',
      variable == 's_43_3' ~ 's_43c',
      variable == 's_43_4' ~ 's_43d',
      variable == 's_43_5' ~ 's_43e',
      variable == 's_43_6' ~ 's_43f',
      variable == 's_43_7' ~ 's_43g',
      variable == 's_43_8' ~ 's_43h',
      variable == 's_43_9' ~ 's_43i',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Self-Rated Health', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('srh' = inst_map))

rm(inst_map)
```

### TCU Drug Screen 5

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The TCU Drug Screen 5 was not used in the Visit 1 collection.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "DS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

#  [1] "DS1_V2"   "DS2_V2"   "DS3_V2"   "DS4_V2"   "DS5_V2"   "DS6_V2"  
#  [7] "DS7_V2"   "DS8_V2"   "DS9_V2"   "DS10A_V2" "DS10B_V2" "DS11A_V2"
# [13] "DS11B_V2" "DS10_V2"  "DS11_V2" 
```

In manual inspection of the variables, we identified that `DS10_V2` and `DS11_V2` were SPSS calculated variables only present in Visit 2.

```{r}
dropping[['v2']] <- c(dropping[['v2']], 'DS10_V2', 'DS11_V2')
```

We checked to see if any of these variables were only missing values in Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "ds1_v2"   "ds2_v2"   "ds3_v2"   "ds4_v2"   "ds5_v2"   "ds6_v2"  
#  [7] "ds7_v2"   "ds8_v2"   "ds9_v2"   "ds10a_v2" "ds10b_v2" "ds11a_v2"
# [13] "ds11b_v2"
```

We checked to see if any of these variables were only missing values in the REDCap, and found none.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
    'DS1_V2', 'DS2_V2', 'DS3_V2', 'DS4_V2', 'DS5_V2', 'DS6_V2', 
    'DS7_V2', 'DS8_V2', 'DS9_V2', 'DS10A_V2', 'DS10B_V2', 'DS11A_V2',
    'DS11B_V2'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars

 # [1] "ds_1"   "ds_2"   "ds_3"   "ds_4"   "ds_5"   "ds_6"   "ds_7"  
 # [8] "ds_8"   "ds_9"   "ds_10a" "ds_10b" "ds_11a" "ds_11b"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "ds_1" in both REDCap and QDS corresponded to the item "During the last 3 months, did you use larger amounts of drugs and/or alcohol or use them for a longer time than you planned or intended?"). 
We only identified the SPSS calculated variables already selected for dropping.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                 "In source  v2 : DS10_V2, DS11_V2"
# [3] "In source  v3 : "                 "In source  v4 : "                
# [5] "In source  v5 : "                 "In source  redcap : "  
```

We created our source maps.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'TCU Drug Screen 5', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('tcu_ds' = inst_map))

rm(inst_map)
```

### Primary Care PTSD Screen (PC-PTSD)

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "PTSD"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "PTSD1_V1"        "PTSD2_V1"        "PTSD3_V1"       
# [4] "PTSD4_V1"        "PTSD_V1_total"   "PTSD_V1_postive"
```

In manual inspection of the variables, we identified that `PTSD_V1_total` and `PTSD_V1_positive` were SPSS calculated variables.

```{r}
dropping[['v1']] <- c(
  dropping[['v1']], 'PTSD_V1_total', 'PTSD_V1_postive'
  )
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "ptsd1_v1" "ptsd2_v1" "ptsd3_v1" "ptsd4_v1"
```

We checked to see if any of these variables were only missing values in the REDCap. All four of our variables were missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "ptsd1_v1 is only missing values" "ptsd2_v1 is only missing values"
# [3] "ptsd3_v1 is only missing values" "ptsd4_v1 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
    'PTSD1_V1', 'PTSD2_V1', 'PTSD3_V1', 'PTSD4_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

# [1] "ptsd_1" "ptsd_2" "ptsd_3" "ptsd_4"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "ptsd_1" in both REDCap and QDS corresponded to the item "In your life, have you ever had any experience that was so frightening, horrible, or upsetting that, in the past month, you have had nightmares about it or thought about it when you did not want to?").
We only identified the SPSS calculated variables previously identified for dropping in QDS Visit 1.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : PTSD_V1_total, PTSD_V1_postive"
# [2] "In source  v2 : "                              
# [3] "In source  v3 : "                              
# [4] "In source  v4 : "                              
# [5] "In source  v5 : "                              
# [6] "In source  redcap : " 
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Primary Care PTSD Screen (PC-PTSD)', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('ptsd' = inst_map))

rm(inst_map)
```

### BRFSS Adverse Childhood Experience (ACE) Module

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The BRFSS Adverse Childhood Experience (ACE) Module was not used in Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "BRA"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

 # [1] "BRAC1"  "BRAC2"  "BRAC3"  "BRAC4"  "BRAC5"  "BRAC6"  "BRAC7" 
 # [8] "BRAC8"  "BRAC9"  "BRAC10" "BRAC11"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "brac1"  "brac2"  "brac3"  "brac4"  "brac5"  "brac6"  "brac7" 
 # [8] "brac8"  "brac9"  "brac10" "brac11"
```

We checked to see if any of these variables were only missing values in the REDCap. All of the variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

#  [1] "brac1 is only missing values"  "brac2 is only missing values" 
#  [3] "brac3 is only missing values"  "brac4 is only missing values" 
#  [5] "brac5 is only missing values"  "brac6 is only missing values" 
#  [7] "brac7 is only missing values"  "brac8 is only missing values" 
#  [9] "brac9 is only missing values"  "brac10 is only missing values"
# [11] "brac11 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'BRAC1', 'BRAC2', 'BRAC3', 'BRAC4', 'BRAC5', 'BRAC6', 'BRAC7', 
  'BRAC8', 'BRAC9', 'BRAC10', 'BRAC11'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars

 # [1] "brac_1"  "brac_2"  "brac_3"  "brac_4"  "brac_5"  "brac_6" 
 # [7] "brac_7"  "brac_8"  "brac_9"  "brac_10" "brac_11"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "brac_1" in both REDCap and QDS corresponded to the item "Now, looking back before you were 18 years of age did you live with anyone who was depressed, mentally ill, or suicidal?"). 

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'BRFSS Adverse Childhood Experience (ACE) Module', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('brfss_ace' = inst_map))

rm(inst_map)
```

### Tobacco History

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "t"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c("TODAY", "TIME", "TEST", "TCU", "TQ"))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#   [1] "T1_V1"    "T2_V1"    "T3A_V1"   "T3B_V1"   "T4_V1"    "T5_V1"   
#   [7] "T5A1_V1"  "T5A2_V1"  "T5A3_V1"  "T5A4_V1"  "T5A5_V1"  "T5A6_V1" 
#  [13] "T6_V1"    "T6A1_V1"  "T6A2_V1"  "T6A3_V1"  "T6A4_V1"  "T6A5_V1" 
#  [19] "T6A6_V1"  "T7_V1"    "T8_V1"    "T9_V1"    "T10_V1"   "T11_V1"  
#  [25] "T12_V1"   "T12A_V1"  "T12B_V1"  "T13_V1"   "T14_V1"   "T15_V1"  
#  [31] "T16_V1"   "T17_V1"   "T18_V1"   "T19_V1"   "T20_V1"   "T21_V1"  
#  [37] "T22_V1"   "T23_V1"   "T24_V1"   "T25_V1"   "T26A_V1"  "T27_V1"  
#  [43] "T28_V1"   "T29_V1"   "T30_V1"   "T31_V1"   "T31B_V1"  "T32_V1"  
#  [49] "T33_V1"   "T34_V1"   "T35_V1"   "T36_V1"   "T37_V1"   "T38_V1"  
#  [55] "T39_V1"   "T40_V1"   "T3A_V1Y"  "T3A_V1M"  "T14_V1A"  "T14_V1B" 
#  [61] "T14_V1C"  "T14_V1D"  "T14_V1E"  "T14_V1F"  "T14_V1G"  "T14_V1H" 
#  [67] "T14_V1I"  "T23_V1A"  "T23_V1B"  "T23_V1C"  "T23_V1D"  "T23_V1E" 
#  [73] "T23_V1F"  "T23_V1G"  "T23_V1H"  "T26A_V1A" "T26A_V1B" "T26A_V1C"
#  [79] "T26A_V1D" "T26A_V1E" "T26A_V1F" "T31_V1A"  "T31_V1B"  "T31_V1C" 
#  [85] "T31_V1D"  "T31_V1E"  "T31_V1F"  "T31_V1G"  "T31_V1H"  "T31_V1I" 
#  [91] "T31_V1J"  "T31B_V1A" "T31B_V1B" "T31B_V1C" "T33_V1A"  "T33_V1B" 
#  [97] "T33_V1C"  "T33_V1D"  "T33_V1E"  "T33_V1F"  "T33_V1G"  "T33_V1H" 
# [103] "T33_V1I"  "T33_V1J"  "T5_V1val" "T6_V1val"
```

In manual inspection of the variables, we identified that the variables containing "val" were SPSS calculated variables.
We marked these variables for dropping.

```{r}
dropping[['v1']] <- c(dropping[['v1']], 'T5_V1val', 'T6_V1val')
dropping[['v3']] <- c(dropping[['v3']], 'T5_V3val', 'T6_V3val')
dropping[['v4']] <- c(dropping[['v4']], 'T5_V4val', 'T6_V4val')
dropping[['v5']] <- c(dropping[['v5']], 'T5_V5val', 'T6_V5val')
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "t1_v1"       "t2_v1"       "t3a_v1y"     "t3a_v1m"    
#  [5] "t3b_v1"      "t4_v1"       "t5_v1"       "t5a1_v1"    
#  [9] "t5a2_v1"     "t5a3_v1"     "t5a4_v1"     "t5a5_v1"    
# [13] "t5a6_v1"     "t6_v1"       "t6a1_v1"     "t6a2_v1"    
# [17] "t6a3_v1"     "t6a4_v1"     "t6a5_v1"     "t6a6_v1"    
# [21] "t7_v1"       "t8_v1"       "t9_v1"       "t10_v1"     
# [25] "t11_v1"      "t12_v1"      "t12a_v1"     "t12b_v1"    
# [29] "t13_v1"      "t14_v1___1"  "t14_v1___2"  "t14_v1___3" 
# [33] "t14_v1___4"  "t14_v1___5"  "t14_v1___6"  "t14_v1___7" 
# [37] "t14_v1___8"  "t14_v1___9"  "t15_v1"      "t16_v1"     
# [41] "t17_v1"      "t18_v1"      "t19_v1"      "t20_v1"     
# [45] "t21_v1"      "t22_v1"      "t23_v1___1"  "t23_v1___2" 
# [49] "t23_v1___3"  "t23_v1___4"  "t23_v1___5"  "t23_v1___6" 
# [53] "t23_v1___7"  "t23_v1___8"  "t24_v1"      "t25_v1"     
# [57] "t26_v1___1"  "t26_v1___2"  "t26_v1___3"  "t26_v1___4" 
# [61] "t26_v1___5"  "t26_v1___6"  "t27_v1"      "t28_v1"     
# [65] "t29_v1"      "t30_v1"      "t31_v1___1"  "t31_v1___2" 
# [69] "t31_v1___3"  "t31_v1___4"  "t31_v1___5"  "t31_v1___6" 
# [73] "t31_v1___7"  "t31_v1___8"  "t31_v1___9"  "t31_v1___10"
# [77] "t31b_v1___1" "t31b_v1___2" "t31b_v1___3" "t32_v1"     
# [81] "t33_v1___1"  "t33_v1___2"  "t33_v1___3"  "t33_v1___4" 
# [85] "t33_v1___5"  "t33_v1___6"  "t33_v1___7"  "t33_v1___8" 
# [89] "t33_v1___9"  "t33_v1___10" "t34_v1"      "t35_v1"     
# [93] "t36_v1"      "t37_v1"      "t38_v1"      "t39_v1"     
# [97] "t40_v1"     
```

We checked to see if any of these variables were only missing values in the REDCap. We found that 13 of our 97 variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

#  [1] "t4_v1 is only missing values"   "t8_v1 is only missing values"  
#  [3] "t9_v1 is only missing values"   "t11_v1 is only missing values" 
#  [5] "t12_v1 is only missing values"  "t12a_v1 is only missing values"
#  [7] "t12b_v1 is only missing values" "t13_v1 is only missing values" 
#  [9] "t15_v1 is only missing values"  "t18_v1 is only missing values" 
# [11] "t19_v1 is only missing values"  "t20_v1 is only missing values" 
# [13] "t21_v1 is only missing values" 
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

We received an error regarding two variables that could not be standardized with our standardization function.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'T1_V1', 'T2_V1', 'T3A_V1', 'T3A_V1Y', 'T3A_V1M', 'T3B_V1', 'T4_V1',
  'T5_V1', 'T5A1_V1', 'T5A2_V1', 'T5A3_V1', 'T5A4_V1', 'T5A5_V1',
  'T5A6_V1', 'T6_V1', 'T6A1_V1', 'T6A2_V1', 'T6A3_V1', 'T6A4_V1',
  'T6A5_V1', 'T6A6_V1', 'T7_V1', 'T8_V1', 'T9_V1', 'T10_V1', 'T11_V1',
  'T12_V1', 'T12A_V1', 'T12B_V1', 'T13_V1', 'T14_V1', 'T14_V1A', 'T14_V1B',
  'T14_V1C', 'T14_V1D', 'T14_V1E', 'T14_V1F', 'T14_V1G', 'T14_V1H',
  'T14_V1I', 'T15_V1', 'T16_V1', 'T17_V1', 'T18_V1', 'T19_V1', 'T20_V1',
  'T21_V1', 'T22_V1', 'T23_V1', 'T23_V1A', 'T23_V1B', 'T23_V1C', 
  'T23_V1D', 'T23_V1E', 'T23_V1F', 'T23_V1G', 'T23_V1H', 'T24_V1',
  'T25_V1', 'T26A_V1', 'T26A_V1A', 'T26A_V1B', 'T26A_V1C', 'T26A_V1D',
  'T26A_V1E', 'T26A_V1F', 'T27_V1', 'T28_V1', 'T29_V1', 'T30_V1', 'T31_V1',
  'T31_V1A', 'T31_V1B', 'T31_V1C', 'T31_V1D', 'T31_V1E', 'T31_V1F',
  'T31_V1G', 'T31_V1H', 'T31_V1I', 'T31_V1J', 'T31B_V1', 'T31B_V1A',
  'T31B_V1B', 'T31B_V1C', 'T32_V1', 'T33_V1', 'T33_V1A', 'T33_V1B',
  'T33_V1C', 'T33_V1D', 'T33_V1E', 'T33_V1F', 'T33_V1G', 'T33_V1H',
  'T33_V1I', 'T33_V1J', 'T34_V1', 'T35_V1', 'T36_V1', 'T37_V1', 'T38_V1',
  'T39_V1', 'T40_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: T31_V1B, 
# T31B_V1
```

From manual inspection, we determined that:

-   `T31_V1B` should standardize to `t_31b`
-   `T31B_V1` should standardize to \`t_31_b

We created these point-modifications.

```{r}
desired_vars[desired_vars == 'T31_V1B'] <- 't_31b'
desired_vars[desired_vars == 'T31B_V1'] <- 't_31_b'

desired_vars

 #  [1] "t_1"    "t_2"    "t_3a"   "t_3ay"  "t_3am"  "t_3b"   "t_4"   
 #  [8] "t_5"    "t_5a1"  "t_5a2"  "t_5a3"  "t_5a4"  "t_5a5"  "t_5a6" 
 # [15] "t_6"    "t_6a1"  "t_6a2"  "t_6a3"  "t_6a4"  "t_6a5"  "t_6a6" 
 # [22] "t_7"    "t_8"    "t_9"    "t_10"   "t_11"   "t_12"   "t_12a" 
 # [29] "t_12b"  "t_13"   "t_14"   "t_14a"  "t_14b"  "t_14c"  "t_14d" 
 # [36] "t_14e"  "t_14f"  "t_14g"  "t_14h"  "t_14i"  "t_15"   "t_16"  
 # [43] "t_17"   "t_18"   "t_19"   "t_20"   "t_21"   "t_22"   "t_23"  
 # [50] "t_23a"  "t_23b"  "t_23c"  "t_23d"  "t_23e"  "t_23f"  "t_23g" 
 # [57] "t_23h"  "t_24"   "t_25"   "t_26a"  "t_26aa" "t_26ab" "t_26ac"
 # [64] "t_26ad" "t_26ae" "t_26af" "t_27"   "t_28"   "t_29"   "t_30"  
 # [71] "t_31"   "t_31a"  "t_31b"  "t_31c"  "t_31d"  "t_31e"  "t_31f" 
 # [78] "t_31g"  "t_31h"  "t_31i"  "t_31j"  "t_31_b" "t_31ba" "t_31bb"
 # [85] "t_31bc" "t_32"   "t_33"   "t_33a"  "t_33b"  "t_33c"  "t_33d" 
 # [92] "t_33e"  "t_33f"  "t_33g"  "t_33h"  "t_33i"  "t_33j"  "t_34"  
 # [99] "t_35"   "t_36"   "t_37"   "t_38"   "t_39"   "t_40"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "t_1" in both REDCap and QDS corresponded to the item "Have you smoked at least 100 cigarettes (or cigarillos) in your entire life? (NOTE: 5 packs = 100 cigarettes)").

We only identified the variables which escaped our standardization function, the previously identified SPSS variables to drop, and the REDCap variables with a different naming convention.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# Warning: Warning: The following column name(s) could not be standardized
# because it/they would have created a duplicate column name: T31B_V1,
# T31_V1B
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: T31B_V3, 
# T31_V3B
# Warning: Warning: The following column name(s) could not be standardized # because it/they would have created a duplicate column name: T31B_V4, 
# T31_V4B
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: T31B_V5, 
# T31_V5B
# [1] "In source  v1 : T31B_V1, T31_V1B, T5_V1val, T6_V1val"
# [2] "In source  v2 : "                                    
# [3] "In source  v3 : T31B_V3, T31_V3B, T5_V3val, T6_V3val"
# [4] "In source  v4 : T31B_V4, T31_V4B, T5_V4val, T6_V4val"
# [5] "In source  v5 : T31B_V5, T31_V5B, T5_V5val, T6_V5val"
# [6] "In source  redcap : t14_v1___1, t14_v1___2, t14_v1___3, t14_v1___4, 
# t14_v1___5, t14_v1___6, t14_v1___7, t14_v1___8, t14_v1___9, t23_v1___1, 
# t23_v1___2, t23_v1___3, t23_v1___4, t23_v1___5, t23_v1___6, t23_v1___7, 
# t23_v1___8, t26_v1___1, t26_v1___2, t26_v1___3, t26_v1___4, t26_v1___5, 
# t26_v1___6, t31_v1___1, t31_v1___2, t31_v1___3, t31_v1___4, t31_v1___5, 
# t31_v1___6, t31_v1___7, t31_v1___8, t31_v1___9, t31_v1___10, t31b_v1___1, 
# t31b_v1___2, t31b_v1___3, t33_v1___1, t33_v1___2, t33_v1___3, t33_v1___4, 
# t33_v1___5, t33_v1___6, t33_v1___7, t33_v1___8, t33_v1___9, t33_v1___10"
```

We created our source maps, including the required point-mutations.

```{r, warning=FALSE}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
    ) %>%
  mutate(variable = case_when(
        variable == 'T31_V1B' ~ 't_31b',
        variable == 'T31B_V1' ~'t_31_b',
        TRUE ~ variable
        )
  )%>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'T31_V3B' ~ 't_31b',
        variable == 'T31B_V3' ~'t_31_b',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'T31_V4B' ~ 't_31b',
        variable == 'T31B_V4' ~'t_31_b',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'T31_V5B' ~ 't_31b',
        variable == 'T31B_V5' ~'t_31_b',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 't_14_1' ~ 't_14a',
      variable == 't_14_2' ~ 't_14b',
      variable == 't_14_3' ~ 't_14c',
      variable == 't_14_4' ~ 't_14d',
      variable == 't_14_5' ~ 't_14e',
      variable == 't_14_6' ~ 't_14f',
      variable == 't_14_7' ~ 't_14g',
      variable == 't_14_8' ~ 't_14h',
      variable == 't_14_9' ~ 't_14i',
      variable == 't_23_1' ~ 't_23a',
      variable == 't_23_2' ~ 't_23b',
      variable == 't_23_3' ~ 't_23c',
      variable == 't_23_4' ~ 't_23d',
      variable == 't_23_5' ~ 't_23e',
      variable == 't_23_6' ~ 't_23f',
      variable == 't_23_7' ~ 't_23g',
      variable == 't_23_8' ~ 't_23h',
      variable == 't_26_1' ~ 't_26aa',
      variable == 't_26_2' ~ 't_26ab',
      variable == 't_26_3' ~ 't_26ac',
      variable == 't_26_4' ~ 't_26ad',
      variable == 't_26_5' ~ 't_26ae',
      variable == 't_26_6' ~ 't_26af',
      variable == 't_31_1' ~ 't_31a',
      variable == 't_31_2' ~ 't_31b',
      variable == 't_31_3' ~ 't_31c',
      variable == 't_31_4' ~ 't_31d',
      variable == 't_31_5' ~ 't_31e',
      variable == 't_31_6' ~ 't_31f',
      variable == 't_31_7' ~ 't_31g',
      variable == 't_31_8' ~ 't_31h',
      variable == 't_31_9' ~ 't_31i',
      variable == 't_31_10' ~ 't_31j',
      variable == 't_31b_1' ~ 't_31ba',
      variable == 't_31b_2' ~ 't_31bb',
      variable == 't_31b_3' ~ 't_31bc',
      variable == 't_33_1' ~ 't_33a',
      variable == 't_33_2' ~ 't_33b',
      variable == 't_33_3' ~ 't_33c',
      variable == 't_33_4' ~ 't_33d',
      variable == 't_33_5' ~ 't_33e',
      variable == 't_33_6' ~ 't_33f',
      variable == 't_33_7' ~ 't_33g',
      variable == 't_33_8' ~ 't_33h',
      variable == 't_33_9' ~ 't_33i',
      variable == 't_33_10' ~ 't_33j',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Tobacco History', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('tobac_hist' = inst_map))

rm(inst_map)
```

### Heaviness of Smoking Index

We identified our keys and identified the matching variables in the qDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "HSI"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "HSI1_V1" "HSI2_V1" "hsi"     "HSI_cat"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables `hsi` and `HSI_CAT` were SPSS calculated variables we wished to drop.

```{r}
dropping[['v1']] <- c(dropping[['v1']], 'hsi', 'HSI_cat')
dropping[['v3']] <- c(dropping[['v3']], 'hsi_V3', 'HSI_V3_cat')
dropping[['v4']] <- c(dropping[['v4']], 'hsi_V4', 'HSI_V4_cat')
dropping[['v5']] <- c(dropping[['v5']], 'hsi_V5', 'HSI_V5_cat')
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "hsi1_v1"  "hsi2_v13"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.


```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'HSI1_V1', 'HSI2_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

# [1] "hsi_1" "hsi_2"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "hsi_1" in both REDCap and QDS corresponded to the item "How many cigarettes per day do you smoke?"). 
We identified the SPSS calculated variables identified for dropping.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : hsi, HSI_cat"      
# [2] "In source  v2 : "                  
# [3] "In source  v3 : hsi_V3, HSI_V3_cat"
# [4] "In source  v4 : hsi_V4, HSI_V4_cat"
# [5] "In source  v5 : hsi_V5, HSI_V5_cat"
# [6] "In source  redcap : "  
```

We created our source maps, including the necessary point-modifications.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Heaviness of Smoking Index', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('hsi' = inst_map))

rm(inst_map)
```

### Behavioral Risk Factor Surveillance System (BRFSS) Inadequate Sleep

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "BRS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "BRS1_V1" "BRS2_V1" "BRS3_V1" "BRS4_V1" "BRS5_V1"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "brs1_v1" "brs2_v1" "brs3_v1" "brs4_v1" "brs5_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'BRS1_V1', 'BRS2_V1', 'BRS3_V1', 'BRS4_V1', 'BRS5_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "brs_1" in both REDCap and QDS corresponded to the item "During the past 30 days, for how many days have you felt you did not get enough rest or sleep?"). 

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Behavioral Risk Factor Surveillance System (BRFSS) Inadequate Sleep',
  desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('brfss_sleep' = inst_map))

rm(inst_map)
```

### Alcohol Quantity and Frequency Questionnaire

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "AF"
  ), 
  'contains' = c("DRINKS")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "AF1_V1"   "AF2M_V1"  "AF3TU_V1" "AF4W_V1"  "AF5TH_V1" "AF6F_V1" 
#  [7] "AF6SA_V1" "AF8SU_V1" "AF9_V1"   "AF9A_V1"  "AF9B_V1"  "AF9C_V1" 
# [13] "DRINKS"  
```

We checked to see if any of these variables were only missing values in WDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "af1_v1"   "af2m_v1"  "af3tu_v1" "af4w_v1"  "af5th_v1" "af6f_v1" 
#  [7] "af6sa_v1" "af8su_v1" "af9_v1"   "af9a_v1"  "af9b_v1"  "af9c_v1" 
# [13] "drinks"  
```

We checked to see if any of these variables were only missing values in the REDCap. We found that `af9c_v1` contained only missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "af9c_v1 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'DRINKS', 'AF1_V1', 'AF2M_V1', 'AF3TU_V1', 'AF4W_V1', 'AF5TH_V1',
  'AF6F_V1', 'AF6SA_V1', 'AF8SU_V1', 'AF9_V1', 'AF9A_V1', 'AF9B_V1',
  'AF9C_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

 # [1] "drinks" "af_1"   "af_2m"  "af_3tu" "af_4w"  "af_5th" "af_6f" 
 # [8] "af_6sa" "af_8su" "af_9"   "af_9a"  "af_9b"  "af_9c" 
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "af_1" in both REDCap and QDS corresponded to the item "Have you consumed alcohol (including beer and wine) in the past 3 years?"). 

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Alcohol Quantity and Frequency Questionnaire', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('aqf' = inst_map))

rm(inst_map)
```

### Alcohol and Drug Timeline Follow-Back (TLFB) 

The Alcohol and Drug Timeline Follow-Back was stored in the TLFB data set.

We identified the variables for the Alcohol and Drug section.

```{r}
tlfb_vars <- tlfb %>%
  select(all_of(contains(c(
      "DRUG", "ALCOHOL", "ALC", "DRINK"
      )))
    ) %>%
  names()

tlfb_vars

#  [1] "Num_Days_Using_Drugs"    "Per_Days_Using_Drugs"   
#  [3] "Per_Drug_Abstinent_Days" "Drug_Use_Days_Yr"       
#  [5] "Drug_Use_Days_Week"      "Num_Alc_Abstinent_Days" 
#  [7] "TotalDrinks"             "Num_Drinking_Days"      
#  [9] "Ave_Drinks_Day"          "Heavy_Drinking_Days"    
# [11] "Greatest_Drinks_1_Day"   "Drinks_Wk"  
```
We checked to see if any of these variables only contained missing values, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in tlfb_vars){
  if(sum(!is.na(tlfb[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
tlfb_vars <- tlfb %>%
  select(all_of(c(
    "TotalDrinks", "Num_Alc_Abstinent_Days", "Num_Drinking_Days", 
    "Ave_Drinks_Day", "Heavy_Drinking_Days", "Greatest_Drinks_1_Day",
    "Drinks_Wk", "Num_Days_Using_Drugs", "Per_Days_Using_Drugs",
    "Per_Drug_Abstinent_Days", "Drug_Use_Days_Yr", "Drug_Use_Days_Week"
    ))
  ) %>%
  names()

desired_vars <- standardize_col_names(tlfb_vars)

desired_vars

#  [1] "totaldrinks"             "num_alc_abstinent_days" 
#  [3] "num_drinking_days"       "ave_drinks_day"         
#  [5] "heavy_drinking_days"     "greatest_drinks_1_day"  
#  [7] "drinks_wk"               "num_days_using_drugs"   
#  [9] "per_days_using_drugs"    "per_drug_abstinent_days"
# [11] "drug_use_days_yr"        "drug_use_days_week"
```

We created our source map. As this only composed a single source (thus named variables and desired variables would be in the same order), we manually created the tibble for brevity.

```{r}
source_maps <- tibble::tibble(
  'tlfb' = tlfb_vars,
  'variable' = desired_vars
)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Alcohol and Drug Timeline Follow-Back (TLFB)', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('alc_tlfb' = inst_map))

rm(inst_map)
```


### Personality Beliefs Questionnaire

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The Personality Beliefs Questionnaire was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "PBQ"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

# [1] "PBQ1"         "PBQ2"         "PBQ3"         "PBQ4"        
# [5] "PBQ5"         "PBQ6"         "PBQ7"         "pbq_v2_total"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variable `pbq_v2_total` was an SPSS calculated variable only present in QDS Visit 2, which we wished to drop.

```{r}
dropping[['v2']] <- c(dropping[['v2']], 'pbq_v2_total')
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 
# [1] "pbq1" "pbq2" "pbq3" "pbq4" "pbq5" "pbq6" "pbq7"
```

We checked to see if any of these variables were only missing values in the REDCap. We found that all 7 of our variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "pbq1 is only missing values" "pbq2 is only missing values"
# [3] "pbq3 is only missing values" "pbq4 is only missing values"
# [5] "pbq5 is only missing values" "pbq6 is only missing values"
# [7] "pbq7 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'PBQ1', 'PBQ2', 'PBQ3', 'PBQ4', 'PBQ5', 'PBQ6', 'PBQ7'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars

# [1] "pbq_1" "pbq_2" "pbq_3" "pbq_4" "pbq_5" "pbq_6" "pbq_7"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "pbq_1" in both REDCap and QDS corresponded to the item "I should do whatever I can get away with."). 

We only identified the SPSS variable we had already marked for dropping.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)
```

We created our source maps.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Personality Beliefs Questionnaire', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('pbq' = inst_map))

rm(inst_map)
```

### USDA Food Security Survey

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The USDA Food Security Survey was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "FSS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

#  [1] "FSS1_V2"                  "FSS2_V2"                 
#  [3] "FSS3_V2"                  "FSS3A_V2"                
#  [5] "FSS4_V2"                  "FSS5_V2"                 
#  [7] "fss_a_V2"                 "fss_b_V2"                
#  [9] "fss_c_V2"                 "fss_d_V2"                
# [11] "fss_e_V2"                 "fss_f_V2"                
# [13] "FSS_V2_total"             "FSS_V2_score"            
# [15] "FSS_V2_score_dichotomous"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables `fss_a_V2`, `fss_b_V2`, `fss_c_V2`, `fss_d_V2`, `fss_e_V2`, `fss_f_V2`, `FSS_V2_total`, `FSS_V2_score`, and `FSS_V2_score_dichotomous` were SPSS calculated variables which we wished to drop.

```{r}
dropping[['v2']] <- c(
  dropping[['v2']], 'fss_a_V2', 'fss_b_V2', 'fss_c_V2', 'fss_d_V2',
  'fss_e_V2', 'fss_f_V2', 'FSS_V2_total', 'FSS_V2_score',
  'FSS_V2_score_dichotomous'
  )

dropping[['v3']] <- c(
  dropping[['v3']], 'fss_a_V3', 'fss_b_V3', 'fss_c_V3', 'fss_d_V3',
  'fss_e_V3', 'fss_f_V3', 'FSS_V3_total', 'FSS_V3_score',
  'FSS_V3_score_dichotomous'
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'fss_a_V4', 'fss_b_V4', 'fss_c_V4', 'fss_d_V4',
  'FSSe_V4', 'FSSf_V4', 'FSS_V4_total', 'FSS_V4_score',
  'FSS_V4_score_dichotomous'
  )

dropping[['v5']] <- c(
  dropping[['v5']], 'fss_a_V5', 'fss_b_V5', 'fss_c_V5', 'fss_d_V5',
  'fss_e_V5', 'fss_f_V5', 'FSS_V5_total', 'FSS_V5_score',
  'FSS_V5_score_dichotomous'
  )
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "fss1_v2"  "fss2_v2"  "fss3_v2"  "fss3a_v2" "fss4_v2"  "fss5_v2"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.


```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'FSS1_V2', 'FSS2_V2', 'FSS3_V2', 'FSS3A_V2', 'FSS4_V2', 'FSS5_V2'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars

# [1] "fss_1"  "fss_2"  "fss_3"  "fss_3a" "fss_4"  "fss_5" 
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "fss_1" in both REDCap and QDS corresponded to the item "In the last month, the food that you bought just didn’t last, and you didn’t have money to get more."). 

We only identified the calculated variables we already identified for dropping.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                                   
# [2] "In source  v2 : fss_a_V2, fss_b_V2, fss_c_V2, fss_d_V2, fss_e_V2, 
# fss_f_V2, FSS_V2_total, FSS_V2_score, FSS_V2_score_dichotomous"
# [3] "In source  v3 : fss_a_V3, fss_b_V3, fss_c_V3, fss_d_V3, fss_e_V3, 
# fss_f_V3, FSS_V3_total, FSS_V3_score, FSS_V3_score_dichotomous"
# [4] "In source  v4 : fss_a_V4, fss_b_V4, fss_c_V4, fss_d_V4, FSSe_V4, 
# FSSf_V4, FSS_V4_total, FSS_V4_score, FSS_V4_score_dichotomous"  
# [5] "In source  v5 : fss_a_V5, fss_b_V5, fss_c_V5, fss_d_V5, fss_e_V5, 
# fss_f_V5, FSS_V5_total, FSS_V5_score, FSS_V5_score_dichotomous"
# [6] "In source  redcap : "
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'USDA Food Security Survey', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('food_sec' = inst_map))

rm(inst_map)
```

### Meal Survey

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "MS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "MS1_V1" "MS2_V1" "MS3_V1" "MS8_V1"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "ms1_v1" "ms2_v1" "ms3_v1" "ms8_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

In manually examining `MS8_V1`, it appeared to be a typographical error that resulted in mis-numbering: it should map to `ms_4`.
We manually created that point-fix.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'MS1_V1', 'MS2_V1', 'MS3_V1', 'MS8_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)
desired_vars[desired_vars == 'ms_8'] <- 'ms_4'

desired_vars
# [1] "ms_1" "ms_2" "ms_3" "ms_4"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "sq_2" in both REDCap and QDS corresponded to the item "Are you Hispanic or Latino?"). 

We only identified the variable with a typographical error in QDS Visit 1, which had a similar error in Visit 5 and the REDCap set.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : MS8_V1"     "In source  v2 : "          
# [3] "In source  v3 : "           "In source  v4 : "          
# [5] "In source  v5 : MS8_V5"     "In source  redcap : ms8_v1"
```

We created our source maps, including the required point-fixes.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
    ) %>%
  mutate(variable = case_when(
        variable == 'ms_8' ~ 'ms_4',
        TRUE ~ variable
        )
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'ms_8' ~ 'ms_4',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'ms_8' ~ 'ms_4',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Meal Survey', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('meal' = inst_map))

rm(inst_map)
```

### TCU CJ Client Evaluation of Self and Treatment (CJ CEST)

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The TCU CJ Client Evaluation of Self and Treatment (CJ CEST) was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "CJ"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

#  [1] "CJ1_V2"   "CJ2_V2"   "CJ3_V2"   "CJ4_V2"   "CJ5_V2"   "CJ6_V2"  
#  [7] "CJ7_V2"   "CJ8_V2"   "CJ9_V2"   "CJ10_V2"  "CJ11_V2"  "CJ12_V2" 
# [13] "CJ13_V2"  "CJ14_V2"  "CJ15_V2"  "CJ16_V2"  "CJ17_V2"  "CJ18_V2" 
# [19] "CJ19_V2"  "CJ20_V2"  "CJ21_V2"  "CJ22_V2"  "CJ23_V2"  "CJ24_V2" 
# [25] "CJ25_V2"  "CJ26_V2"  "CJ27_V2"  "CJ28_V2"  "CJ29_V2"  "CJ30_V2" 
# [31] "CJ31_V2"  "CJ32_V2"  "CJ33_V2"  "CJ34_V2"  "CJ35_V2"  "CJ36_V2" 
# [37] "CJ37_V2"  "CJ38_V2"  "CJ39_V2"  "CJ40_V2"  "CJ21r_V2" "CJ22r_V2"
# [43] "CJ23r_V2" "CJ25r_V2" "CJ34r_V2" "CJ35r_V2" "CJ36r_V2"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables that included an "r\_" were SPSS calculated variables.
We dropped our SPSS calculated variables from all data sets.

```{r}
dropping[['v2']] <- c(
  dropping[['v2']], 'CJ21r_V2', 'CJ22r_V2', 'CJ23r_V2', 'CJ25r_V2',
  'CJ34r_V2', 'CJ35r_V2', 'CJ36r_V2'
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'CJ21r_V4', 'CJ22r_V4', 'CJ23r_V4', 'CJ25r_V4',
  'CJ34r_V4', 'CJ35r_V4', 'CJ36r_V4'
  )
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "cj1_v2"  "cj2_v2"  "cj3_v2"  "cj4_v2"  "cj5_v2"  "cj6_v2" 
#  [7] "cj7_v2"  "cj8_v2"  "cj9_v2"  "cj10_v2" "cj11_v2" "cj12_v2"
# [13] "cj13_v2" "cj14_v2" "cj15_v2" "cj16_v2" "cj17_v2" "cj18_v2"
# [19] "cj19_v2" "cj20_v2" "cj21_v2" "cj22_v2" "cj23_v2" "cj24_v2"
# [25] "cj25_v2" "cj26_v2" "cj27_v2" "cj28_v2" "cj29_v2" "cj30_v2"
# [31] "cj31_v2" "cj32_v2" "cj33_v2" "cj34_v2" "cj35_v2" "cj36_v2"
# [37] "cj37_v2" "cj38_v2" "cj39_v2" "cj40_v2"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'CJ1_V2', 'CJ2_V2', 'CJ3_V2', 'CJ4_V2', 'CJ5_V2', 'CJ6_V2', 'CJ7_V2',
  'CJ8_V2', 'CJ9_V2', 'CJ10_V2', 'CJ11_V2', 'CJ12_V2', 'CJ13_V2',
  'CJ14_V2', 'CJ15_V2', 'CJ16_V2', 'CJ17_V2', 'CJ18_V2', 'CJ19_V2',
  'CJ20_V2', 'CJ21_V2', 'CJ22_V2', 'CJ23_V2', 'CJ24_V2', 'CJ25_V2',
  'CJ26_V2', 'CJ27_V2', 'CJ28_V2', 'CJ29_V2', 'CJ30_V2', 'CJ31_V2',
  'CJ32_V2', 'CJ33_V2', 'CJ34_V2', 'CJ35_V2', 'CJ36_V2', 'CJ37_V2',
  'CJ38_V2', 'CJ39_V2', 'CJ40_V2'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars

#  [1] "cj_1"  "cj_2"  "cj_3"  "cj_4"  "cj_5"  "cj_6"  "cj_7"  "cj_8" 
#  [9] "cj_9"  "cj_10" "cj_11" "cj_12" "cj_13" "cj_14" "cj_15" "cj_16"
# [17] "cj_17" "cj_18" "cj_19" "cj_20" "cj_21" "cj_22" "cj_23" "cj_24"
# [25] "cj_25" "cj_26" "cj_27" "cj_28" "cj_29" "cj_30" "cj_31" "cj_32"
# [33] "cj_33" "cj_34" "cj_35" "cj_36" "cj_37" "cj_38" "cj_39" "cj_40"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "cj_1" in both REDCap and QDS corresponded to the item "Have you used drugs or alcohol in the past 12 months?"). 

We only found the previously identified calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "     
# [2] "In source  v2 : CJ21r_V2, CJ22r_V2, CJ23r_V2, CJ25r_V2, CJ34r_V2, 
# CJ35r_V2, CJ36r_V2"
# [3] "In source  v3 : "    
# [4] "In source  v4 : "     
# [5] "In source  v5 : "      
# [6] "In source  redcap : "      
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'TCU CJ Client Evaluation of Self and Treatment (CJ CEST)', 
  desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('tcu_cj_cest' = inst_map))

rm(inst_map)
```

### Sexual Behaviors

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "SB"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "SB1_V1"  "SB2_V1"  "SB3_V1"  "SB4_V1"  "SB5_V1"  "SB6_V1" 
#  [7] "SB7_V1"  "SB8_V1"  "SB9_V1"  "SB7_V1A" "SB7_V1B" "SB7_V1C"
# [13] "SB7_V1D" "SB7_V1E" "SB7_V1F" "SB7_V1G"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "sb1_v1"     "sb2_v1"     "sb3_v1"     "sb4_v1"     "sb5_v1"    
#  [6] "sb6_v1"     "sb7_v1___1" "sb7_v1___2" "sb7_v1___3" "sb7_v1___4"
# [11] "sb7_v1___5" "sb7_v1___6" "sb7_v1___7" "sb8_v1"     "sb9_v1"
```

We checked to see if any of these variables were only missing values in the REDCap. We found that 8 of our 15 variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "sb1_v1 is only missing values" "sb2_v1 is only missing values"
# [3] "sb3_v1 is only missing values" "sb4_v1 is only missing values"
# [5] "sb5_v1 is only missing values" "sb6_v1 is only missing values"
# [7] "sb8_v1 is only missing values" "sb9_v1 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'SB1_V1', 'SB2_V1', 'SB3_V1', 'SB4_V1', 'SB5_V1', 'SB6_V1', 'SB7_V1',
  'SB7_V1A', 'SB7_V1B', 'SB7_V1C', 'SB7_V1D', 'SB7_V1E', 'SB7_V1F',
  'SB7_V1G', 'SB8_V1', 'SB9_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

 # [1] "sb_1"  "sb_2"  "sb_3"  "sb_4"  "sb_5"  "sb_6"  "sb_7"  "sb_7a"
 # [9] "sb_7b" "sb_7c" "sb_7d" "sb_7e" "sb_7f" "sb_7g" "sb_8"  "sb_9" 
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "sb_1" in both REDCap and QDS corresponded to the item "Have you ever had any kind of sex, including vaginal, anal, or oral?"). We identified the REDCap variables that contained a different naming convention.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "          
# [2] "In source  v2 : "         
# [3] "In source  v3 : "          
# [4] "In source  v4 : "          
# [5] "In source  v5 : "          
# [6] "In source  redcap : sb7_v1___1, sb7_v1___2, sb7_v1___3, sb7_v1___4, 
# sb7_v1___5, sb7_v1___6, sb7_v1___7"
```

We created our source maps, including necessary point-fixes.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'sb_7_1' ~'sb_7a',
      variable == 'sb_7_2' ~'sb_7b',
      variable == 'sb_7_3' ~'sb_7c',
      variable == 'sb_7_4' ~'sb_7d',
      variable == 'sb_7_5' ~'sb_7e',
      variable == 'sb_7_6' ~'sb_7f',
      variable == 'sb_7_7' ~'sb_7g',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Sexual Behaviors', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('sex_beh' = inst_map))

rm(inst_map)
```

### Joining Section

We purged the placeholder from our section-wise list of instruments, and joined our section map.

```{r}
sec_instruments <- sec_instruments[names(sec_instruments) != "placeholder"]

sec_map <- vm_join_inst_section(
  'Health', sec_instruments
  )

sec_map
```

We added the section to our overall list of sections, and purged the section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('health' = sec_map))

rm(sec_map)
```

## Stress

The section of Stress contained 6 instruments: Detroit Area Study Assessment of Day-to-Day Discrimination, MacArthur Major Discrimination, Urban Life Stress Scale, Personal Victimization, Perceived Stress Scale, and Distress Tolerance Scale.

We initiated an empty list of the instruments for this section, which we would build in order.
This placeholder would be removed prior to utilizing the list, but was named for easier removal.

```{r}
sec_instruments <- list("placeholder" = c())
```

### Detroit Area Study Assessment of Day-to-Day Discrimination

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "DD"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

 # [1] "DD1_V1"      "DD2_V1"      "DD3_V1"      "DD4_V1"     
 # [5] "DD5_V1"      "DD6_V1"      "DD7_V1"      "DD8_V1"     
 # [9] "DD9_V1"      "DD10_V1"     "DD_V1_total"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables `DD_V1_total`, `DD_V3_total`, `DD_V4_total` and `DD_V5_total` were SPSS calculated variables.
We dropped our SPSS calculated variables from all data sets.

```{r}
dropping[['v1']] <- c(dropping[['v1']], 'DD_V1_total')
dropping[['v3']] <- c(dropping[['v3']], 'DD_V3_total')
dropping[['v4']] <- c(dropping[['v4']], 'DD_V4_total')
dropping[['v5']] <- c(dropping[['v5']], 'DD_V5_total')
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "dd1_v1"  "dd2_v1"  "dd3_v1"  "dd4_v1"  "dd5_v1"  "dd6_v1" 
 # [7] "dd7_v1"  "dd8_v1"  "dd9_v1"  "dd10_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'DD1_V1', 'DD2_V1', 'DD3_V1', 'DD4_V1', 'DD5_V1', 'DD6_V1', 
  'DD7_V1', 'DD8_V1', 'DD9_V1', 'DD10_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars

 # [1] "dd_1"  "dd_2"  "dd_3"  "dd_4"  "dd_5"  "dd_6"  "dd_7"  "dd_8" 
 # [9] "dd_9"  "dd_10"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "dd_1" in both REDCap and QDS corresponded to the item "In your day-to-day life how often are you treated with less courtesy than other people because of your race, ethnicity, gender, age, religion, physical appearance, sexual orientation, homelessness status, or other characteristics?"). 

We only found the previously identified SPSS variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : DD_V1_total" "In source  v2 : "           
# [3] "In source  v3 : DD_V3_total" "In source  v4 : DD_V4_total"
# [5] "In source  v5 : DD_V5_total" "In source  redcap : " 
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Detroit Area Study Assessment of Day-to-Day Discrimination',
  desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('ddd' = inst_map))

rm(inst_map)
```

### MacAurthur Major Discrimination

We identified our keys and identified the matching variables in the QDS Visit 2 set. MacAurthur Major Discrimination was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "MMD"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

#  [1] "MMD1A"     "MMD1B"     "MMD1C"     "MMD1D"     "MMD1E"    
#  [6] "MMD1F"     "MMD1G"     "MMD1H"     "MMD1I"     "MMD1J"    
# [11] "MMD1K"     "MMD2"      "MMD3"      "MMD4"      "MMD_total"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variable `MMD_total` was an SPSS calculated variable only present in Visit 2 that we wished to drop.

```{r}
dropping[['v2']] <- c(dropping[['v2']], 'MMD_total')
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "mmd1a" "mmd1b" "mmd1c" "mmd1d" "mmd1e" "mmd1f" "mmd1g" "mmd1h"
 # [9] "mmd1i" "mmd1j" "mmd1k" "mmd2"  "mmd3"  "mmd4"
```

We checked to see if any of these variables were only missing values in the REDCap. We found that all 14 of our variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

#  [1] "mmd1a is only missing values" "mmd1b is only missing values"
#  [3] "mmd1c is only missing values" "mmd1d is only missing values"
#  [5] "mmd1e is only missing values" "mmd1f is only missing values"
#  [7] "mmd1g is only missing values" "mmd1h is only missing values"
#  [9] "mmd1i is only missing values" "mmd1j is only missing values"
# [11] "mmd1k is only missing values" "mmd2 is only missing values" 
# [13] "mmd3 is only missing values"  "mmd4 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'MMD1A', 'MMD1B', 'MMD1C', 'MMD1D', 'MMD1E', 'MMD1F', 'MMD1G', 
  'MMD1H', 'MMD1I', 'MMD1J', 'MMD1K', 'MMD2', 'MMD3', 'MMD4'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars

 # [1] "mmd_1a" "mmd_1b" "mmd_1c" "mmd_1d" "mmd_1e" "mmd_1f" "mmd_1g"
 # [8] "mmd_1h" "mmd_1i" "mmd_1j" "mmd_1k" "mmd_2"  "mmd_3"  "mmd_4" 
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "mmd_1a" in both REDCap and QDS corresponded to the item "You were discouraged by a teacher or advisor from seeking higher education?"). 

We only found the previously identified SPSS variable.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "          "In source  v2 : MMD_total"
# [3] "In source  v3 : "          "In source  v4 : "         
# [5] "In source  v5 : "          "In source  redcap : "
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'MacAurthur Major Discrimination', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('maca_md' = inst_map))

rm(inst_map)
```

### Urban Life Stress Scale

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The Urban Life Stress Scale was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "ULS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

#  [1] "ULS1_V2"      "ULS2_V2"      "ULS3_V2"      "ULS4_V2"     
#  [5] "ULS5_V2"      "ULS6_V2"      "ULS7_V2"      "ULS8_V2"     
#  [9] "ULS9_V2"      "ULS10_V2"     "ULS11_V2"     "ULS12_V2"    
# [13] "ULS13_V2"     "ULS14_V2"     "ULS15_V2"     "ULS16_V2"    
# [17] "ULS17_V2"     "ULS18_V2"     "ULS19_V2"     "ULS20_V2"    
# [21] "ULS21_V2"     "uls_V2_total"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.
missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables `uls_V2_total`, `uls_V3_total`, `uls_V4_total`, and `uls_V5_total` were SPSS calculated variables that we wished to drop.

```{r}
dropping[['v2']] <- c(dropping[['v2']], 'uls_V2_total')
dropping[['v3']] <- c(dropping[['v3']], 'uls_V3_total')
dropping[['v4']] <- c(dropping[['v4']], 'uls_V4_total')
dropping[['v5']] <- c(dropping[['v5']], 'uls_V5_total')
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "uls1_v2"  "uls2_v2"  "uls3_v2"  "uls4_v2"  "uls5_v2"  "uls6_v2" 
#  [7] "uls7_v2"  "uls8_v2"  "uls9_v2"  "uls10_v2" "uls11_v2" "uls12_v2"
# [13] "uls13_v2" "uls14_v2" "uls15_v2" "uls16_v2" "uls17_v2" "uls18_v2"
# [19] "uls19_v2" "uls20_v2" "uls21_v2"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'ULS1_V2', 'ULS2_V2', 'ULS3_V2', 'ULS4_V2', 'ULS5_V2', 'ULS6_V2',
  'ULS7_V2', 'ULS8_V2', 'ULS9_V2', 'ULS10_V2', 'ULS11_V2', 'ULS12_V2',
  'ULS13_V2', 'ULS14_V2', 'ULS15_V2', 'ULS16_V2', 'ULS17_V2', 'ULS18_V2',
  'ULS19_V2', 'ULS20_V2', 'ULS21_V2'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars
#  [1] "uls_1"  "uls_2"  "uls_3"  "uls_4"  "uls_5"  "uls_6"  "uls_7" 
#  [8] "uls_8"  "uls_9"  "uls_10" "uls_11" "uls_12" "uls_13" "uls_14"
# [15] "uls_15" "uls_16" "uls_17" "uls_18" "uls_19" "uls_20" "uls_21"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "uls_1" in both REDCap and QDS corresponded to the item "How much stress do you generally experience related to money or finances?"). 
We only found the previously identified SPSS calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "             "In source  v2 : uls_V2_total"
# [3] "In source  v3 : uls_V3_total" "In source  v4 : uls_V4_total"
# [5] "In source  v5 : uls_V5_total" "In source  redcap : "
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Urban Life Stress Scale', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('uls' = inst_map))

rm(inst_map)
```

### Personal Victimization

We identified our keys and identified the matching variables in the QDS Visit 2 set.
Personal Victimization was not used in Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "PV"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

# [1] "PV1_V2" "PV2_V2" "PV3_V2"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 
```

We checked to see if any of these variables were only missing values in the REDCap. We found that 26 of our 44 variables only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

We received a warning that all three variables escaped our standardization function.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'PV1_V2', 'PV2_V2', 'PV3_V2'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: PV1_V2, 
# PV2_V2, PV3_V2
# [1] "PV1_V2" "PV2_V2" "PV3_V2"
```

We manually set our desired standardization.

```{r}
desired_vars <- c('pv_1', 'pv_2', 'pv_3')
desired_vars
# [1] "pv_1" "pv_2" "pv_3"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "pv_1" in both REDCap and QDS corresponded to the item "In the past 30 days, has anyone used violence, such as in a mugging, fight, or sexual assault, against you?"). 
We found that all data sets would escape our standardization function.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: PV1_V2, PV2_V2, 
# PV3_V2
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: PV1_V3, PV2_V3
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: PV1_V4, PV2_V4
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: PV1_V5, PV2_V5, 
# PV3_V5
# Warning: Warning: The following column name(s) could not be standardized 
# because it/they would have created a duplicate column name: pv1_v2, pv2_v2, 
# pv3_v2
# [1] "In source  v1 : "                          
# [2] "In source  v2 : PV1_V2, PV2_V2, PV3_V2"    
# [3] "In source  v3 : PV1_V3, PV2_V3"            
# [4] "In source  v4 : PV1_V4, PV2_V4"            
# [5] "In source  v5 : PV1_V5, PV2_V5, PV3_V5"    
# [6] "In source  redcap : pv1_v2, pv2_v2, pv3_v2"
```

We created our source maps, which required manual assignments for all variables.

```{r, warning=FALSE}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'PV1_V2' ~ 'pv_1',
        variable == 'PV2_V2' ~'pv_2',
        variable == 'PV3_V2' ~'pv_3',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'PV1_V3' ~ 'pv_1',
        variable == 'PV2_V3' ~'pv_2',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'PV1_V4' ~ 'pv_1',
        variable == 'PV2_V4' ~'pv_2',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'PV1_V5' ~ 'pv_1',
        variable == 'PV2_V5' ~'pv_2',
        variable == 'PV3_V5' ~'pv_3',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ) %>%
  mutate(variable = case_when(
        variable == 'pv1_v2' ~ 'pv_1',
        variable == 'pv2_v2' ~'pv_2',
        variable == 'pv3_v2' ~'pv_3',
        TRUE ~ variable
        )
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Personal Victimization', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('pers_vic' = inst_map))

rm(inst_map)
```

### Perceived Stress Scale

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The Perceived Stress Scale was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "PS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

# [1] "PS1_V2"      "PS2_V2"      "PS3_V2"      "PS4_V2"     
# [5] "PS2r_V2"     "PS3r_V2"     "PS_V2_total"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables containing '*total' and/or 'r*' were a SPSS calculated variables that we wished to drop.

```{r}
dropping[['v2']] <- c(
  dropping[['v2']], 'PS2r_V2', 'PS3r_V2', 'PS_V2_total'
  )
dropping[['v3']] <- c(
  dropping[['v3']], 'PS2r_V3', 'PS3r_V3', 'PS_V3_total'
  )
dropping[['v4']] <- c(
  dropping[['v4']], 'PS2r_V4', 'PS3r_V4', 'PS_V4_total'
  )
dropping[['v5']] <- c(
  dropping[['v5']], 'PS2r_V5', 'PS3r_V5', 'PS_V5_total'
  )
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 
# [1] "ps1_v2" "ps2_v2" "ps3_v2" "ps4_v2"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'PS1_V2', 'PS2_V2', 'PS3_V2', 'PS4_V2'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars
# [1] "ps_1" "ps_2" "ps_3" "ps_4"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "ps_1" in both REDCap and QDS corresponded to the item "In the last week, how often have you felt that you were unable to control the important things in your life?"). 
We only found the previously identified SPSS calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                             
# [2] "In source  v2 : PS2r_V2, PS3r_V2, PS_V2_total"
# [3] "In source  v3 : PS2r_V3, PS3r_V3, PS_V3_total"
# [4] "In source  v4 : PS2r_V4, PS3r_V4, PS_V4_total"
# [5] "In source  v5 : PS2r_V5, PS3r_V5, PS_V5_total"
# [6] "In source  redcap : " 
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Perceived Stress Scale', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('perc_stress' = inst_map))

rm(inst_map)
```

### Distress Tolerance Scale

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The Distress Tolerance Scale was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "DTS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

#  [1] "DTS1_V2"           "DTS2_V2"           "DTS3_V2"          
#  [4] "DTS4_V2"           "DTS5_V2"           "DTS6_V2"          
#  [7] "DTS7_V2"           "DTS8_V2"           "DTS9_V2"          
# [10] "DTS10_V2"          "DTS11_V2"          "DTS12_V2"         
# [13] "DTS13_V2"          "DTS14_V2"          "DTS15_V2"         
# [16] "DTS16_V2"          "DTS1r_V2"          "DTS2r_V2"         
# [19] "DTS3r_V2"          "DTS4r_V2"          "DTS5r_V2"         
# [22] "DTS6r_V2"          "DTS8r_V2"          "DTS9r_V2"         
# [25] "DTS10r_V2"         "DTS11r_V2"         "DTS12r_V2"        
# [28] "DTS13r_V2"         "DTS14r_V2"         "DTS15r_V2"        
# [31] "DTS16r_V2"         "DTS_tolerance_V2"  "DTS_absorption_V2"
# [34] "DTS_appraisal_V2"  "DTS_regulation_V2" "DTS_total_V2"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variable containing "r\_", "absorption", "tolerance", "appraisal", "regulation" and/or "total" were SPSS calculated variables only present in QDS Visit 2 that we wished to drop.

```{r}
dropping[['v2']] <- c(
  dropping[['v2']], 'DTS1r_V2', 'DTS2r_V2', 'DTS3r_V2', 'DTS4r_V2',
  'DTS5r_V2', 'DTS6r_V2', 'DTS8r_V2', 'DTS9r_V2', 'DTS10r_V2', 'DTS11r_V2',
  'DTS12r_V2', 'DTS13r_V2', 'DTS14r_V2', 'DTS15r_V2', 'DTS16r_V2',
  'DTS_tolerance_V2', 'DTS_absorption_V2', 'DTS_appraisal_V2',
  'DTS_regulation_V2', 'DTS_total_V2'
  )
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "dts1_v2"  "dts2_v2"  "dts3_v2"  "dts4_v2"  "dts5_v2"  "dts6_v2" 
#  [7] "dts7_v2"  "dts8_v2"  "dts9_v2"  "dts10_v2" "dts11_v2" "dts12_v2"
# [13] "dts13_v2" "dts14_v2" "dts15_v2" "dts16_v2"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'DTS1_V2', 'DTS2_V2', 'DTS3_V2', 'DTS4_V2', 'DTS5_V2', 'DTS6_V2',
  'DTS7_V2', 'DTS8_V2', 'DTS9_V2', 'DTS10_V2', 'DTS11_V2', 'DTS12_V2',
  'DTS13_V2', 'DTS14_V2', 'DTS15_V2', 'DTS16_V2'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars
#  [1] "dts_1"  "dts_2"  "dts_3"  "dts_4"  "dts_5"  "dts_6"  "dts_7" 
#  [8] "dts_8"  "dts_9"  "dts_10" "dts_11" "dts_12" "dts_13" "dts_14"
# [15] "dts_15" "dts_16"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "dts_1" in both REDCap and QDS corresponded to the item "Feeling distressed or upset is unbearable to me."). 
We only found the previously identified SPSS calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "             
# [2] "In source  v2 : DTS1r_V2, DTS2r_V2, DTS3r_V2, DTS4r_V2, DTS5r_V2, 
# DTS6r_V2, DTS8r_V2, DTS9r_V2, DTS10r_V2, DTS11r_V2, DTS12r_V2, DTS13r_V2, 
# DTS14r_V2, DTS15r_V2, DTS16r_V2, DTS_tolerance_V2, DTS_absorption_V2, 
# DTS_appraisal_V2, DTS_regulation_V2, DTS_total_V2"
# [3] "In source  v3 : "           
# [4] "In source  v4 : "           
# [5] "In source  v5 : "         
# [6] "In source  redcap : " 
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Distress Tolerance Scale', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('dts' = inst_map))

rm(inst_map)
```

### Joining Section

We purged the placeholder from our section-wise list of instruments, and joined our section map.

```{r}
sec_instruments <- sec_instruments[names(sec_instruments) != "placeholder"]

sec_map <- vm_join_inst_section(
  'Stress', sec_instruments
  )

sec_map
```

We added the section to our overall list of sections, and purged the section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('stress' = sec_map))

rm(sec_map)
```

## Negative Affect

The section of Negative Affect contained 2 instruments: Aggression Questionnaire (AQ-12) and Center for Epidemiological Studies Depression (CES-D).

We initiated an empty list of the instruments for this section, which we would build in order.
This placeholder would be removed prior to utilizing the list, but was named for easier removal.

```{r}
sec_instruments <- list("placeholder" = c())
```

### Aggression Questionnaire (AQ-12)

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "AQ"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "AQ1_V1"  "AQ2_V1"  "AQ3_V1"  "AQ4_V1"  "AQ5_V1"  "AQ6_V1" 
#  [7] "AQ7_V1"  "AQ8_V1"  "AQ9_V1"  "AQ10_V1" "AQ11_V1" "AQ12_V1"
# [13] "AQ"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables `AQ`, `AQ_V3`, `AQ_V4`, and `AQ_V5` were SPSS calculated variables that we wished to drop.

```{r}
dropping[['v1']] <- c(dropping[['v1']], 'AQ')
dropping[['v3']] <- c(dropping[['v3']], 'AQ_V3')
dropping[['v4']] <- c(dropping[['v4']], 'AQ_V4')
dropping[['v5']] <- c(dropping[['v5']], 'AQ_V5')
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "aq1_v1"  "aq2_v1"  "aq3_v1"  "aq4_v1"  "aq5_v1"  "aq6_v1" 
 # [7] "aq7_v1"  "aq8_v1"  "aq9_v1"  "aq10_v1" "aq11_v1" "aq12_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'AQ1_V1', 'AQ2_V1', 'AQ3_V1', 'AQ4_V1', 'AQ5_V1', 'AQ6_V1', 'AQ7_V1',
  'AQ8_V1', 'AQ9_V1', 'AQ10_V1', 'AQ11_V1', 'AQ12_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars
 # [1] "aq_1"  "aq_2"  "aq_3"  "aq_4"  "aq_5"  "aq_6"  "aq_7"  "aq_8" 
 # [9] "aq_9"  "aq_10" "aq_11" "aq_12"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "aq_1" in both REDCap and QDS corresponded to the item "Given enough provocation, I may hit another person."). 
We only found the previously identified SPSS calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : AQ"    "In source  v2 : "     
# [3] "In source  v3 : AQ_V3" "In source  v4 : AQ_V4"
# [5] "In source  v5 : AQ_V5" "In source  redcap : "
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Aggression Questionnaire (AQ-12)', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('aq' = inst_map))

rm(inst_map)
```

### Center for Epidemiological Studies Depression (CES-D)

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "CES"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "CES1_V1"                "CES2_V1"               
#  [3] "CES3_V1"                "CES4_V1"               
#  [5] "CES5_V1"                "CES6_V1"               
#  [7] "CES7_V1"                "CES8_V1"               
#  [9] "CES9_V1"                "CES10_V1"              
# [11] "CES5_V1r"               "CES8_V1r"              
# [13] "CES_V1_total"           "CES_V1_total_labelled" 
# [15] "CES1_V1_dichot"         "CES2_V1_dichot"        
# [17] "CES3_V1_dichot"         "CES4_V1_dichot"        
# [19] "CES5_V1r_dichot"        "CES6_V1_dichot"        
# [21] "CES7_V1_dichot"         "CES8_V1r_dichot"       
# [23] "CES9_V1_dichot"         "CES10_V1_dichot"       
# [25] "CES_V1_dichot_total"    "CES_V1_dichot_labelled"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables containing "dichot", "total", or "r" were SPSS calculated variables we wished to drop.

```{r}
dropping[['v1']] <- c(
  dropping[['v1']], 'CES5_V1r', 'CES8_V1r', 'CES_V1_total',
  'CES_V1_total_labelled', 'CES1_V1_dichot', 'CES2_V1_dichot',
  'CES3_V1_dichot', 'CES4_V1_dichot', 'CES5_V1r_dichot', 'CES6_V1_dichot',
  'CES7_V1_dichot', 'CES8_V1r_dichot', 'CES9_V1_dichot', 'CES10_V1_dichot',
  'CES_V1_dichot_total', 'CES_V1_dichot_labelled'
  )

dropping[['v3']] <- c(
  dropping[['v3']], 'CES5_V3r', 'CES8_V3r', 'CES_V3_total',
  'CES_V3_total_labelled', 'CES1_V3_dichot', 'CES2_V3_dichot',
  'CES3_V3_dichot', 'CES4_V3_dichot', 'CES5_V3r_dichot', 'CES6_V3_dichot',
  'CES7_V3_dichot', 'CES8_V3r_dichot', 'CES9_V3_dichot', 'CES10_V3_dichot',
  'CES_V3_dichot_total', 'CES_V3_dichot_labelled'
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'CES5_V4r', 'CES8_V4r', 'CES_V4_total',
  'CES_V4_total_labelled', 'CES1_V4_dichot', 'CES2_V4_dichot',
  'CES3_V4_dichot', 'CES4_V4_dichot', 'CES5_V4r_dichot', 'CES6_V4_dichot',
  'CES7_V4_dichot', 'CES8_V4r_dichot', 'CES9_V4_dichot', 'CES10_V4_dichot',
  'CES_V4_dichot_total', 'CES_V4_dichot_labelled'
  )

dropping[['v5']] <- c(
  dropping[['v5']], 'CES5_V5r', 'CES8_V5r', 'CES_V5_total',
  'CES_V5_total_labelled', 'CES1_V5_dichot', 'CES2_V5_dichot',
  'CES3_V5_dichot', 'CES4_V5_dichot', 'CES5_V5r_dichot', 'CES6_V5_dichot',
  'CES7_V5_dichot', 'CES8_V5r_dichot', 'CES9_V5_dichot', 'CES10_V5_dichot',
  'CES_V5_dichot_total', 'CES_V5_dichot_labelled'
  )
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "ces1_v1"  "ces2_v1"  "ces3_v1"  "ces4_v1"  "ces5_v1"  "ces6_v1" 
 # [7] "ces7_v1"  "ces8_v1"  "ces9_v1"  "ces10_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'CES1_V1', 'CES2_V1', 'CES3_V1', 'CES4_V1', 'CES5_V1', 'CES6_V1',
  'CES7_V1', 'CES8_V1', 'CES9_V1', 'CES10_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars
 # [1] "ces_1"  "ces_2"  "ces_3"  "ces_4"  "ces_5"  "ces_6"  "ces_7" 
 # [8] "ces_8"  "ces_9"  "ces_10"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "ces_1" in both REDCap and QDS corresponded to the item "During the past week, I was bothered by things that don't usually bother me."). 
We only found the previously identified SPSS calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : CES5_V1r, CES8_V1r, CES_V1_total, 
# CES_V1_total_labelled, CES1_V1_dichot, CES2_V1_dichot, CES3_V1_dichot, 
# CES4_V1_dichot, CES5_V1r_dichot, CES6_V1_dichot, CES7_V1_dichot, 
# CES8_V1r_dichot, CES9_V1_dichot, CES10_V1_dichot, CES_V1_dichot_total, 
# CES_V1_dichot_labelled"
# [2] "In source  v2 : "                                    
# [3] "In source  v3 : CES5_V3r, CES8_V3r, CES_V3_total, 
# CES_V3_total_labelled, CES1_V3_dichot, CES2_V3_dichot, CES3_V3_dichot, 
# CES4_V3_dichot, CES5_V3r_dichot, CES6_V3_dichot, CES7_V3_dichot, 
# CES8_V3r_dichot, CES9_V3_dichot, CES10_V3_dichot, CES_V3_dichot_total, 
# CES_V3_dichot_labelled"
# [4] "In source  v4 : CES5_V4r, CES8_V4r, CES_V4_total, 
# CES_V4_total_labelled, CES1_V4_dichot, CES2_V4_dichot, CES3_V4_dichot, 
# CES4_V4_dichot, CES5_V4r_dichot, CES6_V4_dichot, CES7_V4_dichot, 
# CES8_V4r_dichot, CES9_V4_dichot, CES10_V4_dichot, CES_V4_dichot_total, 
# CES_V4_dichot_labelled"
# [5] "In source  v5 : CES5_V5r, CES8_V5r, CES_V5_total, 
# CES_V5_total_labelled, CES1_V5_dichot, CES2_V5_dichot, CES3_V5_dichot, 
# CES4_V5_dichot, CES5_V5r_dichot, CES6_V5_dichot, CES7_V5_dichot, 
# CES8_V5r_dichot, CES9_V5_dichot, CES10_V5_dichot, CES_V5_dichot_total, 
# CES_V5_dichot_labelled"
# [6] "In source  redcap : "  
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Center for Epidemiological Studies Depression (CES-D)', 
  desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('cesd' = inst_map))

rm(inst_map)
```

### Joining Section

We purged the placeholder from our section-wise list of instruments, and joined our section map.

```{r}
sec_instruments <- sec_instruments[names(sec_instruments) != "placeholder"]

sec_map <- vm_join_inst_section(
  'Negative Affect', sec_instruments
  )

sec_map
```

We added the section to our overall list of sections, and purged the section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('neg_affect' = sec_map))

rm(sec_map)
```

## Interpersonal/Intrapersonal Resources

The section of Interpersonal/Intrapersonal Resources contained 6 instruments: Interpersonal Support Evaluation List, Religious Participation, Lubben Social Network Scale 6, Homeless Timeline Follow Back (TLFB), Resource Utilization Questionnaire, Barriers to Phone Based Case Management.

We initiated an empty list of the instruments for this section, which we would build in order.
This placeholder would be removed prior to utilizing the list, but was named for easier removal.

```{r}
sec_instruments <- list("placeholder" = c())
```

### Interpersonal Support Evaluation List

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "IS"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "IS1_V1"    "IS2_V1"    "IS3_V1"    "IS4_V1"    "IS5_V1"   
#  [6] "IS6_V1"    "IS7_V1"    "IS8_V1"    "IS9_V1"    "IS10_V1"  
# [11] "IS11_V1"   "IS12_V1"   "IS1_V1r"   "IS2_V1r"   "IS7_V1r"  
# [16] "IS8_V1r"   "IS11_V1r"  "IS12_V1r"  "ISEapp_V1" "ISEbel_V1"
# [21] "ISEtan_V1"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables containing "r", "app", "bel", and/or "tan" were an SPSS calculated variables that we wished to drop.

```{r}
dropping[['v1']] <- c(
  dropping[['v1']], 'IS1_V1r', 'IS2_V1r', 'IS7_V1r', 'IS8_V1r', 
  'IS11_V1r', 'IS12_V1r', 'ISEapp_V1', 'ISEbel_V1', 'ISEtan_V1'
  )

dropping[['v3']] <- c(
  dropping[['v3']], 'IS1_V3r', 'IS2_V3r', 'IS7_V3r', 'IS8_V3r', 
  'IS11_V3r', 'IS12_V3r', 'ISEapp_V3', 'ISEbel_V3', 'ISEtan_V3'
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'IS1_V4r', 'IS2_V4r', 'IS7_V4r', 'IS8_V4r', 
  'IS11_V4r', 'IS12_V4r', 'ISEapp_V4', 'ISEbel_V4', 'ISEtan_V4'
  )

dropping[['v5']] <- c(
  dropping[['v5']], 'IS1_V5r', 'IS2_V5r', 'IS7_V5r', 'IS8_V5r', 
  'IS11_V5r', 'IS12_V5r', 'ISEapp_V5', 'ISEbel_V5', 'ISEtan_V5'
  )
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "is1_v1"  "is2_v1"  "is3_v1"  "is4_v1"  "is5_v1"  "is6_v1" 
 # [7] "is7_v1"  "is8_v1"  "is9_v1"  "is10_v1" "is11_v1" "is12_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'IS1_V1', 'IS2_V1', 'IS3_V1', 'IS4_V1', 'IS5_V1', 'IS6_V1', 'IS7_V1',
  'IS8_V1', 'IS9_V1', 'IS10_V1', 'IS11_V1', 'IS12_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars
 # [1] "is_1"  "is_2"  "is_3"  "is_4"  "is_5"  "is_6"  "is_7"  "is_8" 
 # [9] "is_9"  "is_10" "is_11" "is_12"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "is_1" in both REDCap and QDS corresponded to the item "If I wanted to go on a trip for a day (for example, to the country or mountains), I would have a hard time finding someone to go with me."). 
We only found the previously identified SPSS calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : IS1_V1r, IS2_V1r, IS7_V1r, IS8_V1r, IS11_V1r, 
# IS12_V1r, ISEapp_V1, ISEbel_V1, ISEtan_V1"
# [2] "In source  v2 : "                                   
# [3] "In source  v3 : IS1_V3r, IS2_V3r, IS7_V3r, IS8_V3r, IS11_V3r, 
# IS12_V3r, ISEapp_V3, ISEbel_V3, ISEtan_V3"
# [4] "In source  v4 : IS1_V4r, IS2_V4r, IS7_V4r, IS8_V4r, IS11_V4r, 
# IS12_V4r, ISEapp_V4, ISEbel_V4, ISEtan_V4"
# [5] "In source  v5 : IS1_V5r, IS2_V5r, IS7_V5r, IS8_V5r, IS11_V5r, 
# IS12_V5r, ISEapp_V5, ISEbel_V5, ISEtan_V5"
# [6] "In source  redcap : "   
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Interpersonal Support Evaluation List', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('interp_eval' = inst_map))

rm(inst_map)
```

### Religious Participation

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "RP"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "RP1_V1" "RP2_V1"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "rp1_v1" "rp2_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'RP1_V1', 'RP2_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars
# [1] "rp_1" "rp_2"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "rp_1" in both REDCap and QDS corresponded to the item "Apart from special occasions such as weddings and funerals, how often do you attend religious services?"). 

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Religious Participation', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('rp' = inst_map))

rm(inst_map)
```

### Lubben Social Network Scale 6

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "LSN"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

# [1] "LSN1_V1"        "LSN2_V1"        "LSN3_V1"        "LSN4_V1"       
# [5] "LSN5_V1"        "LSN6_V1"        "LSN_V1_family"  "LSN_V1_friends"
# [9] "LSN_V1_total"  
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

In manual inspection of the variables, we identified that the variables containing "family", "friends" and/or "total" were SPSS calculated variables that we wished to drop.

```{r}
dropping[['v1']] <- c(
  dropping[['v1']], 'LSN_V1_family', "LSN_V1_friends", "LSN_V1_total"
  )

dropping[['v3']] <- c(
  dropping[['v3']], 'LSN_V3_family', "LSN_V3_friends", "LSN_V3_total"
  )

dropping[['v4']] <- c(
  dropping[['v4']], 'LSN_V4_family', "LSN_V4_friends", "LSN_V4_total"
  )

dropping[['v5']] <- c(
  dropping[['v5']], 'LSN_V5_family', "LSN_V5_friends", "LSN_V5_total"
  )
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 
# [1] "lsn1_v1" "lsn2_v1" "lsn3_v1" "lsn4_v1" "lsn5_v1" "lsn6_v1"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'LSN1_V1', 'LSN2_V1', 'LSN3_V1', 'LSN4_V1', 'LSN5_V1', 'LSN6_V1'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars
# [1] "lsn_1" "lsn_2" "lsn_3" "lsn_4" "lsn_5" "lsn_6"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "lsn_1" in both REDCap and QDS corresponded to the item "Considering the people to who you are related by birth, marriage, adoption etc, how many relatives do you see or hear from at least once a month?"). 
We only found the previously identified SPSS calculated variables.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : LSN_V1_family, LSN_V1_friends, LSN_V1_total"
# [2] "In source  v2 : "                                           
# [3] "In source  v3 : LSN_V3_family, LSN_V3_friends, LSN_V3_total"
# [4] "In source  v4 : LSN_V4_family, LSN_V4_friends, LSN_V4_total"
# [5] "In source  v5 : LSN_V5_family, LSN_V5_friends, LSN_V5_total"
# [6] "In source  redcap : "      
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Lubben Social Network Scale 6', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('lsn' = inst_map))

rm(inst_map)
```

### Homeless Timeline Follow Back (TLFB) 

The Homeless Timeline Follow Back (TLFB) was stored in the TLFB data set.

We identified the variables for the Homelessness section.

```{r}
tlfb_vars <- tlfb %>%
  select(all_of(contains(c(
      "HOMELESS"
      )))
    ) %>%
  names()

tlfb_vars
# [1] "Num_Days_Homeless"    "Per_Days_Homeless"    "Est_Days_Homeless_Yr"
# [4] "Avg_Days_Homeless_Wk"
```
We checked to see if any of these variables only contained missing values, and none did.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in tlfb_vars){
  if(sum(!is.na(tlfb[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
tlfb_vars <- tlfb %>%
  select(all_of(c(
    "Num_Days_Homeless", "Per_Days_Homeless", "Num_Days_Home",
    "Est_Days_Homeless_Yr", "Avg_Days_Homeless_Wk"
    ))
  ) %>%
  names()

desired_vars <- standardize_col_names(tlfb_vars)

desired_vars

# [1] "num_days_homeless"    "per_days_homeless"    "num_days_home"       
# [4] "est_days_homeless_yr" "avg_days_homeless_wk"
```

We created our source map. As this only composed a single source (thus named variables and desired variables would be in the same order), we manually created the tibble for brevity.

```{r}
source_maps <- tibble::tibble(
  'tlfb' = tlfb_vars,
  'variable' = desired_vars
)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Homeless Timeline Follow Back (TLFB)', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('homeless_tlfb' = inst_map))

rm(inst_map)
```

### Resource Utilization Questionnaire

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "R1", "R2", "R2", "R3", "R4", "R5", "R6", "R7", "R8", "R9", "R0"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

#  [1] "R1_V1"   "R10_V1"  "R11_V1"  "R11B_V1" "R12_V1"  "R13_V1" 
#  [7] "R14_V1"  "R15_V1"  "R15_V1A" "R15_V1B" "R15_V1C" "R15_V1D"
# [13] "R15_V1E" "R15_V1F" "R15_V1G" "R15_V1H" "R15_V1I" "R15_V1J"
# [19] "R15_V1K" "R15_V1L" "R15_V1M" "R15_V1N" "R15_V1O" "R2_V1"  
# [25] "R3_V1"   "R4_V1"   "R5_V1"   "R6_V1"   "R7_V1"   "R8_V1"  
# [31] "R9_V1" 
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "r1_v1"       "r11_v1"      "r11b_v1"     "r12_v1"     
#  [5] "r13_v1"      "r14_v1"      "r15_v1___1"  "r15_v1___2" 
#  [9] "r15_v1___3"  "r15_v1___4"  "r15_v1___5"  "r15_v1___6" 
# [13] "r15_v1___7"  "r15_v1___8"  "r15_v1___9"  "r15_v1___10"
# [17] "r15_v1___11" "r15_v1___12" "r15_v1___13" "r15_v1___14"
# [21] "r15_v1___15" "r2_v1"       "r3_v1"       "r4_v1"      
# [25] "r5_v1"       "r6_v1"       "r7_v1"       "r8_v1"      
# [29] "r9_v1"   
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'R1_V1', 'R2_V1', 'R3_V1', 'R4_V1', 'R5_V1', 'R6_V1', 'R7_V1', 'R8_V1',
  'R9_V1', 'R10_V1', 'R11_V1', 'R11B_V1', 'R12_V1', 'R13_V1', 'R14_V1',
  'R15_V1', 'R15_V1A', 'R15_V1B', 'R15_V1C', 'R15_V1D', 'R15_V1E',
  'R15_V1F', 'R15_V1G', 'R15_V1H', 'R15_V1I', 'R15_V1J', 'R15_V1K',
  'R15_V1L', 'R15_V1M', 'R15_V1N', 'R15_V1O'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars
#  [1] "r_1"   "r_2"   "r_3"   "r_4"   "r_5"   "r_6"   "r_7"   "r_8"  
#  [9] "r_9"   "r_10"  "r_11"  "r_11b" "r_12"  "r_13"  "r_14"  "r_15" 
# [17] "r_15a" "r_15b" "r_15c" "r_15d" "r_15e" "r_15f" "r_15g" "r_15h"
# [25] "r_15i" "r_15j" "r_15k" "r_15l" "r_15m" "r_15n" "r_15o"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "r_1" in both REDCap and QDS corresponded to the item "Over the past 30 days, how many days did you receive Mental Health/Behavioral Health Counseling at local shelters?"). We identified the REDCap variables with a different naming convention.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                                      
# [2] "In source  v2 : "                                
# [3] "In source  v3 : "                                 
# [4] "In source  v4 : "                                
# [5] "In source  v5 : "                                 
# [6] "In source  redcap : r15_v1___1, r15_v1___2, r15_v1___3, r15_v1___4, 
# r15_v1___5, r15_v1___6, r15_v1___7, r15_v1___8, r15_v1___9, r15_v1___10, 
# r15_v1___11, r15_v1___12, r15_v1___13, r15_v1___14, r15_v1___15"
```

We created our source maps, including the required point-modifications.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'r_15_1' ~ 'r_15a',
      variable == 'r_15_2' ~ 'r_15b',
      variable == 'r_15_3' ~ 'r_15c',
      variable == 'r_15_4' ~ 'r_15d',
      variable == 'r_15_5' ~ 'r_15e',
      variable == 'r_15_6' ~ 'r_15f',
      variable == 'r_15_7' ~ 'r_15g',
      variable == 'r_15_8' ~ 'r_15h',
      variable == 'r_15_9' ~ 'r_15i',
      variable == 'r_15_10' ~ 'r_15j',
      variable == 'r_15_11' ~ 'r_15k',
      variable == 'r_15_12' ~ 'r_15l',
      variable == 'r_15_13' ~ 'r_15m',
      variable == 'r_15_14' ~ 'r_15n',
      variable == 'r_15_15' ~ 'r_15o',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Resource Utilization Questionnaire', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('ruq' = inst_map))

rm(inst_map)
```

### Barriers to Phone Based Case Management

We identified our keys and identified the matching variables in the QDS Visit 1 set.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "BPM"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v1 <- v1 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v1

 # [1] "BPM1_V1"  "BPM2_V1"  "BPM3_V1"  "BPM4_V1"  "BPM5_V1"  "BPM5_V1A"
 # [7] "BPM5_V1B" "BPM5_V1C" "BPM5_V1D" "BPM5_V1E" "BPM5_V1F" "BPM5_V1G"
```

We checked to see if any of these variables were only missing values in QDS Visit 1, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v1){
  if(sum(!is.na(v1[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

 # [1] "bpm1_v1"     "bpm2_v1"     "bpm3_v1"     "bpm4_v1"    
 # [5] "bpm5_v1___0" "bpm5_v1___1" "bpm5_v1___2" "bpm5_v1___3"
 # [9] "bpm5_v1___4" "bpm5_v1___5" "bpm5_v1___6"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v1 <- v1 %>%
  select(all_of(c(
  'BPM1_V1', 'BPM2_V1', 'BPM3_V1', 'BPM4_V1', 'BPM5_V1', 'BPM5_V1A',
  'BPM5_V1B', 'BPM5_V1C', 'BPM5_V1D', 'BPM5_V1E', 'BPM5_V1F', 'BPM5_V1G'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v1)

desired_vars
 # [1] "bpm_1"  "bpm_2"  "bpm_3"  "bpm_4"  "bpm_5"  "bpm_5a" "bpm_5b"
 # [8] "bpm_5c" "bpm_5d" "bpm_5e" "bpm_5f" "bpm_5g"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "bpm_1" in both REDCap and QDS corresponded to the item "I am comfortable with completing case management sessions in my case manager’s office at the shelter."). We identified the REDCap variables that used a different naming convention.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "                     
# [2] "In source  v2 : "                    
# [3] "In source  v3 : "                     
# [4] "In source  v4 : "                  
# [5] "In source  v5 : "                   
# [6] "In source  redcap : bpm5_v1___0, bpm5_v1___1, bpm5_v1___2, bpm5_v1___3,
# bpm5_v1___4, bpm5_v1___5, bpm5_v1___6"
```

We created our source maps, including the required point-modifications.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'bpm_5_0' ~ 'bpm_5a',
      variable == 'bpm_5_1' ~ 'bpm_5b',
      variable == 'bpm_5_2' ~ 'bpm_5c',
      variable == 'bpm_5_3' ~ 'bpm_5d',
      variable == 'bpm_5_4' ~ 'bpm_5e',
      variable == 'bpm_5_5' ~ 'bpm_5f',
      variable == 'bpm_5_6' ~ 'bpm_5g',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Barriers to Phone Based Case Management', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('bar_pcm' = inst_map))

rm(inst_map)
```

### Joining Section

We purged the placeholder from our section-wise list of instruments, and joined our section map.

```{r}
sec_instruments <- sec_instruments[names(sec_instruments) != "placeholder"]

sec_map <- vm_join_inst_section(
  'Interpersonal/Intrapersonal Resources', sec_instruments
  )

sec_map
```

We added the section to our overall list of sections, and purged the section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('interpersonal' = sec_map))

rm(sec_map)
```

## Treatment Quality and Satisfaction

The section for Treatment Quality and Satisfaction contained only one instrument.

We identified our keys and identified the matching variables in the QDS Visit 3 set.
The Treatment Quality and Satisfaction Survey was not used in QDS Visits 1 or 2.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "TQ", "YQ"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v3 <- v3 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v3

#  [1] "TQ1_1V3"  "TQ2_1V3"  "TQ14_1V3" "TQ1_2V3"  "TQ2_2V3"  "TQ3_2V3" 
#  [7] "TQ4_2V3"  "TQ9_2V3"  "TQ10_2V3" "TQ12_2V3" "TQ13_2V3" "TQ14_2V3"
# [13] "TQ1_3V3"  "TQ2_3V3"  "TQ3_3V3"  "TQ4_3V3"  "TQ5_3V3"  "TQ6_3V3" 
# [19] "TQ7_3V3"  "TQ8_3V3"  "TQ9_3V3"  "TQ10_3V3" "TQ11_3V3" "TQ12_3V3"
# [25] "TQ13_3V3" "TQ14_3V3" "TQ15_3V3" "TQ16_3V3" "TQ17_3V3" "TQ18_3V3"
# [31] "YQ11_2V3"
```

We checked to see if any of these variables were only missing values in Visit 3, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v3){
  if(sum(!is.na(v3[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

#  [1] "tq1_1v3"  "tq2_1v3"  "tq14_1v3" "tq1_2v3"  "tq2_2v3"  "tq3_2v3" 
#  [7] "tq4_2v3"  "tq9_2v3"  "tq10_2v3" "tq11_2v3" "tq12_2v3" "tq13_2v3"
# [13] "tq14_2v3" "tq1_3v3"  "tq2_3v3"  "tq3_3v3"  "tq4_3v3"  "tq5_3v3" 
# [19] "tq6_3v3"  "tq7_3v3"  "tq8_3v3"  "tq9_3v3"  "tq10_3v3" "tq11_3v3"
# [25] "tq12_3v3" "tq13_3v3" "tq14_3v3"
```

We checked to see if any of these variables were only missing values in the REDCap, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v3 <- v3 %>%
  select(all_of(c(
  'TQ1_1V3', 'TQ2_1V3', 'TQ3_2V3', 'TQ4_2V3', 'TQ5_3V3', 'TQ6_3V3',
  'TQ7_3V3', 'TQ8_3V3', 'TQ9_2V3', 'TQ10_2V3', 'YQ11_2V3', 'TQ12_2V3',
  'TQ13_2V3', 'TQ14_1V3', 'TQ15_3V3', 'TQ16_3V3', 'TQ17_3V3', 'TQ18_3V3',
  'TQ14_2V3', 'TQ1_2V3', 'TQ2_2V3', 'TQ1_3V3', 'TQ2_3V3', 'TQ3_3V3',
  'TQ4_3V3', 'TQ9_3V3', 'TQ10_3V3', 'TQ11_3V3', 'TQ12_3V3', 'TQ13_3V3',
  'TQ14_3V3'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v3)

desired_vars

#  [1] "tq_1_1"  "tq_2_1"  "tq_3_2"  "tq_4_2"  "tq_5_3"  "tq_6_3" 
#  [7] "tq_7_3"  "tq_8_3"  "tq_9_2"  "tq_10_2" "yq_11_2" "tq_12_2"
# [13] "tq_13_2" "tq_14_1" "tq_15_3" "tq_16_3" "tq_17_3" "tq_18_3"
# [19] "tq_14_2" "tq_1_2"  "tq_2_2"  "tq_1_3"  "tq_2_3"  "tq_3_3" 
# [25] "tq_4_3"  "tq_9_3"  "tq_10_3" "tq_11_3" "tq_12_3" "tq_13_3"
# [31] "tq_14_3"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "tq_1_1" in both REDCap and QDS corresponded to the item "How helpful has the Bridge Homeless Recovery Program been to you?"). We identified that the REDCap data did not have the same spelling error ('yq' instead of 'tq') present in the QDS data.

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)

# [1] "In source  v1 : "             "In source  v2 : "            
# [3] "In source  v3 : "             "In source  v4 : "            
# [5] "In source  v5 : "             "In source  redcap : tq11_2v3"
```

We created our source maps, including the required point-modification.

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCap
  full_join(
    vm_make_source_map(
      source_list, dropping, 6, 'redcap', incl_keys, excl_keys
        ) %>%
    mutate(variable = case_when(
      variable == 'tq_11_2' ~ 'yq_11_2',
      TRUE ~ variable
      )
    ),
  by = "variable"
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'Treatment Quality and Satisfaction Survey', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

### Joining Section

As the Treatment Quality and Satisfaction section was a single instrument, we created our section.

```{r}
sec_map <- vm_join_inst_section(
  'Treatment Quality and Satisfaction', list(inst_map)
  )

sec_map
```

We added the section to our overall list, and purged the instrument & section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('treatment' = sec_map))
rm(inst_map)
rm(sec_map)
```

## Staff Perceptions of the Link2Care App 🔴 - PLACEHOLDER

Staff Perceptions of the Link2Care was not included in the QDS Data

## Ecological Momentary Assessment (EMA) Matrix 🔴 - PLACEHOLDER

The Ecological Momentary Assessment variables were not included in the QDS Data.

## COVID-19 Pandemic Related Data

The section of COVID-19 Pandemic Related Data contained 2 instruments: COVID-19 Vaccination Questionnaire, and the Pandemic Stress Index (PSI).

We initiated an empty list of the instruments for this section, which we would build in order.
This placeholder would be removed prior to utilizing the list, but was named for easier removal.

```{r}
sec_instruments <- list("placeholder" = c())
```

### COVID-19 Vaccination Questionnaire

We identified our keys and identified the matching variables in the QDS Visit 2 set.
The COVID-19 Vaccination Questionnaire was not used in QDS Visit 1.

```{r}
# Must be a "non-empty string", but no valid variable name is a single space
incl_keys <- list(
  'starts_with' = c(
    "VAC"
  ), 
  'contains' = c(" ")
  )

# Must be a "non-empty string", but no valid variable name is a single space
excl_keys <- list(
  'starts_with' = c(" "),
  'contains' = c(" "))


vars_v2 <- v2 %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

vars_v2

# [1] "VAC1_V2"  "VAC2_V2"  "VAC3_V2"  "VAC2_V2Y" "VAC2_V2M" "VAC2_V2D"
# [7] "VAC3_V2Y" "VAC3_V2M" "VAC3_V2D"
```

We checked to see if any of these variables were only missing values in QDS Visit 2, and none were.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in vars_v2){
  if(sum(!is.na(v2[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}
```

We identified the pertinent variables from the REDCap data set. 

```{r}
red_vars <- redcap %>%
    select(all_of(starts_with(incl_keys$starts_with)),
           all_of(contains(incl_keys$contains))
         ) %>%
    select(-c(
      all_of(starts_with(excl_keys$starts_with)),
      all_of(contains(excl_keys$contains))
      )
    ) %>%
  names()

red_vars 

# [1] "vac1" "vac2" "vac3"
```

We checked to see if any of these variables were only missing values in the REDCap. We found that `vac2` only contained missing values.

```{r}
# DATA CHECK: checking if variable only contains missing values.

missing_vars <- c()
message <- c()

for (var in red_vars){
  if(sum(!is.na(redcap[,var])) == 0){
    missing_vars <- c(missing_vars, var)
    message <- c(message, (paste(var, "is only missing values")))
  }
}
if (length(message)>0){
  print(message)
}

# [1] "vac2 is only missing values"
```

We set our initial desired order and standardization using the QDS variables. We utilized tidyselect to enable a warning/error message if the variable name changes after our initial processing, to facilitate updates.

```{r}
vars_v2 <- v2 %>%
  select(all_of(c(
  'VAC1_V2', 'VAC2_V2', 'VAC2_V2Y', 'VAC2_V2M', 'VAC2_V2D', 'VAC3_V2',
  'VAC3_V2Y', 'VAC3_V2M', 'VAC3_V2D'
      )
    )
  ) %>%
  names()

desired_vars <- standardize_col_names(vars_v2)

desired_vars
# [1] "vac_1"  "vac_2"  "vac_2y" "vac_2m" "vac_2d" "vac_3"  "vac_3y"
# [8] "vac_3m" "vac_3d"
```

We checked for any variables that would either standardize differently, or were not already identified. We manually verified that similar variables corresponded to the same question (i.e. "vac_1" in both REDCap and QDS corresponded to the item "Have you received the COVID-19 vaccine?"). 

```{r}
# DATA CHECK: Meant to have human-legible output. 

flagged_vars <- flag_unmatching_variables(source_list, desired_vars, 
                          incl_keys, excl_keys)
```

We created our source maps

```{r}
source_maps <- vm_make_source_map(
  source_list, dropping, 1, 'v1', incl_keys, excl_keys
  ) %>%
  # V2
  full_join(vm_make_source_map(
  source_list, dropping, 2, 'v2', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V3
  full_join(vm_make_source_map(
  source_list, dropping, 3, 'v3', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V4
  full_join(vm_make_source_map(
  source_list, dropping, 4, 'v4', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # V5
  full_join(vm_make_source_map(
  source_list, dropping, 5, 'v5', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # REDCAP
  full_join(vm_make_source_map(
  source_list, dropping, 6, 'redcap', incl_keys, excl_keys
      ), 
  by = 'variable'
  ) %>%
  # Move 'variable' key column to the beginning
  relocate(variable)

source_maps
```

We created the instrument map, placing our variables in the desired order.

```{r}
inst_map <- vm_create_for_instrument(
  'COVID-19 Vaccination Questionnaire', desired_vars
  ) %>%
  left_join(source_maps, 
            by = 'variable')

inst_map
```

We added the instrument to our section-wise list of instruments.
We purged the instrument map to reduce memory burden in processing.

```{r}
sec_instruments <- append(sec_instruments, list('covid_vax' = inst_map))

rm(inst_map)
```

### Pandemic Stress Index (PSI) 🔴 - PLACEHOLDER

### Joining Section

We purged the placeholder from our section-wise list of instruments, and joined our section map.

```{r}
sec_instruments <- sec_instruments[names(sec_instruments) != "placeholder"]

sec_map <- vm_join_inst_section(
  'COVID-19 Pandemic Related Data', sec_instruments
  )

sec_map
```

We added the section to our overall list of sections, and purged the section maps to reduce memory burden in processing.

```{r}
all_sections <- append(all_sections, list('covid' = sec_map))

rm(sec_map)
```

# Aggregation of Variable Map

We purged the placeholder from our list of sections, and joined our section map.

```{r}
all_sections <- all_sections[names(all_sections) != "placeholder"]

variable_map <- vm_join_sections(all_sections)
```

# Verifying Remaining Variables

We examined the 68 variables that had otherwise failed to be assigned from each data set. These variables were all determined to be either SPSS calculated variables, or entirely empty errant duplicates of variables, that we wished to recreate in R from our aggregated set.

```{r}
remaining_vars <- c()

for (i in 1:length(source_list)){
  source_vars <- colnames(source_list[[i]])
  source_name <- names(source_list)[[i]]
  
  source_remaining <- setdiff(
    setdiff(source_vars, na.omit(variable_map[[source_name]])),
    dropping[[source_name]]
  )
  
  remaining_vars <- unique(c(remaining_vars, source_remaining))
  
}

remaining_vars

#  [1] "BRIS2_QD_dichot"         "QD_unintent_slp"         "PA"                      "VA"                     
#  [5] "A"                       "HA"                      "AlcQF_V1"                "binge_drinker_V1"       
#  [9] "Heavy_drinker"           "current_months_homeless" "friends_smoke_V1"        "spouse_smoke"           
# [13] "Mental_Health_dx"        "pain"                    "Substance_abuse_hs"      "Substance_use_30d"      
# [17] "Any_health_insurance"    "Time_to_complete_V1"     "TCU_DS_TOTAL_V2"         "TCU_DS_SCORE_V2"        
# [21] "TCU_desire_v2_total"     "TCU_tn_v2_total"         "TCU_ts_v2_total"         "TCU_se_v2_total"        
# [25] "TCU_hs_v2_total"         "TCU_rt_v2_total"         "Time_to_complete_V2"     "BRIS2_V3_dichot"        
# [29] "unintent_slp_V3"         "AlcQF_V3"                "binge_drinker_V3"        "Heavy_drinker_V3"       
# [33] "PA_V3"                   "VA_V3"                   "A_V3"                    "HA_V3"                  
# [37] "Time_to_complete_V3"     "PHQ_dep_dichot_total_V4" "BRIS2_V4_dichot"         "unintent_slp_V4"        
# [41] "AlcQF_V4"                "binge_drinker_V4"        "Heavy_drinker_V4"        "TCU_desire_v4_total"    
# [45] "TCU_tn_v4_total"         "TCU_ts_V4_total"         "PA_V4"                   "VA_V4"                  
# [49] "A_V4"                    "HA_V4"                   "Time_to_complete_V4"     "PHQ_dep_dichot_total_V5"
# [53] "BRIS2_V5_dichot"         "unintent_slp_V5"         "AlcQF_V5"                "binge_drinker_V5"       
# [57] "Heavy_drinker_V5"        "PA_V5"                   "VA_V5"                   "A_V5"                   
# [61] "HA_V5"                   "Time_to_complete_V5"     "staffperc_q1"
```

As such, we added these variables to our list of variables to drop for each set.

```{r}
remaining_vars <- c()

for (i in 1:length(source_list)){
  source_vars <- colnames(source_list[[i]])
  source_name <- names(source_list)[[i]]
  
  source_remaining <- setdiff(
    setdiff(source_vars, na.omit(variable_map[[source_name]])),
    dropping[[source_name]]
  )
  
  dropping[[source_name]] <- unique(
    c(dropping[[source_name]], source_remaining)
  )
  
}

# Clean up in case of memory leak
rm(source_vars)
rm(source_name)
rm(source_remaining)
rm(i)
rm(remaining_vars)
```


# 💾 Saving the Variable Map

```{r}
variable_map_path <- here(
  "data", "Combined Participant Data", "variable_map.rds"
  )

write_rds(variable_map, variable_map_path)
```

# BOTTOM PLACEHOLDER 🔴
