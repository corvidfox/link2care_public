---
title: "Automated Quarterly Report"
date: "2021-05-10 <br> Updated: `r Sys.Date()`"
---

# 📝Instructions

1. Update the quarterly report template document: template_l2c_quarterly_report.docx.
  - Update the Quarter and date information on page 1.
  - Update the Quarter and date information in the header beginning on page 2.

2. Update file paths below, if necessary. 

```{r}
master_log_path <- "../../Live Documents/Master Log (version2).xlsx"
phone_term_path <- "../../Live Documents/Link2Care Phone Terminations.xlsx"
remote_path <- "../../Live Documents/L2C Remote Interview & Redcap Tracking.xlsx"
ema_initial_pay_approach_path <- "../../Live Documents/ema_data comparison.xlsx"
ema_15_day_path <- "../../Live Documents/15_Day_EMA.xlsx"
arrest_path <- "../../Participant Data/Arrest Data Requests/current_arrest_data.xlsx"
bridge_path <- "../../Participant Data/Bridge Session Data/bridge_session_minutes.xlsx"
```

3. Click "Run All Chunks Below" to create the quarterly report as a Word document. It will also create multiple other Word documents that contain tables of data. They are exported as separate Word documents because the coping the data and pasting into the appropriate table in the quarterly report is too easy to justify the effort of doing all of the table formatting in R code below.

These tables require a cut and paste of values:
  - Table 05: Reasons for phone terminations
  - Table 06: Number and percent of participants per L2C group 
  - Table 07: Number and percent of participants who completed visits 1 through 5
  - Table 08: COVID-19 phone, REDCap, and combination interviews
  - Table 10: Arrests by treatment arm 12 months after enrollment
  - Table 11: Number and percent of participants who used Bridge case management
  - Table 12: Number and duration of case management sessions used

# 📦Load packages

```{r message=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(readr, warn.conflicts = FALSE)
library(readxl, warn.conflicts = FALSE)
library(freqtables, warn.conflicts = FALSE)
library(meantables, warn.conflicts = FALSE)
library(stringr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(forcats, warn.conflicts = FALSE)
library(purrr, warn.conflicts = FALSE)
library(ggplot2, warn.conflicts = FALSE)
library(lubridate, warn.conflicts = FALSE)
library(officer, warn.conflicts = FALSE)
library(flextable, warn.conflicts = FALSE)
```

# Load helper functions

```{r}
source("../R/get_mean_sd.R")
source("../R/flextable_helpers.R")
source("../R/bridge_table_fns.R")
```


# 📥Import data 

## Master log Screened-in

```{r}
master_log_screened_in <- read_excel(
  master_log_path,
  # For testing
  # "/Users/bradcannell/Desktop/L2C_Master_Log.xlsm",
  sheet = "Screened In",
  col_names = c(
    "id", "status", "date_baseline", "date_dropped", "date_v2_scheduled", "date_v2_presented",
    "late_v2", "no_show_v2","days_v2_to_v3_scheduled","date_v3_scheduled", 
    "date_v3_presented", "late_v3", "no_show_v3", "days_v3_to_v4_scheduled", 
    "date_v4_scheduled", "date_v4_presented", "late_v4", "no_show_v4", 
    "days_4v_to_v5_scheduled", "date_v5_scheduled", "date_v5_presented", 
    "late_v5", "no_show_v5", "group", "v2_status", "dropped_status", "name_first",
    "name_middle_init",  "name_last", "gender", "race", "hispanic", "date_birth", 
    "age", "clincard_id", "n_clincards", "phone_id", "phone_number_l2c", 
    "phone_n_distributed", "care_manager", "v1", "v2", "v3", "v4", "v5", 
    "v3_r_distributed", "v3_r_completed", "v4_r_distributed", 
    "v4_r_completed","v5_r_distributed", "v5_r_completed", "v2_phone", "v3_phone",
    "v4_phone", "v5_phone"
  ),
  col_types = c(
    # Some of the dates must be imported as text because the have embedded 
    # notes (e.g., "no show")
    rep("text",2), rep("date", 4), rep("text", 2), "numeric", rep("date", 2),
    rep("text", 2), "numeric", rep("date", 2), rep("text", 2), "numeric", rep("date", 2), rep("text", 11),
    "date", "numeric", "text", "numeric", rep("text", 2), "numeric", "text", rep("text", 15)
    # They have some calculations in BD:BH of the the Excel sheet. I'm skipping
    # those so that the sheet can be read in without errors.
    # rep("skip", 5)
  ),
  na = c("", ".", "N/A", "No show", "No Show"),
  skip = 1
) %>% 
  filter(!is.na(id))

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Master log screened in imported with", nrow(master_log_screened_in), "rows and",
  ncol(master_log_screened_in),
  "columns.\n"
)

# 2022-12-04: Master log screened in imported with 442 rows and 55 columns.
```

## Master log Screened-out

```{r}
master_log_screened_out <- read_excel(
  master_log_path,
  # For testing
  # "/Users/bradcannell/Desktop/L2C_Master_Log.xlsm",
  sheet = "Screened Out",
  col_names = c(
    "id", "name_full", "date_baseline", "gender",  "race", "hispanic", 
    "date_birth", "age", "reason_1", "reason_2", "reason_3",  "reason_4", 
    "reason_5", "reason_6", "reason_7", "reason_8", "reason_9", "notes"
  ),
  col_types = c(
    "text", "text", "date", rep("text", 3), "date", "numeric", 
    rep("text", 9), "text", 
    # There is a "key" in column S. Will will not read that in to the data.
    "skip"
  ),
  skip = 1,
  na = c("", "N/A")
)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Master log screened out imported with", nrow(master_log_screened_out), 
  "rows and", ncol(master_log_screened_out),
  "columns.\n"
)

# 2023-03-15: Master log screened out imported with 68 rows and 18 columns.
```

## Phone terminations

```{r}
phone_terminations <- read_excel(
  phone_term_path, 
  sheet = "Terminations",
  col_names = c(
    "id", "group", "status", "v5_date", 
    "phone_1_id", "phone_1_num", "phone_1_active", "phone_1_activated_date", "phone_1_term_req_date", "phone_1_term_reason",
    "phone_2_id", "phone_2_num", "phone_2_active", "phone_2_activated_date", "phone_2_term_req_date", "phone_2_term_reason",
    "phone_3_id", "phone_3_num", "phone_3_active", "phone_3_activated_date", "phone_3_term_req_date", "phone_3_term_reason"
  ),
  col_types = c(
    rep("text", 3), "date", 
    rep("text", 3), rep("date", 2), "text",
    rep("text", 3), rep("date", 2), "text",
    rep("text", 3), rep("date", 2), "text"
  ),
  na = c("", "N/A"),
  skip = 1
)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Phone terminations imported with", nrow(phone_terminations), 
  "rows and", ncol(phone_terminations),
  "columns.\n"
)

# 2023-03-15: Phone terminations imported with 444 rows and 22 columns.
```

## Remote Interview & Redcap Tracking Sheet

```{r}
remote <- read_excel(
  remote_path, 
  sheet = "Log",
  col_names = c(
    "id", "group", "visit", "surface_pro", "interviewer", "mode", "date_visit", 
    "date_data_transfer", "notes"
  ),
  col_types = c(
    "numeric", "text", "numeric", rep("text", 3), rep("date", 2), "text"
  ),
  na = c("", "N/A", "."),
  skip = 3
)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Remote interview imported with", nrow(remote), 
  "rows and", ncol(remote),
  "columns.\n"
)

# 2023-03-15: Remote interview imported with 143 rows and 9 columns.
```

## EMA data

NOTES: Eventually, I may want to pull this data directly from Insight. Need to learn how to use Insight first.

```{r}
ema_initial_pay_approach <- read_excel(
  ema_initial_pay_approach_path,
  sheet = "Old EMA",
  range = "A2:N48",
  col_names = c(
    "id", "group", paste0("emas_completed_cycle_", 1:12)
  ),
  col_types = c(
    "text", "text", rep("numeric", 12)
  )
)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "EMA initial pay approach data imported with", nrow(ema_initial_pay_approach), 
  "rows and", ncol(ema_initial_pay_approach),
  "columns.\n"
)

# 2022-12-04: EMA initial pay approach data imported with 47 rows and 14 columns.
# This is not expected to change over time.
```

```{r}
# Create column names for use below when reading in the EMA data.
# Cycles 1 through 12 each have 6 variables with the same names.
ema_col_nms <- c(
  "date_complete", "contact", "initials", "locator_update", "emas_completed",
  "compensation"
)

ema_cycles <- paste("cycle", 1:12, sep = "_")

ema_col_nms <- paste(ema_col_nms, rep(ema_cycles, each = 6), sep = "_")
```

```{r warning=FALSE}
ema <- read_excel(
  ema_15_day_path,
  sheet = "15_Day_EMA_Log",
  col_names = c(
    "id", "name", "group", "date_randomization",
    # Cycles 1 through 12 each have 6 variables with the same names.
    ema_col_nms
  ),
  col_types = c(
    rep("text", 3), "date", 
    rep(c("date", "text", "text", "text", "numeric", "text"), 12),
    # There are some calculations in the spreadsheet to the right of the data
    # that we don't want to import.
    rep("skip", 6)
  ),
  na = c("", "N/A", "."),
  skip = 1
)

# Warnings for this chunk are silenced.
# There were two sources of the warnings. 
# First, there are warnings because some zeros are stored as text instead of 
# numbers in the Excel file. These are safe to ignore.
# Second, there is a warning that says, "datetimeWarning: NA inserted for 
# impossible 1900-02-29". It appears to be a warning about dates that are pre 
# 1900 (https://github.com/tidyverse/readxl/issues/551). 
# However, the warning doesn't tell us which cells are causing the warning. 
# I think the warnings are for the date_randomization column. Specifically, 
# there are some calculated columns in the Excel spreadsheet the are copied
# down past the last row with participant data. It looks like those are all
# being converted to NA. This is safe to ignore. Additionally, we need to 
# drop those rows from the data frame. 

ema <- filter(ema, !is.na(id))

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "EMA completion data imported with", nrow(ema), 
  "rows and", ncol(ema),
  "columns.\n"
)

# 2023-03-15: EMA completion data imported with 369 rows and 76 columns.
```

## Arrests

* Had to remove password from Excel sheet before import. Help -> Passwords -> Delete password.
* Had to do a little bit of manual removal of text from dates (i.e., "CURRENTLY IN CUSTODY") in the Excel file.

```{r}
arrest <- read_excel(
  arrest_path,
  sheet = "Sheet1",
  col_names = c(
    "id", "arrested", "date_baseline", paste("date", 1:12, sep = "_"), "n_arrests"
  ),
  col_types = c(
    "text", "text", rep("date", 13), "numeric"
  ),
  na = c("", "None"),
  skip = 1
)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Arrest data imported with", nrow(arrest), 
  "rows and", ncol(arrest),
  "columns.\n"
)

# 2023-03-15: Arrest data imported with 499 rows and 16 columns.
```

## Bridge Case Session Minutes

```{r}
bridge <- read_excel(
  bridge_path,
  sheet = "Sheet1",
  col_names = c(
    "id", "baseline_date", "v2_rand_date", "v5_sched_final_visit_date", 
    "date_session", "type", "duration", "flag_ns_v2", "flag_dropped", "notes"
  ),
  col_types = c(
    "text", rep("date", 3), "text", rep("numeric", 4), "text"
  ),
  skip = 10
)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Bridge session data imported with", nrow(bridge), 
  "rows and", ncol(bridge),
  "columns.\n"
)

# 2023-03-15: Bridge session data imported with 4353 rows and 10 columns.
```


# 🚧Data management

## Master log

Combine screened in and screened out for easier data manipulation below.

```{r}
# Variable to identify which data frame each record came from
master_log_screened_in$screened_in <- 1L
master_log_screened_out$screened_in <- 0L

# Bind rows
master_log_combined <- bind_rows(master_log_screened_in, master_log_screened_out)

# Factorize screened_in variable
master_log_combined$screened_in_f <- factor(
  master_log_combined$screened_in, labels = c("Screened-Out", "Screened-In")
)
```

Coerce date columns to dates

```{r}
master_log_combined <- master_log_combined %>% 
  mutate(
    across(
      starts_with("date_"),
      ~ as.Date(as.numeric(.x), origin = "1899-12-30")
    )
  )

# 'NAs introduced by coercion' error is a result of attempting to change text 
# to numbers. For example, "no show". R converts those to NA instead. That's
# exactly what we want.
```

Recode variables and create factors

```{r}
master_log_combined <- master_log_combined %>%
  mutate(
    group_f = factor(group, c("UCM", "UCM+SP", "L2C")),
    gender_f = factor(gender, c("M", "F", "Other"), c("Male", "Female", "Other")),
    race_3cat = case_when(
      is.na(race)  ~ NA_character_,
      race == "AA" ~ "Black or African American",
      race == "W"  ~ "White",
      TRUE         ~ "Other"
    ),
    race_3cat_f = factor(
      race_3cat,
      c("Black or African American", "White", "Other")
    ),
    hispanic_f = factor(hispanic, c("N", "Y"), c("Non-Hispanic", "Hispanic"))
  )
```

Created new screened-in and screened-out now that we are done with variable cleaning.

```{r}
screened_in  <- filter(master_log_combined, screened_in == 1L)
screened_out <- filter(master_log_combined, screened_in == 0L)
```

## Phone terminations

There were some merged rows in the Excel sheet that delineated different EMA structures. We will remove those rows from the data.   

```{r}
phone_terminations <- phone_terminations %>% 
  filter(!str_detect(id, "[a-zA-Z]"))
```

Add informed consent form (ICF) version to the data

```{r}
phone_terminations <- phone_terminations %>% 
  mutate(
    icf = case_when(
      id <= 2073 ~ 1L,
      id <= 2153 ~ 2L,
      id >= 2154 ~ 3L
    )
  )
```

Create a long version and coerce reason to factor.

```{r}
phone_terminations_long <- phone_terminations %>%
  select(id, icf, ends_with("term_reason")) %>% 
  pivot_longer(
    cols = ends_with("term_reason"),
    names_to = "phone",
    names_pattern = "phone_(\\d)_term_reason",
    names_transform = list(phone = as.integer),
    values_to = "reason"
  ) %>% 
  filter(!is.na(reason)) %>% 
  mutate(
    reason_f = factor(reason) %>% fct_infreq()
  )
```

## Remote Interview & Redcap Tracking Sheet

```{r}
remote <- remote %>% 
  mutate(
    # Fix different spellings
    group = if_else(group == "UCM+SP", "UCM + SP", group),
    group_f = factor(group, c("UCM", "UCM + SP", "L2C"))
  )
```

## EMA data

Keep UCM+SP and L2C rows only for EMA analysis.

```{r}
# Check for misspellings
unique(ema$group)
```

```{r}
ema <- ema %>% 
  mutate(group = str_remove_all(group, " "))
```

Also, only keep participants who have gone through all 12 EMA cycles. The denominator for the calculations in the analysis section below should only include participants who have been in the study long enough to complete all 12 cycles. I'm determining which rows from the EMA data to keep by finding the highest id number with a non-missing value for emas_completed_cycle_12 (on the spreadsheet: "EMAs_Completed12"). 

What is the highest id with all 12 cycles? 

```{r}
highest_id_w_12 <- ema %>% 
  filter(!is.na(emas_completed_cycle_12)) %>% 
  pull(id) %>% 
  max()

highest_id_w_12 # 2410
```

```{r}
ema <- ema %>% 
  filter(group %in% c("UCM+SP", "L2C")) %>% 
  filter(id <= highest_id_w_12)
```

Setting NA to zero in 15 day EMA log, if they exist.
NOTES: This should be happening directly in the Excel file.

```{r}
# For data checking
ema %>% 
  select(id, starts_with("emas_completed")) %>% 
  filter(
    if_any(
      everything(), 
      ~ is.na(.x)
    )
  )
```

```{r}
ema <- ema %>% 
  mutate(
    across(
      starts_with("emas_completed"),
      ~if_else(is.na(.x), 0, .x)
    )
  )
```

Add a column for total EMAs completed

```{r}
ema_initial_pay_approach <- ema_initial_pay_approach %>% 
  rowwise() %>% 
  mutate(emas_completed_total = sum(c_across(starts_with("emas_completed")))) %>% 
  ungroup()
```

```{r}
ema <- ema %>% 
  rowwise() %>% 
  mutate(emas_completed_total = sum(c_across(starts_with("emas_completed")))) %>% 
  ungroup()
```

```{r}
# For data checking
# ema %>% 
#   select(id, starts_with("emas_completed"), emas_completed_total)
```

Create a variable that indicates if all 12 15-day periods have been tallied.

```{r}
ema_initial_pay_approach <- ema_initial_pay_approach %>%
  rowwise() %>% 
  mutate(n_periods = sum(!is.na(c_across(matches("emas_completed_cycle"))))) %>% 
  ungroup()
```

```{r}
ema <- ema %>%
  rowwise() %>% 
  mutate(n_periods = sum(!is.na(c_across(matches("emas_completed_cycle"))))) %>% 
  ungroup()
```

Create a combined version of the data set

```{r}
ema_initial_pay_approach <- ema_initial_pay_approach %>% 
  mutate(pay_approach = "Initial")

ema <- ema %>% 
  mutate(pay_approach = "Revised")

ema_combined <- ema_initial_pay_approach %>% 
  bind_rows(ema)
```

Make a long version of the data.

```{r}
ema_combined_long <- ema_combined %>% 
  select(id:pay_approach) %>% 
  pivot_longer(
    emas_completed_cycle_1:emas_completed_cycle_12,
    names_to = "cycle",
    names_prefix = "emas_completed_cycle_",
    values_to = "n_completed"
  ) %>% 
  mutate(cycle_f = factor(cycle, 1:12))
```

For the March 2023 quarterly report: There are actually two different revised payment approaches. Michael wants to plot them separately.

2023-03-20, From James:
I want to mention that there was some bleed over from the 1nd RPA into the 2st RPA for 2 participants (2147 & 2148) when we switched over to the 2nd RPA. The PIs wanted us to get all the participants who were on the 1st RPA consented on the 2nd RPA asap. I don’t think this changes your analysis procedure, but wanted to advise.  

There are 2 RPA and the original payment structure for EMA Comp:
* 1st 2001-2073 Participants. Compensated on their V3-v5. 10, 15, 25 for EMA Completion. 
* 1st RPA 2074-2152 Frequency of payment was changed to every 15 days. Comp was the same as original 10, 15, 25 for EMA Completion. 
* 2nd RPA 2153-2442. Frequency of payment was every 15 days and doubled comp. 20, 30, 50.

```{r}
ema_combined_long <- ema_combined_long |> 
  mutate(
    pay_approach_3cat = case_when(
      id < 2074 ~ 1L, # Initial
      id < 2153 ~ 2L, # Increased pay frequency
      TRUE      ~ 3L  # Doubled pay amount
    ),
    pay_approach_3cat_f = factor(
      pay_approach_3cat, 1:3, 
      c("Initial Approach", "Increased Payment Frequency", "Double Payment Amount")
    )
  )
```

## Arrests

Remove blank rows from arrest data.

```{r eval=FALSE}
# Data check
arrest |> 
  filter(is.na(id)) |> 
  nrow() # 20230-03-21: 57
```

```{r}
arrest <- arrest |> 
  filter(!is.na(id))
```

Drop people who are missing arrested

```{r}
arrest <- arrest |> 
  filter(!is.na(arrested))
```

Are there any id's missing from the arrest data?

```{r eval=FALSE}
# Data check
# setdiff(master_log_screened_in$id, arrest$id) # No difference
```

Merge L2C group into the arrest data.

```{r}
arrest <- arrest %>% 
  left_join(
    screened_in %>% 
      select(id, group),
    by = "id"
  ) %>% 
  select(id, group, everything())
```

Create factor version of group

```{r eval=FALSE}
unique(arrest$group)
```

```{r}
arrest <- arrest |> 
  mutate(
    group_f = factor(group, c("UCM", "UCM+SP", "L2C"))
  )
```

## Bridge Case Session Minutes

Remove text from date columns and convert to dates.

```{r}
bridge <- bridge %>% 
  mutate(
    date_session = str_remove_all(date_session, "[A-z]|[a-z]"),
    date_session = as.numeric(date_session),
    date_session = as.Date(date_session, origin = "1899-12-30")
  )
```

Remove instructions from "notes" column of rows 1 and 2.

```{r}
bridge[1, "notes"] <- NA_character_
bridge[2, "notes"] <- NA_character_
```

Drop blank rows. In the Excel sheet there were some blank spacer rows.

* `c_across()` doesn't work with columns of different types. So, creating missing data dummy variables.

```{r} 
bridge <- bridge %>%
  # Create missing data dummy variables
  mutate(
    across(
      everything(),
      is.na,
      .names = "{col}_miss"
    )
  ) %>% 
  # Sum missing data dummy variables
  rowwise() %>% 
  mutate(
    n_missing = sum(c_across(ends_with("_miss")))
  ) %>% 
  ungroup() %>% 
  # Drop missing data dummy variables
  select(-ends_with("_miss")) %>% 
  # Drop rows that are missing in every column
  filter(!n_missing == 8)
```

Carry forward id numbers. In the Excel sheet, the id number is only given in the first row of each set of rows for each participant.

```{r}
bridge <- bridge %>%
  # Carry forward id
  fill(id) %>% 
  group_by(id) %>% 
  # Carry forward other variables grouped by id
  fill(baseline_date, v2_rand_date, v5_sched_final_visit_date) %>% 
  ungroup()
```

Create a factor for session type and a dummy variable for case management.

```{r}
bridge <- bridge %>% 
    mutate(
    # Change NA to None for type
    type = if_else(is.na(type), 4, type),
    # Create factor version
    type_f = factor(
      type,
      1:4,
      c("case_management", "crisis_management", "other", "none")
    ),
    # Create dummy variable for case management
    case_management = type_f == "case_management"
  )
```

Merge L2C group into the Bridge data.

```{r}
bridge <- bridge %>%
  left_join(
    screened_in %>% 
      select(id, group),
    by = "id"
  ) %>% 
  select(id, group, everything())
```

Create an "other" group to capture groups other than UCM, UCM+SP, and L2C.

```{r}
bridge <- bridge %>%
  mutate(
    group_f = factor(group, c("UCM", "UCM+SP", "L2C")),
    group_f = fct_explicit_na(group_f, na_level = "Other")
  )
```

Remove rows with participants who are missing a V2 randomization date.

* James has a footnote that says, "Excludes participants who missed randomization (V2) date (n=16)." So, I will filter out people who are missing a V2 randomization date.

```{r}
bridge %>% 
  filter(is.na(v2_rand_date)) %>% 
  nrow()
```

There are four participants with a missing date for V2 randomization. They will be removed from the analyses below.

```{r}
bridge <- bridge %>% 
  filter(!is.na(v2_rand_date))
```

Create a dummy variable for 
* "Used at least one session of regular case management."
* "Used at least one session of crisis case management."
* "Used at least one session of other case management."
* "Used no forms of Bridge case management."

```{r}
bridge <- bridge %>%
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = sum(type %in% 1:3),
    total_minutes = sum(duration, na.rm = TRUE),
    any_case_management = any(type_f == "case_management"),
    any_crisis_management = any(type_f == "crisis_management"),
    any_other = any(type_f == "other"),
    all_none = all(type_f == "none")
  ) %>% 
  ungroup()
```

Create a "wide" version of the data with one row per participant.

```{r}
bridge_wide <- bridge %>% 
  filter(row == 1)
```

Keep only participants in L2C, UCM, and UCM+SP groups for analysis.

```{r}
bridge <- bridge %>% 
  filter(group_f %in% c("L2C", "UCM", "UCM+SP"))
```

```{r}
bridge_wide <- bridge_wide %>% 
  filter(group_f %in% c("L2C", "UCM", "UCM+SP"))
```

## Recruitment

```{r}
recruitment <- master_log_screened_in %>% 
  select(date_baseline) %>% 
  mutate(
    covid = if_else(date_baseline < "2020-03-17", "pre", "post")
  )
```


# 📈Analysis

Number of participants screened in

```{r}
n_screened_in <- nrow(screened_in) # 442
```

## 📄Load Word template

```{r}
doc <- read_docx("template_l2c_quarterly_report.docx")

# Pg. 3
## Add number of participants screened-in and the date
doc <- doc %>% 
  body_replace_text_at_bkm("n_participants", as.character(n_screened_in)) %>% 
  body_replace_text_at_bkm("date", format(Sys.Date(), "%B %d, %Y"))
```

**NOTES:** You may want to use descriptive names for these tables instead of numbers. The numbers may change over time. You might also want to organize this Rmd file by sections that match the quarterly report. But maybe not.

## Table 1

Table 1. Demographic characteristics of all people screened for study inclusion.

### Screened-in

```{r}
t1_cont_stats_si <- master_log_combined %>%
  filter(screened_in == 1) %>% 
  get_mean_sd(age, 1) %>% 
  # Add blank row below
  add_row(var = "", cat = "", formatted_stats = "")
```

**NOTES:** Right now, I have to use purrr::map_df to use freq_table over multiple categorical variables. In the future, I'd like to either create a wrapper function for this or make a really good vignette for using this method. Created issues in freqtables (#23, #36).

**NOTES:** Create a function to add an empty row. For now, I'm just adding this to the data frame manually. I've asked if there is a way to do this in flextable on [StackOverflow](https://stackoverflow.com/questions/64932726/add-a-blank-row-in-flextable). I've also created an issue in freqtables to create a wrapper function to do this (#35).

```{r}
# Loop over all categorical vars
t1_cat_stats_si <- map_df(
  quos(gender_f, race_3cat_f, hispanic_f), 
  function(x) {
    master_log_combined %>%
      filter(screened_in == 1) %>% 
      freq_table({{x}}) %>%
      freq_format(recipe = "n (percent)", digits = 1) %>%
      select(var, cat, formatted_stats) %>%
      # Add a row with the var name only
      add_row(var = quo_name(x), .before = 1) %>% 
      # Add blank row below
      add_row(var = "", cat = "", formatted_stats = "")
  }
) %>% 
  # Drop the final empty row
  slice(-n())
```

Add group n and row bind cont and cat stats

```{r}
table_1_si <- t1_cont_stats_si %>% 
  bind_rows(t1_cat_stats_si) %>% 
  rename(screened_in = formatted_stats)
```

### Screened-out

Number of participants screened_out

```{r}
n_screened_out <- nrow(screened_out)
```

```{r}
t1_cont_stats_so <- master_log_combined %>%
  filter(screened_in == 0) %>% 
  get_mean_sd(age, 1) %>% 
  # Add blank row below
  add_row(var = "", cat = "", formatted_stats = "")
```

```{r}
# Loop over all categorical vars
t1_cat_stats_so <- map_df(
  quos(gender_f, race_3cat_f, hispanic_f), 
  function(x) {
    master_log_combined %>%
      filter(screened_in == 0) %>% 
      freq_table({{x}}) %>%
      freq_format(recipe = "n (percent)", digits = 1) %>%
      select(var, cat, formatted_stats) %>%
      # Add a row with the var name only
      add_row(var = quo_name(x), .before = 1) %>% 
      # Add blank row below
      add_row(var = "", cat = "", formatted_stats = "")
  }
) %>% 
  # Drop the final empty row
  slice(-n())
```

Add group n and row bind cont and cat stats

```{r}
# table_1_so <- tibble(
#   var = "",
#   cat = "",
#   formatted_stats = paste0("(n = ", n_screened_out, ")")
# ) %>% 
#   bind_rows(t1_cont_stats_so) %>% 
#   bind_rows(t1_cat_stats_so) %>% 
#   rename(screened_out = formatted_stats)
```

```{r}
table_1_so <- t1_cont_stats_so %>% 
  bind_rows(t1_cat_stats_so) %>% 
  rename(screened_out = formatted_stats)
```

### Combined

Combined screened-in and screened-out

```{r}
table_1 <- bind_cols(
  table_1_si,
  table_1_so %>%
    select(screened_out)
)
```

Slide categories over

```{r}
table_1 <- table_1 %>%
  mutate(
    # Slide categories over
    var = if_else(is.na(cat), var, cat)
  ) %>%
  select(-cat)
```

Create flextable object

### 📌 Note on flextable helpers

2021-05-11: You started an R script called flextable_helpers and started pulling some of the stuff out into helper functions. You can probably do even more of that in the future. For example, the "compose" code in the chunk below.

```{r}
table_1_ft <- flextable(table_1) %>% 
  
  # Format the header row
  set_header_labels(
    var = "Characteristic",
    screened_in = "Screened-in",
    screened_out = "Screened-out"
  ) %>%
  bold(part = "header") %>%
  
  # Add group n's
  add_header(top = FALSE, 
    screened_in = paste0("(n = ", n_screened_in, ")"),
    screened_out = paste0("(n = ", n_screened_out, ")")
  ) %>% 
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  
  # Adjust the borders around the header
  border_remove() %>% 
  hline_top(part = "header", border = fp_border(width = 1)) %>%
  hline_bottom(part = "header", border = fp_border(width = 1)) %>%
  
  # # Bold variable names
  compose(
    i = 1, j = 1,
    value = as_paragraph(
      as_chunk("Age in years", props = header_fmt), ", mean (sd)"
    )
  ) %>%
  compose(
    i = 3, j = 1,
    value = as_paragraph(
      as_chunk("Gender", props = header_fmt), ", n(%)"
    )
  ) %>%
  compose(
    i = 8, j = 1,
    value = as_paragraph(
      as_chunk("Race", props = header_fmt), ", n(%)"
    )
  ) %>%
  compose(
    i = 13, j = 1,
    value = as_paragraph(
      as_chunk("Ethnicity", props = header_fmt), ", n(%)"
    )
  ) %>%
  
  # Indent categories
  padding(i = c(4:6, 9:11, 14:15), j = 1, padding.left = 10) %>%

  # Left align first column
  align(j = 1, align = "left", part = "body") %>%

  # Center align second and third column
  align(j = 2:3, align = "center", part = "all") %>%

  # Resize bottom border
  hline_bottom(border = fp_border(width = 1)) %>% 
  
  # Style with my theme
  # Remove vertical cell padding and TNR 11 font
  my_ft_theme() |> 
  
  # Change column widths
  width(width = 2.33)

# table_1_ft
```

### 📄 Add Table 1 to Word

```{r}
## Add Table 1. Demographic characteristics of all people screened-in.
doc <- body_replace_flextable_at_bkm(doc, "table_demographics", table_1_ft)
```

Clean up

```{r}
rm(
  t1_cat_stats_si, t1_cat_stats_so, t1_cont_stats_si, t1_cont_stats_so, table_1,
  table_1_si, table_1_so
)
```

## Table 2

Table 2. Distribution of reasons for screen-out

```{r eval=FALSE}
unique(screened_out$reason_1)
```

```{r}
table_2 <- screened_out %>%
  select(id, starts_with("reason")) |> 
  pivot_longer(
    starts_with("reason"),
    names_to = "reason_number",
    names_prefix = "reason_",
    values_to = "reason"
  ) %>% 
  filter(!is.na(reason)) %>% 
  # Change reason to factor so that we can add all categories of screen-out
  # reasons -- including those with zero observations (e.g., Refused to report 
  # SSN or residency)
  mutate(reason_f = factor(reason) %>% fct_expand("Refused to report SSN or residency")) %>% 
  # 2023-03-20: Michael wants the denominator to be number of people who were 
  # screened out. Then, add a note saying that the percentages add up to 
  # more than 100 because people could be screened out for multiple reasons.
  count(reason_f, .drop = FALSE) |> 
  mutate(
    n_total = length(unique(screened_out$id)),
    prop = n / n_total,
    percent = prop * 100
  ) |> 
  arrange(desc(n)) %>% 
  rename(cat = reason_f) %>% 
  freq_format("n (percent)", digits = 1) %>%
  select(cat, formatted_stats)
```

Create flextable object

```{r}
table_2_ft <- flextable(table_2) %>% 
  
  # Format the header row
  set_header_labels(
    cat = "Reason For Screen Out",
    formatted_stats = "n (%)"
  ) %>%
  bold(part = "header") %>%
  
  # Adjust the borders around the header
  border_remove() %>% 
  hline_top(part = "header", border = fp_border(width = 1)) %>%
  hline_bottom(part = "header", border = fp_border(width = 1)) %>% 
  
  # Center align second column
  align(j = 2, align = "center", part = "all") %>%

  # Adjust bottom borders
  hline_bottom(border = fp_border(width = 1)) %>% 
  
  # Style with my theme
  # Remove vertical cell padding and TNR 11 font
  my_ft_theme() |> 
  
  # Change column widths
  width(width = 3.5)
  
# table_2_ft
```

### 📄 Add Table 2 to Word

```{r}
doc <- body_replace_flextable_at_bkm(doc, "table_screen_out", table_2_ft)
```

## Table 3

Table 3. Payment card and phone loss. 

Adding to the Word template as we go.

Total number of ClinCards distributed

```{r}
doc <- body_replace_text_at_bkm(
  doc, 
  "t3_tot_clin_card_dist", 
  sum(master_log_screened_in$n_clincards, na.rm = TRUE) %>% as.character()
)
```

Total number of participants with ClinCard replacements

```{r}
doc <- body_replace_text_at_bkm(
  doc, 
  "t3_tot_n_part_clincard_replace", 
  sum(master_log_screened_in$n_clincards > 1, na.rm = TRUE) %>% as.character()
)
```

Total number of phones distributed

```{r}
doc <- body_replace_text_at_bkm(
  doc, 
  "t3_tot_phones_dist", 
  sum(master_log_screened_in$phone_n_distributed, na.rm = TRUE) %>% as.character()
)
```

Total number of participants with phone replacements

```{r}
doc <- body_replace_text_at_bkm(
  doc, 
  "t3_tot_n_part_phone_replace", 
  sum(master_log_screened_in$phone_n_distributed > 1, na.rm = TRUE) %>% as.character()
)
```

Number of ClinCard replacements

```{r}
# Don't need the first row. Those arent' "replacements"
t3_n_clincard_replacements <- count(master_log_screened_in, n_clincards) %>% 
  slice(-1) %>% 
  pull(n) %>% 
  as.character()
```

```{r}
# Data check
if (length(t3_n_clincard_replacements) != 5) {
  stop(
    paste0(
      "Expecting t3_n_clincard_replacements to have 5 values, but it has ",
      length(t3_n_clincard_replacements), ". You may need to update Table 3 ",
      "in template_l2c_quarterly_report.docx to accomodate."
    )     
  )
}
```

```{r}
# Add the numbers directly to the table in the Word document
for (i in seq_along(t3_n_clincard_replacements)) {
  doc <- body_replace_text_at_bkm(
    doc,
    paste0("t3_n_clincard_replacements_", i),
    t3_n_clincard_replacements[i]
  )
}
```

## Table 4

Table 4. Phone distribution and replacement.

Total # of phones distributed overall

```{r}
sum(master_log_screened_in$phone_n_distributed, na.rm = TRUE) # 413

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_phones_distributed",
  sum(master_log_screened_in$phone_n_distributed, na.rm = TRUE) %>% as.character()
)
```

Total # of participants in phone groups

NOTES: 2020-12-03, from James, Phone groups are L2C and UCM+SP only.

```{r}
master_log_screened_in %>% 
  filter(group == "L2C" | group == "UCM+SP") %>% 
  nrow() # 269

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_in_phone_groups",
  master_log_screened_in %>% 
    filter(group == "L2C" | group == "UCM+SP") %>% 
    nrow() %>% 
    as.character()
)
```

Total number of participants with phone replacements

```{r}
sum(master_log_screened_in$phone_n_distributed > 1, na.rm = TRUE) # 134

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_in_phone_replacements",
  sum(master_log_screened_in$phone_n_distributed > 1, na.rm = TRUE) %>% as.character()
)
```

Number of participants w/ phone replacement (UCM+SP)

```{r}
master_log_screened_in %>% 
  filter(group == "UCM+SP") %>% 
  summarise(sum(phone_n_distributed > 1, na.rm = TRUE)) # 61

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_in_phone_replacements_ucm_sp",
  master_log_screened_in %>% 
    filter(group == "UCM+SP") %>% 
    summarise(sum(phone_n_distributed > 1, na.rm = TRUE)) %>% 
    as.character()
)
```

Number of participants w/ phone replacement (L2C)

```{r}
master_log_screened_in %>% 
  filter(group == "L2C") %>% 
  summarise(sum(phone_n_distributed > 1, na.rm = TRUE)) # 73

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_in_phone_replacements_l2c",
  master_log_screened_in %>% 
    filter(group == "L2C") %>% 
    summarise(sum(phone_n_distributed > 1, na.rm = TRUE)) %>% 
    as.character()
)
```

Total number of participants in UCM+SP w/ 1 phone replacement

```{r}
master_log_screened_in %>% 
  filter(group == "UCM+SP") %>% 
  summarise(sum(phone_n_distributed == 2, na.rm = TRUE)) # 56

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_1_phone_replacement_ucm",
  master_log_screened_in %>% 
    filter(group == "UCM+SP") %>% 
    summarise(sum(phone_n_distributed == 2, na.rm = TRUE)) %>% 
    as.character()
)
```

Total number of participants in L2C w/ 1 phone replacement

```{r}
master_log_screened_in %>% 
  filter(group == "L2C") %>% 
  summarise(sum(phone_n_distributed == 2, na.rm = TRUE)) # 67

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_1_phone_replacement_l2c",
  master_log_screened_in %>% 
    filter(group == "L2C") %>% 
    summarise(sum(phone_n_distributed == 2, na.rm = TRUE)) %>% 
    as.character()
)
```

Number of participants in UCM+SP w/ >1 phone replacement

```{r}
master_log_screened_in %>% 
  filter(group == "UCM+SP") %>% 
  summarise(sum(phone_n_distributed > 2, na.rm = TRUE)) # 5

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_mult_phone_replacements_ucm",
  master_log_screened_in %>% 
    filter(group == "UCM+SP") %>% 
    summarise(sum(phone_n_distributed > 2, na.rm = TRUE)) %>% 
    as.character()
)
```

Number of Participants in L2C w/ >1 phone replacement

```{r}
master_log_screened_in %>% 
  filter(group == "L2C") %>% 
  summarise(sum(phone_n_distributed > 2, na.rm = TRUE)) # 6

# Add to Word document
doc <- body_replace_text_at_bkm(
  doc,
  "t4_n_mult_phone_replacements_l2c",
  master_log_screened_in %>% 
    filter(group == "L2C") %>% 
    summarise(sum(phone_n_distributed > 2, na.rm = TRUE)) %>% 
    as.character()
)
```

Footnote: Number of participants had phone replaced 1 time (2 phones per participant total).

```{r}
sum(master_log_screened_in$phone_n_distributed == 2, na.rm = TRUE)
```

Footnote: N by group and ids for 2 or more phone replacements due to malfunctions in the UCM+SP and L2C groups

The footnote under Table 4 that I'm trying to recreate says, "3 UCM+SP participants (2010, 2165, 2168) & 3 L2C participants (2099, 2124, 2189) replaced phone 2 times (3 phones per participant total) due to phone malfunctions."

NOTES: I tried importing the issues and notes file to see if I could recreate this information. I could not find consistent use of a word like "malfunction" that I could search for to systematically update this number. Therefore, I'm going to leave a comment on the report asking James to update it manually.

NOTES: 2020-12-10, James and Addison changed how "Defective" is coded. It should appear more often now.

NOTES: 2021-05-11, I took this footnote out of the report. I don't think it's that informative. If you need the code for it, you can look through previous versions on GitHub.

## Figure 1

Figure 1. Reasons for phone terminations overall.

```{r}
n_phone_terminations <- phone_terminations_long %>% 
  filter(!is.na(reason_f)) %>% 
  nrow()
```

```{r}
fig_1 <- phone_terminations_long %>% 
  filter(!is.na(reason_f)) %>% 
  freq_table(reason_f) %>% 
  mutate(
    cat_f = factor(cat),
    cat_f = fct_reorder(cat_f, n)
  ) %>% 
  ggplot(aes(cat_f, n)) +
    geom_bar(stat = "identity", fill = "#00519B") +
    geom_label(aes(label = n)) +
    coord_flip() +
    labs(
      # X in plot, but Y before flipping coordinates
      y = "Number of Phones"
    ) +
    theme_classic() +
    theme(
      axis.title.y = element_blank(),
      axis.text.y = element_text(color = "black"),
      axis.text.x = element_text(color = "black")
    ) 
```

Save figure for copy and paste into report

```{r}
ggsave("fig_1.jpeg", width = 7, height = 4)
```

### 📄 Add Figure 1 to Word

```{r}
# Add Figure 1. Reasons for phone terminations overall.
doc <- doc %>% 
  body_replace_text_at_bkm("n_phone_terminations", as.character(n_phone_terminations)) %>% 
  body_replace_img_at_bkm(
    "fig_phone_terminations", 
    external_img("fig_1.jpeg", width = 7, height = 4)
  )
```

## Table 5

Table 5. Reasons for phone terminations by informed consent form iteration

2021-05-11: Filled in manually.

By ICF. ICF 1 and 2 should not change over time.

```{r}
table_05 <- phone_terminations_long %>%
  filter(!is.na(reason_f)) %>% 
  # Arrange reasons in the same order they appear in the table
  mutate(
    reason_ordered = fct_relevel(
      reason_f,
      "Stolen", "Completed Study", "Non-Compliance", "Lost", "Defective", 
      "Sold or Gifted", "Returned to Staff", "Broken"
    ),
    # Add Total category
    reason_ordered = fct_expand(reason_ordered,"Total")
  ) %>% 
  freq_table(icf, reason_ordered) |> 
  select(row_cat, col_cat, n, percent_row) |> 
  # Calculate totals for each icf
  group_by(row_cat) |> 
  mutate(
    n = if_else(col_cat == "Total", sum(n), n),
    percent_row = if_else(col_cat == "Total", sum(percent_row), percent_row)
  ) |> 
  freq_format("n (percent_row)", digits = 1) |> 
  select(row_cat, col_cat, formatted_stats) %>% 
  pivot_wider(
    names_from = "row_cat",
    values_from = c("formatted_stats")
  )
```

NOTES: 
1. Table 5 "non-compliance" and "completed" n for ICF#1 needs to be updated manually. This is done to show how many PT's would have been terminated if non-compliance protocol was in place during IFC#1 and compare to ICF#2 and #3. 

Create flextable

```{r}
table_05_ft <- flextable(table_05) %>% 
  my_ft_theme() 
```

Output Word document for easy copy paste into template (DELETE)
* Bold  total manually.

```{r}
read_docx() %>%
  body_add_flextable(table_05_ft) %>% 
  print("table_05_ft.docx")
```

## Table 6

Table 6. Number and percent of participants per L2C group.

2021-05-11: Filled in manually.

Create a tibble that contains randomized participants only.

```{r}
# Data check. As of 2021-12-04, the group column in the master log should only
# contain "L2C", "UCM+SP", "UCM", and NA.
if (!identical(unique(master_log_screened_in$group), c("L2C", "UCM+SP", "UCM", NA))) {
  stop("We expect the group column in the master log to contain only L2C, ", 
       "UCM+SP, UCM, and NA. Instead, it contains ", 
       paste0(unique(master_log_screened_in$group), collapse = ", "),
       ". This condition is tested in the Table 6 section of code.")
}
```

```{r}
master_log_randomized <- filter(master_log_screened_in, !is.na(group))
n_randomized <- nrow(master_log_randomized)
```

```{r}
# Use participants randomized to a L2C group only.
table_06 <- master_log_randomized %>%
  # Order groups in the same order they appear in the table
  mutate(
    group_ordered = factor(
      group,
      c("UCM+SP", "UCM", "L2C"),
      c("UCM+SP", "UCM", "L2C")
    )
  ) %>%
  freq_table(group_ordered) %>% 
  freq_format("n (percent)", digits = 1) %>%
  select(cat, formatted_stats) %>% 
  rename(`L2C Group` = cat, `n (percent)` = formatted_stats)
```

Create flextable

```{r}
table_06_ft <- flextable(table_06) %>% 
  my_ft_theme() 
```

Output Word document for easy copy paste into template (DELETE)
* Bold  total manually.

```{r}
read_docx() %>%
  body_add_flextable(table_06_ft) %>% 
  print("table_06_ft.docx")
```

### 📄 Add n randomized to title of Table 6

```{r}
doc <- doc %>% 
  body_replace_text_at_bkm("n_randomized", as.character(n_randomized))
```

## Table 7

Table 7. Number and percent of participants who completed visits 1 through 5.

```{r}
table_07_overall <- master_log_screened_in %>% 
  select(v1:v5) %>% 
  pivot_longer(
    cols = v1:v5,
    names_to = "visit",
    names_prefix = "v",
    values_to = "complete"
  ) %>% 
  # Coerce complete to numeric to calculate prop below
  mutate(complete = if_else(complete == "Yes", 1L, 0L)) %>% 
  group_by(visit) %>% 
  summarise(
    n = sum(complete == 1, na.rm = TRUE),
    mean = mean(complete, na.rm = TRUE),
    percent = round(mean * 100, 1),
    .groups = "drop"
  ) %>% 
  freq_format("n (percent)", digits = 1) %>% 
  select(visit, formatted_stats)
```

Add visit compliance Excluding No Show V2 PTs

```{r}
table_07_w_v2 <- master_log_screened_in %>%
  filter(v2 == "Yes") %>% 
  pivot_longer(
    cols = v1:v5,
    names_to = "visit",
    names_prefix = "v",
    values_to = "complete"
  ) %>% 
  # Coerce complete to numeric to calculate prop below
  mutate(complete = if_else(complete == "Yes", 1L, 0L)) %>%
  group_by(visit) %>% 
  summarise(
    n = sum(complete == 1, na.rm = TRUE),
    mean = mean(complete, na.rm = TRUE),
    percent = round(mean * 100, 1),
    .groups = "drop"
  ) %>% 
  freq_format("n (percent)", digits = 1) %>% 
  select(visit, formatted_stats)
```

```{r}
# Add column totals directly to Word document
# Overall
sum(master_log_screened_in$v1 == "Yes") # 442
doc <- body_replace_text_at_bkm(
  doc,
  "t7_n_overall",
  sum(master_log_screened_in$v1 == "Yes") %>% as.character()
)

# Participants Who Attended Visit 2
sum(master_log_screened_in$v2 == "Yes") # 406
doc <- body_replace_text_at_bkm(
  doc,
  "t7_n_attend_2",
  sum(master_log_screened_in$v2 == "Yes") %>% as.character()
)
```

Merged 7 overall and 7 with V2 together and make flextable.

```{r}
table_07_ft <- table_07_overall %>% 
  left_join(table_07_w_v2, by = "visit") %>% 
  rename(
    Overall = formatted_stats.x,
    `Participants Who Attended Visit 2` = formatted_stats.y
  ) |> 
  flextable() %>% 
  my_ft_theme() 
```

Output Word document for easy copy paste

NOTES: Delete all these separate Word documents with tables after you make the big automated report.

```{r}
read_docx() %>%
  body_add_flextable(table_07_ft) %>% 
  print("table_07_ft.docx")
```

## Table 8

Table 8. COVID-19 phone interviews (N={see below}) since protocol change on 3/17/2020. 

2021-05-11: Filled in manually.

2023-03-20: James says we should pull these numbers from the Master Log instead of remote. 

Total interviews by mode (phone vs. redcap)

```{r}
# Data check
screened_in |> 
  select(id, group_f, v3_r_completed, v4_r_completed, v5_r_completed) |> 
  summarise(
    v3 = sum(v3_r_completed == "Yes"),
    v4 = sum(v4_r_completed == "Yes"),
    v5 = sum(v5_r_completed == "Yes", na.rm = TRUE)
  )
```


```{r}
remote_interviews <- screened_in |> 
  # Use completed, not distributed
  select(id, group_f, v3_r_completed, v4_r_completed, v5_r_completed, v2_phone:v5_phone) |> 
  # Rename to make for easier pivoting later
  rename_with(
    ~ paste("REDCap", str_extract(.x, "\\d"), sep = "_"),
    v3_r_completed:v5_r_completed
  ) |> 
  rename_with(
    ~ paste("Phone", str_extract(.x, "\\d"), sep = "_"),
    v2_phone:v5_phone
  ) |>
  pivot_longer(
    c(-id, -group_f),
    names_to = c(".value", "visit"),
    names_sep = "_",
    names_transform = list(visit = as.integer)
  ) |> 
  mutate(
    REDCap = if_else(REDCap == "No", 0L, 1L),
    Phone = if_else(Phone == "No", 0L, 1L),
    mode = case_when(
      REDCap == 1 & Phone == 1 ~ 3L, # Both
      Phone == 1 ~ 1L, # Phone
      REDCap == 1 ~ 2L, # REDCap
      TRUE ~ NA_integer_
    ),
    mode_f = factor(mode, 1:3, c("Phone", "REDCap", "Both"))
  ) |> 
  filter(!is.na(mode_f))
```

```{r}
table_08 <- tibble(
  categories = "Overall",
  n = nrow(remote_interviews)
)
```

By remote interview modality (REDCap, Phone, Both)

```{r}
table_08_by_mode <- remote_interviews |>
  count(mode_f) |> 
  mutate(total = sum(n)) |> 
  mutate(unique_id = length(unique(remote_interviews$id))) |> 
  select(categories = mode_f, n)
```

```{r}
table_08 <- table_08 |> 
  bind_rows(table_08_by_mode)
```

By group

```{r}
table_08_by_group <- remote_interviews |> 
  count(group_f) %>% 
  mutate(total = sum(n)) |> 
  select(categories = group_f, n)
```

```{r}
table_08 <- table_08 |> 
  add_row(categories = "L2C Groups") |> 
  bind_rows(table_08_by_group)
```

By visit

```{r}
table_08_by_visit <- remote_interviews |> 
  count(visit) |> 
  mutate(total = sum(n)) |> 
  mutate(visit = paste("Visit", visit)) |> 
  select(categories = visit, n)
```

```{r}
table_08 <- table_08 |> 
  add_row(categories = "L2C Visits") |>
  bind_rows(table_08_by_visit)
```

Create flextable

```{r}
table_08_ft <- flextable(table_08) %>% 
  my_ft_theme() 
```

Output Word document for easy copy paste into template (DELETE)
* Bold total manually.

```{r}
read_docx() %>%
  body_add_flextable(table_08_ft) %>% 
  print("table_08_ft.docx")
```

## Replace table 9

For the December 2022 quarterly report, James and Michael decided to replace table 9. They wanted the same information, but they want it in a different form. Instead of using a table, we are now using 3 charts.

For the March 2023 quarterly report: There are actually two different revised payment approaches. Michael wants to plot them separately.

2023-03-20, From James:
I want to mention that there was some bleed over from the 1nd RPA into the 2st RPA for 2 participants (2147 & 2148) when we switched over to the 2nd RPA. The PIs wanted us to get all the participants who were on the 1st RPA consented on the 2nd RPA asap. I don’t think this changes your analysis procedure, but wanted to advise.  

There are 2 RPA and the original payment structure for EMA Comp:
* 1st 2001-2073 Participants. Compensated on their V3-v5. 10, 15, 25 for EMA Completion. 
* 1st RPA 2074-2152 Frequency of payment was changed to every 15 days. Comp was the same as original 10, 15, 25 for EMA Completion. 
* 2nd RPA 2153-2442. Frequency of payment was every 15 days and doubled comp. 20, 30, 50.
 
6/24/2019: EMA compensation change. New payment structure for surveys 
* 13-15 = $50 
* 11-12 = $30 
* 7-10 = $20 
* 0-6 = $0 

Old payment structure for EMAs 
* 13-15 = $25 
* 11-12 = $15 
* 7-10 = $10 
* 0-6 = $0 

How many people are in each group?

```{r eval=FALSE}
# Data check
ema_combined_long |> 
  group_by(id) |> 
  filter(row_number() == 1) |> 
  group_by(pay_approach) |> 
  count()
```

```{r eval=FALSE}
# Data check
ema_combined_long |> 
  group_by(id) |> 
  filter(row_number() == 1) |> 
  group_by(pay_approach_3cat_f) |> 
  count()
```

### Figure 2

Number of Ecological Momentary Assessments (EMA) completed by 15-day cycle and payment approach.

```{r}
# Medians for the plot
median_emas_completed <- ema_combined_long %>%
  group_by(cycle_f, pay_approach_3cat_f) %>% 
  summarise(
    median = median(n_completed),
    .groups = "drop"
  )
```

```{r}
ggplot(ema_combined_long) +
  geom_jitter(aes(x = pay_approach_3cat_f, y = n_completed, col = pay_approach_3cat_f), height = 0.05, alpha = .1) +
  facet_wrap(vars(cycle_f), nrow = 1) + 
  geom_segment(
    aes(x = rep(c(0.5, 1.5, 2.5), 12), y = median, xend = rep(c(1.5, 2.5, 3.5), 12), yend = median), 
    size = 0.75, col = "red", data = median_emas_completed
  ) +
  labs(subtitle = "15-Day Cycle (1-12)") +
  xlab("Cycles") +
  ylab("Number of EMA's Completed") +
  scale_color_manual("Payment Approach", values = c("#BC581A", "#00519B", "#5D3FD3")) +
  theme_classic() +
  theme(
    legend.position = "bottom", 
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
  )
```

Save figure for copy and paste into report

```{r}
ggsave("fig_emas_by_cycle.jpeg", width = 7, height = 4)
```

### 📄 Add Figure 2 to Word

```{r}
doc <- doc %>% 
  body_replace_img_at_bkm(
    "fig_emas_by_cycle", 
    external_img("fig_emas_by_cycle.jpeg", width = 7, height = 4)
  )
```

### Figure 3

Percentage of participants who completed zero Ecological Momentary Assessments (EMA) by 15-day cycle and payment approach.

```{r}
ema_zero_seven <- ema_combined_long %>% 
  group_by(cycle_f, pay_approach_3cat_f) %>% 
  summarise(
    rows = n(),
    zeros = sum(n_completed == 0),
    seven_plus = sum(n_completed >= 7),
    .groups = "drop"
  ) %>% 
  mutate(
    percent_zero = zeros / rows * 100,
    percent_zero_formatted = paste0(round(percent_zero, 0), "%"),
    percent_seven_plus = seven_plus / rows * 100,
    percent_seven_plus_formatted = paste0(round(percent_seven_plus, 0), "%")
  )
```

```{r}
ggplot(ema_zero_seven, aes(x = cycle_f, y = percent_zero, col = pay_approach_3cat_f, group = pay_approach_3cat_f)) + 
  geom_point() +
  geom_line() +
  geom_text(aes(label = percent_zero_formatted), nudge_y = 2.5) +
  xlab("15-Day EMA Cycle") +
  ylab("Percent of Participants") +
  scale_color_manual("Payment Approach", values = c("#BC581A", "#00519B", "#5D3FD3")) +
  theme_classic() +
  theme(
    legend.position = "bottom"
  )
```

Save figure for copy and paste into report

```{r}
ggsave("fig_zero_emas_by_cycle.jpeg", width = 7, height = 4)
```

```{r}
doc <- doc %>% 
  body_replace_img_at_bkm(
    "fig_zero_emas_by_cycle", 
    external_img("fig_zero_emas_by_cycle.jpeg", width = 7, height = 4)
  )
```

### Figure 4

Percentage of participants who completed seven or more Ecological Momentary Assessments (EMA) by 15-day cycle and payment approach.

```{r}
ggplot(ema_zero_seven, aes(x = cycle_f, y = percent_seven_plus, col = pay_approach_3cat_f, group = pay_approach_3cat_f)) + 
  geom_point() +
  geom_line() +
  geom_text(aes(label = percent_seven_plus_formatted), nudge_y = 2.5) +
  xlab("15-Day EMA Cycle") +
  ylab("Percent of Participants") +
  scale_color_manual("Payment Approach", values = c("#BC581A", "#00519B", "#5D3FD3")) +
  theme_classic() +
  theme(
    legend.position = "bottom"
  )
```

Save figure for copy and paste into report

```{r}
ggsave("fig_seven_plus_emas_by_cycle.jpeg", width = 7, height = 4)
```

```{r}
doc <- doc %>% 
  body_replace_img_at_bkm(
    "fig_seven_plus_emas_by_cycle", 
    external_img("fig_seven_plus_emas_by_cycle.jpeg", width = 7, height = 4)
  )
```

## Table 10

Table 10. Arrests by treatment arm 12 months after enrollment.

2021-05-11: Filled in manually.

How many people are in each group?

```{r eval=FALSE}
# Data check
master_log_screened_in |> 
  group_by(group) |> 
  count() |> 
  ungroup() |> 
  mutate(total = sum(n))
```

Overall

```{r}
table_10 <- arrest %>% 
  freq_table(arrested) %>% 
  freq_format("n (percent)", digits = 1) %>% 
  select(var, cat, formatted_stats, n_total) |> 
  
  # Format for easier binding and conversion to flextable
  filter(cat == "Yes") |> 
  mutate(cat = "Overall") |> 
  select(cat, n = n_total, formatted_stats)
```

By L2C group

```{r}
table_10_by_group <- arrest %>% 
  freq_table(group_f, arrested) %>% 
  filter(col_cat == "Yes") %>% 
  freq_format("n (percent_row)", digits = 1) %>% 
  
  # Format for easier binding and conversion to flextable
  mutate(row_cat = if_else(is.na(row_cat), "NS V2", row_cat)) |> 
  select(cat = row_cat, n = n_row, formatted_stats)
```

Bind overall and by group

```{r}
table_10 <- table_10 |> 
  bind_rows(table_10_by_group) |> 
  rename(Arrested = formatted_stats)
```

Create flextable

```{r}
table_10_ft <- flextable(table_10) %>% 
  my_ft_theme() 
```

Output Word document for easy copy paste into template (DELETE)

```{r}
read_docx() %>%
  body_add_flextable(table_10_ft) %>% 
  print("table_10_ft.docx")
```

## Table 11

Table 11. Number and percent of participants who used Bridge case management.

2021-05-11: Filled in manually.

Column totals

```{r}
bridge_col_totals <- bridge %>% 
  filter(row == 1) %>% 
  count(group_f) %>% 
  mutate(cum = cumsum(n))
```

```{r}
# To make it easier to add values to the Word document
n_bridge_overall <- bridge_col_totals |> pull(cum) |> max() |> as.character()
n_bridge_ucm <- bridge_col_totals |> filter(group_f == "UCM") |> pull(n) |> as.character()
n_bridge_ucm_sp <- bridge_col_totals |> filter(group_f == "UCM+SP") |> pull(n) |> as.character()
n_bridge_l2c <- bridge_col_totals |> filter(group_f == "L2C") |> pull(n) |> as.character()
```

### 📄 Add bridge column tolals to Table 11

```{r}
doc <- doc %>% 
  body_replace_text_at_bkm("n_bridge_overall_11", n_bridge_overall) |> 
  body_replace_text_at_bkm("n_bridge_ucm_11", n_bridge_ucm) |>
  body_replace_text_at_bkm("n_bridge_ucm_sp_11", n_bridge_ucm_sp) |>
  body_replace_text_at_bkm("n_bridge_l2c_11", n_bridge_l2c)
```

This table only needs one row per id.

Include only randomized participants.

```{r}
case_mgmt_vars <- quos(
  any_case_management, any_crisis_management, any_other, all_none
)
```

Overall

```{r}
table_11_overall <- map_df(
  case_mgmt_vars,
  function(x) {
    bridge_wide %>% 
      freq_table({{ x }}) %>% 
      filter(cat == TRUE) %>% 
      freq_format("n (percent)", digits = 1) %>% 
      select(var, Overall = formatted_stats)
  }
)
```

By Group

```{r}
table_11_by_group <- map_df(
  case_mgmt_vars,
  function(x) {
    bridge_wide %>% 
      freq_table(group_f, {{ x }}) %>% 
      filter(col_cat == TRUE) %>% 
      select(row_cat, col_var, n, n_row, n_total, percent_row) %>% 
      freq_format("n (percent_row)", digits = 1)
  }
) %>% 
  select(row_cat, col_var, formatted_stats) %>% 
  pivot_wider(
    names_from = "row_cat",
    values_from = "formatted_stats"
  )
```

Merge together and create flextable object.

```{r}
table_11_ft <- table_11_overall %>% 
  left_join(table_11_by_group, by = c("var" = "col_var")) %>% 
  flextable() %>% 
  my_ft_theme()
```

Output Word document for easy copy paste

NOTES: Delete all these separate Word documents with tables after you make the big automated report.

```{r}
read_docx() %>%
  body_add_flextable(table_11_ft) %>% 
  print("table_11_ft.docx")
```

## Table 12

Table 12. Number and duration of case management sessions used.

2021-05-11: Filled in manually.

### 📄 Add bridge column tolals to Table 11

NOTE: Calculated in the Table 11 code above.

```{r}
doc <- doc %>% 
  body_replace_text_at_bkm("n_bridge_overall_12", n_bridge_overall) |> 
  body_replace_text_at_bkm("n_bridge_ucm_12", n_bridge_ucm) |>
  body_replace_text_at_bkm("n_bridge_ucm_sp_12", n_bridge_ucm_sp) |>
  body_replace_text_at_bkm("n_bridge_l2c_12", n_bridge_l2c)
```

### Case management of any type

```{r eval=FALSE}
# For testing
bridge_wide %>% 
  med_sesssions_minutes_fn("UCM") |> 
  med_sesssions_minutes_format_fn()
```

Iterate over all study groups

```{r}
sessions_minutes_any_type <- map(
  c("Overall", "UCM", "UCM+SP", "L2C"),
  ~ bridge_wide %>% 
     med_sesssions_minutes_fn(.x) |> 
     med_sesssions_minutes_format_fn()
) |> 
  # Use reduce to join them all together
  reduce(left_join, by = "measure")
```

### Case management of by type

Remove type "none" because we don't have a section for it in Table 12.

```{r}
bridge_3type <- bridge |> 
  filter(type_f != "none")
```

Calculate the total number of sessions and total duration in minutes by case management session type for each participant.

```{r}
bridge_sessions_mins_by_type_id <- bridge_3type %>%
  select(id, group_f, type_f, duration) |> 
  group_by(type_f, id) %>% 
  # Use mutate instead of summarise so that we can retain group.
  mutate(
    total_sessions = n(),
    total_minutes = sum(duration),
    row = row_number()
  ) |> 
  arrange(type_f, id) |> 
  select(type_f, id, group_f, total_sessions, total_minutes) |> 
  # Keep 1 row per combination of case management type and id
  filter(row_number() == 1) |> 
  ungroup()
```

```{r eval=FALSE}
# For testing
bridge_sessions_mins_by_type_id %>% 
  filter(type_f == "case_management") |> 
  med_sesssions_minutes_fn("UCM") |> 
  med_sesssions_minutes_format_fn()
```

#### Regular case management only

```{r}
# Iterate over all study groups
sessions_minutes_type_regular <- map(
  c("Overall", "UCM", "UCM+SP", "L2C"),
  ~ bridge_sessions_mins_by_type_id %>% 
      filter(type_f == "case_management") |> 
      med_sesssions_minutes_fn(.x) |> 
      med_sesssions_minutes_format_fn()
) |> 
  # Use reduce to join them all together
  reduce(left_join, by = "measure")
```

#### Crisis case management only

```{r}
# Iterate over all study groups
sessions_minutes_type_crisis <- map(
  c("Overall", "UCM", "UCM+SP", "L2C"),
  ~ bridge_sessions_mins_by_type_id %>% 
      filter(type_f == "crisis_management") |> 
      med_sesssions_minutes_fn(.x) |> 
      med_sesssions_minutes_format_fn()
) |> 
  # Use reduce to join them all together
  reduce(left_join, by = "measure")
```

#### Other case management only

```{r}
# Iterate over all study groups
sessions_minutes_type_other <- map(
  c("Overall", "UCM", "UCM+SP", "L2C"),
  ~ bridge_sessions_mins_by_type_id %>% 
      filter(type_f == "other") |> 
      med_sesssions_minutes_fn(.x) |> 
      med_sesssions_minutes_format_fn()
) |> 
  # Use reduce to join them all together
  reduce(left_join, by = "measure")
```

### Bind tables together

```{r}
table_12 <- tibble(measure = "Case management of any type") |> 
  bind_rows(sessions_minutes_any_type) |> 
  add_row(measure = "Regular Case Management") |> 
  bind_rows(sessions_minutes_type_regular) |> 
  add_row(measure = "Crisis Case Management") |> 
  bind_rows(sessions_minutes_type_crisis) |> 
  add_row(measure = "Other Case Management") |> 
  bind_rows(sessions_minutes_type_other)
```

### Create flextable

```{r}
table_12_ft <- flextable(table_12) %>% 
  my_ft_theme()
```

Output Word document for easy copy paste into template (DELETE)

```{r}
read_docx() %>%
  body_add_flextable(table_12_ft) %>% 
  print("table_12_ft.docx")
```

## Figure 5

Figure 2. Recruitment by month.

1. Recruitment began on April 17, 2018 and ended temporarily on March 17, 2020 due to COVID-19 and began again on July 6, 2020
2. Graph does not include participants that screened out during baseline assessment

* Can't just count calls by month because months will be combined across years.
* Can't just paste month and year together because they will be displayed in alphabetical order rather than chronological order.
* Need to create a factor for year and month.

```{r}
baseline_per_month <- master_log_screened_in %>% 
  select(date_baseline) %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  # Fill in the missing months and set n to zero.
  complete(
    date = seq.Date(as.Date("2018-04-01"), Sys.Date(), "months"), 
    fill = list(n = 0)
  )
```

```{r}
ggplot(baseline_per_month, aes(date, n, group = 1)) +
  geom_vline(xintercept = as.Date("2020-03-17"), alpha = 0.5, color = "red", linetype = "dashed") +
  geom_vline(xintercept = as.Date("2020-07-06"), alpha = 0.5, color = "red", linetype = "dashed") +
  geom_line() +
  geom_label(aes(label = n)) +
  scale_x_date("Date", date_label = "%Y-%b", 
  # Make sure the x-axis includes the earliest date and today with other breaks
  # coming at 2 month intervals.
  breaks = seq(min(baseline_per_month$date), Sys.Date(), "2 months")
  ) +
  scale_y_continuous("Number of Participants Enrolled") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Save figure for copy and paste into report

```{r}
ggsave("fig_recruitment_by_month.jpeg", width = 7, height = 4)
```

Footnotes

2021-05-11: Filled in manually.

Average recruitment by month

Overall

```{r}
recruitment_mean_overall <- recruitment %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  summarise(mean = mean(n)) |> 
  round(1) |> 
  as.character()
```

Pre-covid

```{r}
recruitment_mean_pre_covid <- recruitment %>% 
  filter(covid == "pre") %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  arrange(date) %>% 
  summarise(mean = mean(n)) |> 
  round(1) |> 
  as.character()
```

Post-covid

```{r}
recruitment_mean_post_covid <- recruitment %>% 
  filter(covid == "post") %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  arrange(date) %>% 
  summarise(mean = mean(n)) |> 
  round(1) |> 
  as.character()
```

### 📄 Add Figure 5 to Word

```{r}
# Add Figure 5. Recruitment by month.
doc <- doc %>% 
  body_replace_img_at_bkm(
    "fig_recruitment_by_month", 
    external_img("fig_recruitment_by_month.jpeg", width = 7, height = 4)
  ) |> 
  body_replace_text_at_bkm("recruitment_mean_overall", recruitment_mean_overall) |> 
  body_replace_text_at_bkm("recruitment_mean_pre_covid", recruitment_mean_pre_covid) |> 
  body_replace_text_at_bkm("recruitment_mean_post_covid", recruitment_mean_post_covid)
```

## Figure 6

Figure 3. Monthly recruitment stratified by year.

* Can't just count calls by month because months will be combined across years.
* Can't just paste month and year together because they will be displayed in alphabetical order rather than chronological order.
* Need to create a factor for year and month.

```{r}
baseline_per_month_by_year <- master_log_screened_in %>% 
  select(date_baseline) %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  # Fill in the missing months and set n to zero.
  complete(
    date = seq.Date(as.Date("2018-04-01"), Sys.Date(), "months"), 
    fill = list(n = 0)
  ) %>% 
  mutate(
    month = format(date, "%b"),
    month_f = factor(month, month.abb),
    year = year(date),
    year_f = factor(year)
  )
```

```{r}
ggplot(baseline_per_month_by_year, aes(month_f, n, group = year_f)) +
  geom_line(aes(color = year_f)) +
  scale_x_discrete("Month") +
  scale_y_continuous("Number of Participants Enrolled") +
  scale_color_discrete("Year") +
  theme_classic() 
```

Save figure for copy and paste into report

```{r}
ggsave("fig_recruitment_by_year.jpeg", width = 7, height = 4)
```

### 📄 Add Figure 6 to Word

```{r}
# Add Figure 6. Recruitment by year.
doc <- doc %>%
  body_replace_img_at_bkm(
    "fig_recruitment_by_year",
    external_img("fig_recruitment_by_year.jpeg", width = 7, height = 4)
  )
```


# 🖨Output Word document

Update the year and month in the file name dynamically

```{r}
print(
  doc, 
  paste0(Sys.Date() %>% format("%Y_%m"), " L2C Quarterly Report.docx")
)
```


# 🗑Clean up

```{r eval=FALSE}
# rm(list = ls())
```

```{r echo=FALSE}
sessionInfo()
```
