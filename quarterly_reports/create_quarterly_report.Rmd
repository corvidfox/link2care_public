---
title: "Automated Quarterly Report"
date: "2021-05-10 <br> Updated: `r Sys.Date()`"
---

# üìùInstructions

1. Connect to UTH server.

```{bash}
# Make sure you are connected to the VPN
# Don't drill all the way down to live documents because not all of the data is in live documents.
open 'smb://islgpcifs.uthouston.edu/sph_research/Link2Care/'
```

2. Unlock the Bridge Session data   

* This Bridge Session Data is in "/Volumes/Link2Care/Participant Data/Bridge Session Data/Current_Bridge Session Minutes_as of_5-4-21.xlsx". You have to download to local drive first because it's password protected (Link2Care).    
* You're not able to remove the password from this Excel document. Instead, you have to copy the information in the sheet and pasted it into a new Excel file.  
* Upload the unlocked file to the UTH server as "/Volumes/Link2Care/Participant Data/Bridge Session Data/bridge_session_minutes.xlsx"   

3. Update file paths, if necessary. 

```{r}
master_log_path <- "/Volumes/Link2Care/Live Documents/Master Log (version2).xlsx"
phone_term_path <- "/Volumes/Link2Care/Live Documents/Link2Care Phone Terminations.xlsx"
remote_path <- "/Volumes/Link2Care/Live Documents/L2C Remote Interview & Redcap Tracking.xlsx"
ema_initial_pay_approach_path <- "/Volumes/Link2Care/Live Documents/ema_data comparison.xlsx"
ema_15_day_path <- "/Volumes/Link2Care/Live Documents/15_Day_EMA.xlsx"
arrest_path <- "/Volumes/Link2Care/Participant Data/Arrest Data Requests/current_arrest_data.xlsx"
bridge_path <- "/Volumes/Link2Care/Participant Data/Bridge Session Data/bridge_session_minutes.xlsx"
```

4. Click "Run All Chunks Below" to create the  quarterly report as a Word document.


# üì¶Load packages

```{r message=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(readxl, warn.conflicts = FALSE)
library(freqtables, warn.conflicts = FALSE)
library(meantables, warn.conflicts = FALSE)
library(stringr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(forcats, warn.conflicts = FALSE)
library(purrr, warn.conflicts = FALSE)
library(ggplot2, warn.conflicts = FALSE)
library(lubridate, warn.conflicts = FALSE)
library(officer, warn.conflicts = FALSE)
library(flextable, warn.conflicts = FALSE)
```

# Load helper functions

```{r}
source("../R/get_mean_sd.R")
source("../R/flextable_helpers.R")
```


# üì•Import data 

## Master log Screened-in

```{r}
master_log_screened_in <- read_excel(
  master_log_path,
  # For testing
  # "/Users/bradcannell/Desktop/L2C_Master_Log.xlsm",
  sheet = "Screened In",
  col_names = c(
    "id", "status", "date_baseline", "date_dropped", "date_v2_scheduled", "date_v2_presented",
    "late_v2", "no_show_v2","days_v2_to_v3_scheduled","date_v3_scheduled", 
    "date_v3_presented", "late_v3", "no_show_v3", "days_v3_to_v4_scheduled", 
    "date_v4_scheduled", "date_v4_presented", "late_v4", "no_show_v4", 
    "days_4v_to_v5_scheduled", "date_v5_scheduled", "date_v5_presented", 
    "late_v5", "no_show_v5", "group", "v2_status", "dropped_status", "name_first",
    "name_middle_init",  "name_last", "gender", "race", "hispanic", "date_birth", 
    "age", "clincard_id", "n_clincards", "phone_id", "phone_number_l2c", 
    "phone_n_distributed", "care_manager", "v1", "v2", "v3", "v4", "v5", 
    "v3_r_distributed", "v3_r_completed", "v4_r_distributed", 
    "v4_r_completed","v5_r_distributed", "v5_r_completed", "v2_phone", "v3_phone",
    "v4_phone", "v5_phone"
  ),
  col_types = c(
    # Some of the dates must be imported as text because the have embedded 
    # notes (e.g., "no show")
    rep("text",2), rep("date", 4), rep("text", 2), "numeric", rep("date", 2),
    rep("text", 2), "numeric", rep("date", 2), rep("text", 2), "numeric", rep("date", 2), rep("text", 11),
    "date", "numeric", "text", "numeric", rep("text", 2), "numeric", "text", rep("text", 15)
  ),
  na = c("", ".", "N/A", "No show", "No Show"),
  skip = 1
) %>% 
  filter(!is.na(id))

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Master log screened in imported with", nrow(master_log_screened_in), "rows and",
  ncol(master_log_screened_in),
  "columns.\n"
)

# 2022-04-19: Master log screened in imported with 360 rows and 55 columns.
```

## Master log Screened-out

```{r}
master_log_screened_out <- read_excel(
  master_log_path,
  # For testing
  # "/Users/bradcannell/Desktop/L2C_Master_Log.xlsm",
  sheet = "Screened Out",
  col_names = c(
    "id", "name_full", "date_baseline", "gender",  "race", "hispanic", 
    "date_birth", "age", "reason_1", "reason_2", "reason_3", "notes"
  ),
  col_types = c(
    "text", "text", "date", rep("text", 3), "date", "numeric", 
    rep("text", 3), "skip", "text", "skip"
  ),
  skip = 1,
  na = c("", "N/A")
)

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "Master log screened out imported with", nrow(master_log_screened_out), 
  "rows and", ncol(master_log_screened_out),
  "columns.\n"
)

# 2021-11-23: Master log screened out imported with 53 rows and 12 columns.
```

## Phone terminations

```{r}
phone_terminations <- read_excel(
  phone_term_path, 
  sheet = "Terminations",
  col_names = c(
    "id", "group", "status", "v5_date", 
    "phone_1_id", "phone_1_num", "phone_1_active", "phone_1_activated_date", "phone_1_term_req_date", "phone_1_term_reason",
    "phone_2_id", "phone_2_num", "phone_2_active", "phone_2_activated_date", "phone_2_term_req_date", "phone_2_term_reason",
    "phone_3_id", "phone_3_num", "phone_3_active", "phone_3_activated_date", "phone_3_term_req_date", "phone_3_term_reason"
  ),
  col_types = c(
    rep("text", 3), "date", 
    rep("text", 3), rep("date", 2), "text",
    rep("text", 3), rep("date", 2), "text",
    rep("text", 3), rep("date", 2), "text"
  ),
  na = c("", "N/A"),
  skip = 1
)
```

## Remote Interview & Redcap Tracking Sheet

```{r}
remote <- read_excel(
  remote_path, 
  sheet = "Log",
  col_names = c(
    "id", "group", "visit", "surface_pro", "interviewer", "mode", "date_visit", 
    "date_data_transfer", "notes"
  ),
  col_types = c(
    "numeric", "text", "numeric", rep("text", 3), rep("date", 2), "text"
  ),
  na = c("", "N/A", "."),
  skip = 3
)
```

## EMA data

NOTES: Eventually, I will pull this data directly from Insight. Need to learn how to use Insight first.

Download the data from Kiteworks needed to recreate the stats for Table 9 about participants who received the initial payment approach. These stats shouldn't change over time. I just want to check them to be thorough.

* Kiteworks -> Link2Care -> EMA Comparison -> ema_data comparison.xlsx

```{r}
ema_initial_pay_approach <- read_excel(
  ema_initial_pay_approach_path,
  sheet = "Old EMA",
  range = "A2:N48",
  col_names = c(
    "id", "group", paste("emas", 1:12, sep = "_")
  ),
  col_types = c(
    "numeric", "text", rep("numeric", 12)
  )
)
```

```{r}
ema <- read_excel(
  ema_15_day_path,
  sheet = "15_Day_EMA_Log",
  col_names = c(
    "id", "group", paste("emas", 1:12, sep = "_")
  ),
  col_types = c(
    "numeric", "skip", "text", rep(c(rep("skip", 5), "numeric"), 12), rep("skip", 7)
  ),
  skip = 1
)
```

## Arrests

* Had to remove password from Excel sheet before import. Help -> Passwords -> Delete password.
* Had to do a little bit of manual removal of text from dates (i.e., "CURRENTLY IN CUSTODY") in the Excel file.

```{r}
arrest <- read_excel(
  arrest_path,
  sheet = "Sheet1",
  col_names = c(
    "id", "arrested", "date_baseline", paste("date", 1:5, sep = "_")
  ),
  col_types = c(
    "text", "text", rep("date", 6)
  ),
  na = c("", "None"),
  skip = 1
)
```

## Bridge Case Session Minutes

```{r}
bridge <- read_excel(
  bridge_path,
  sheet = "Sheet1",
  col_names = c(
    "id", "baseline_date", "v2_rand_date", "v5_sched_final_visit_date", 
    "date_session", "type", "duration", "flag_ns_v2", "flag_dropped", "notes"
  ),
  col_types = c(
    "text", rep("date", 3), "text", rep("numeric", 4), "text"
  ),
  skip = 10
)
```


# üößData management

## Master log

Combine screened in and screened out for easier data manipulation below.

```{r}
# Variable to identify which data frame each record came from
master_log_screened_in$screened_in <- 1L
master_log_screened_out$screened_in <- 0L

# Bind rows
master_log_combined <- bind_rows(master_log_screened_in, master_log_screened_out)

# Factorize screened_in variable
master_log_combined$screened_in_f <- factor(
  master_log_combined$screened_in, labels = c("Screened-Out", "Screened-In")
)
```

Coerce date columns to dates

```{r}
master_log_combined <- master_log_combined %>% 
  mutate(
    across(
      starts_with("date_"),
      ~ as.Date(as.numeric(.x), origin = "1899-12-30")
    )
  )

# 'NAs introduced by coercion' error is a result of attempting to change text 
# to numbers. For example, "no show". R converts those to NA instead. That's
# exactly what we want.
```

Recode variables and create factors

```{r}
master_log_combined <- master_log_combined %>%
  mutate(
    gender_f = factor(gender, c("M", "F", "Other"), c("Male", "Female", "Other")),
    race_3cat = case_when(
      is.na(race)  ~ NA_character_,
      race == "AA" ~ "Black or African American",
      race == "W"  ~ "White",
      TRUE         ~ "Other"
    ),
    race_3cat_f = factor(
      race_3cat,
      c("Black or African American", "White", "Other")
    ),
    hispanic_f = factor(hispanic, c("N", "Y"), c("Non-Hispanic", "Hispanic"))
  )
```

Created new screened-in and screened-out now that we are done with variable cleaning.

```{r}
screened_in  <- filter(master_log_combined, screened_in == 1L)
screened_out <- filter(master_log_combined, screened_in == 0L)
```

## Phone terminations

There were some merged rows in the Excel sheet that delineated different EMA structures. We will remove those rows from the data.   

```{r}
phone_terminations <- phone_terminations %>% 
  filter(!str_detect(id, "[a-zA-Z]"))
```

Add informed consent form (ICF) version to the data

```{r}
phone_terminations <- phone_terminations %>% 
  mutate(
    icf = case_when(
      id <= 2073 ~ 1L,
      id <= 2153 ~ 2L,
      id >= 2154 ~ 3L
    )
  )
```

Create a long version and coerce reason to factor.

```{r}
phone_terminations_long <- phone_terminations %>%
  select(id, icf, ends_with("term_reason")) %>% 
  pivot_longer(
    cols = ends_with("term_reason"),
    names_to = "phone",
    names_pattern = "phone_(\\d)_term_reason",
    names_transform = list(phone = as.integer),
    values_to = "reason"
  ) %>% 
  filter(!is.na(reason)) %>% 
  mutate(
    reason_f = factor(reason) %>% fct_infreq()
  )
```

## Remote Interview & Redcap Tracking Sheet

```{r}
remote <- remote %>% 
  mutate(
    group_f = factor(group, c("UCM", "UCM + SP", "L2C"))
  )
```

## EMA data

Keep UCM+SP and L2C rows only for EMA analysis.

```{r}
# Check for misspellings
unique(ema$group)
```

Also, only keep participants who have gone through all 12 EMA cycles. The denominator for the calculations in the analysis section below should only include participants who have been in the study long enough to complete all 12 cycles. I'm determining which rows from the ema data to keep by finding the highest id number with a non-missing value for emas_12 (on the spreadsheet: "EMAs_Completed12"). 

What is the highest id with all 12 cycles? 

```{r}
highest_id_w_12 <- ema %>% 
  filter(!is.na(emas_12)) %>% 
  pull(id) %>% 
  max()
```

```{r}
ema <- ema %>% 
  filter(group %in% c("UCM+SP", "L2C")) %>% 
  filter(id <= highest_id_w_12)
```

Setting NA to zero in 15 day EMA log

NOTES: This should be happening directly in the Excel file.

```{r}
ema <- ema %>% 
  mutate(
    across(
      emas_1:emas_12,
      ~if_else(is.na(.x), 0, .x)
    )
  )
```

Add a column for total EMAs completed

```{r}
ema_initial_pay_approach <- ema_initial_pay_approach %>% 
  rowwise() %>% 
  mutate(emas_total = sum(c_across(emas_1:emas_12))) %>% 
  ungroup()
```

```{r}
ema <- ema %>% 
  rowwise() %>% 
  mutate(emas_total = sum(c_across(emas_1:emas_12))) %>% 
  ungroup()
```

Create an variable that indicates if all 12 15-day periods have been tallied.

```{r}
ema_initial_pay_approach <- ema_initial_pay_approach %>%
  rowwise() %>% 
  mutate(n_periods = sum(!is.na(c_across(emas_1:emas_12)))) %>% 
  ungroup()
```

```{r}
ema <- ema %>% 
  rowwise() %>% 
  mutate(n_periods = sum(!is.na(c_across(emas_1:emas_12)))) %>% 
  ungroup()
```

Create a combined version of the data set

```{r}
ema_initial_pay_approach <- ema_initial_pay_approach %>% 
  mutate(pay_approach = "Initial")

ema <- ema %>% 
  mutate(pay_approach = "Revised")

ema_combined <- ema_initial_pay_approach %>% 
  bind_rows(ema)
```

Make a long version of the data.

```{r}
ema_combined_long <- ema_combined %>% 
  pivot_longer(
    emas_1:emas_12,
    names_to = "cycle",
    names_prefix = "emas_",
    values_to = "n_completed"
  ) %>% 
  mutate(cycle_f = factor(cycle, 1:12))
```

## Arrests

Merge L2C group into the arrest data.

```{r}
arrest <- arrest %>% 
  left_join(
    screened_in %>% 
      select(id, group),
    by = "id"
  ) %>% 
  select(id, group, everything())
```

## Bridge Case Session Minutes

Remove text from date columns and convert to dates.

```{r}
bridge <- bridge %>% 
  mutate(
    date_session = str_remove_all(date_session, "[A-z]|[a-z]"),
    date_session = as.numeric(date_session),
    date_session = as.Date(date_session, origin = "1899-12-30")
  )
```

Remove instructions from "notes" column of rows 1 and 2.

```{r}
bridge[1, "notes"] <- NA_character_
bridge[2, "notes"] <- NA_character_
```

Drop blank rows. In the Excel sheet there were some blank spacer rows.

* `c_across()` doesn't work with columns of different types. So, creating missing data dummy variables.

```{r} 
bridge <- bridge %>%
  # Create missing data dummy variables
  mutate(
    across(
      everything(),
      is.na,
      .names = "{col}_miss"
    )
  ) %>% 
  # Sum missing data dummy variables
  rowwise() %>% 
  mutate(
    n_missing = sum(c_across(ends_with("_miss")))
  ) %>% 
  ungroup() %>% 
  # Drop missing data dummy variables
  select(-ends_with("_miss")) %>% 
  # Drop rows that are missing in every column
  filter(!n_missing == 8)
```

Carry forward id numbers. In the Excel sheet, the id number is only given in the first row of each set of rows for each participant.

```{r}
bridge <- bridge %>%
  # Carry forward id
  fill(id) %>% 
  group_by(id) %>% 
  # Carry forward other variables grouped by id
  fill(baseline_date, v2_rand_date, v5_sched_final_visit_date) %>% 
  ungroup()
```

Create a factor for session type and a dummy variable for case management.

```{r}
bridge <- bridge %>% 
    mutate(
    # Change NA to None for type
    type = if_else(is.na(type), 4, type),
    # Create factor version
    type_f = factor(
      type,
      1:4,
      c("case_management", "crisis_management", "other", "none")
    ),
    # Create dummy variable for case management
    case_management = type_f == "case_management"
  )
```

Merge L2C group into the Bridge data.

```{r}
bridge <- bridge %>%
  left_join(
    screened_in %>% 
      select(id, group),
    by = "id"
  ) %>% 
  select(id, group, everything())
```

Create an "other" group to capture groups other than UCM, UCM+SP, and L2C.

```{r}
bridge <- bridge %>%
  mutate(
    group_f = factor(group, c("UCM", "UCM+SP", "L2C")),
    group_f = fct_explicit_na(group_f, na_level = "Other")
  )
```

Remove rows with participants who are missing a V2 randomization date.

* James has a footnote that says, "Excludes participants who missed randomization (V2) date (n=16)." So, I will filter out people who are missing a V2 randomization date.

```{r}
bridge %>% 
  filter(is.na(v2_rand_date)) %>% 
  nrow()
```

There are four participants with a missing date for V2 randomization. They will be removed from the analyses below.

```{r}
bridge <- bridge %>% 
  filter(!is.na(v2_rand_date))
```

Create a dummy variable for 
* "Used at least one session of regular case management."
* "Used at least one session of crisis case management."
* "Used at least one session of other case management."
* "Used no forms of Bridge case management."

```{r}
bridge <- bridge %>%
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = sum(type %in% 1:3),
    total_minutes = sum(duration, na.rm = TRUE),
    any_case_management = any(type_f == "case_management"),
    any_crisis_management = any(type_f == "crisis_management"),
    any_other = any(type_f == "other"),
    all_none = all(type_f == "none")
  ) %>% 
  ungroup()
```

Create a "wide" version of the data with one row per participant.

```{r}
bridge_wide <- bridge %>% 
  filter(row == 1)
```

Keep only participants in L2C, UCM, and UCM+SP groups for analysis.

```{r}
bridge <- bridge %>% 
  filter(group_f %in% c("L2C", "UCM", "UCM+SP"))
```

```{r}
bridge_wide <- bridge_wide %>% 
  filter(group_f %in% c("L2C", "UCM", "UCM+SP"))
```

## Recruitment

```{r}
recruitment <- master_log_screened_in %>% 
  select(date_baseline) %>% 
  mutate(
    covid = if_else(date_baseline < "2020-03-17", "pre", "post")
  )
```


# üìàAnalysis

## üìå Note on Table names

You should probably use descriptive names for these tables instead of numbers. The numbers may change over time. You might also want to organize this Rmd file by sections that match the quarterly report. But maybe not.

## Table 1

Table 1. Demographic characteristics of all people screened for study inclusion.

### Screened-in

Number of participants screened_in

```{r}
n_screened_in <- nrow(screened_in)
```

```{r}
t1_cont_stats_si <- master_log_combined %>%
  filter(screened_in == 1) %>% 
  get_mean_sd(age, 1) %>% 
  # Add blank row below
  add_row(var = "", cat = "", formatted_stats = "")
```

**NOTES:** Right now, I have to use purrr::map_df to use freq_table over multiple categorical variables. In the future, I'd like to either create a wrapper function for this or make a really good vignette for using this method. Created issues in freqtables (#23, #36).

**NOTES:** Create a function to add an empty row. For now, I'm just adding this to the data frame manually. I've asked if there is a way to do this in flextable on [StackOverflow](https://stackoverflow.com/questions/64932726/add-a-blank-row-in-flextable). I've also created an issue in freqtables to create a wrapper function to do this (#35).

```{r}
# Loop over all categorical vars
t1_cat_stats_si <- map_df(
  quos(gender_f, race_3cat_f, hispanic_f), 
  function(x) {
    master_log_combined %>%
      filter(screened_in == 1) %>% 
      freq_table({{x}}) %>%
      freq_format(recipe = "n (percent)", digits = 1) %>%
      select(var, cat, formatted_stats) %>%
      # Add a row with the var name only
      add_row(var = quo_name(x), .before = 1) %>% 
      # Add blank row below
      add_row(var = "", cat = "", formatted_stats = "")
  }
) %>% 
  # Drop the final empty row
  slice(-n())
```

Add group n and row bind cont and cat stats

```{r}
table_1_si <- t1_cont_stats_si %>% 
  bind_rows(t1_cat_stats_si) %>% 
  rename(screened_in = formatted_stats)
```

### Screened-out

Number of participants screened_out

```{r}
n_screened_out <- nrow(screened_out)
```

```{r}
t1_cont_stats_so <- master_log_combined %>%
  filter(screened_in == 0) %>% 
  get_mean_sd(age, 1) %>% 
  # Add blank row below
  add_row(var = "", cat = "", formatted_stats = "")
```

```{r}
# Loop over all categorical vars
t1_cat_stats_so <- map_df(
  quos(gender_f, race_3cat_f, hispanic_f), 
  function(x) {
    master_log_combined %>%
      filter(screened_in == 0) %>% 
      freq_table({{x}}) %>%
      freq_format(recipe = "n (percent)", digits = 1) %>%
      select(var, cat, formatted_stats) %>%
      # Add a row with the var name only
      add_row(var = quo_name(x), .before = 1) %>% 
      # Add blank row below
      add_row(var = "", cat = "", formatted_stats = "")
  }
) %>% 
  # Drop the final empty row
  slice(-n())
```

Add group n and row bind cont and cat stats

```{r}
# table_1_so <- tibble(
#   var = "",
#   cat = "",
#   formatted_stats = paste0("(n = ", n_screened_out, ")")
# ) %>% 
#   bind_rows(t1_cont_stats_so) %>% 
#   bind_rows(t1_cat_stats_so) %>% 
#   rename(screened_out = formatted_stats)
```

```{r}
table_1_so <- t1_cont_stats_so %>% 
  bind_rows(t1_cat_stats_so) %>% 
  rename(screened_out = formatted_stats)
```


### Combined

Combined screened-in and screened-out

```{r}
table_1 <- bind_cols(
  table_1_si,
  table_1_so %>%
    select(screened_out)
)
```

Slide categories over

```{r}
table_1 <- table_1 %>%
  mutate(
    # Slide categories over
    var = if_else(is.na(cat), var, cat)
  ) %>%
  select(-cat)
```

Create flextable object

### üìå Note on flextable helpers

2021-05-11: You started an R script called flextable_helpers and started pulling some of the stuff out into helper functions. You can probably do even more of that in the future. For example, the "compose" code in the chunk below.

```{r}
table_1_ft <- flextable(table_1) %>% 
  
  # Change column widths
  width(width = 2.33) %>%
  
  # Format the header row
  set_header_labels(
    var = "Characteristic",
    screened_in = "Screened-in",
    screened_out = "Screened-out"
  ) %>%
  bold(part = "header") %>%
  
  # Add group n's
  add_header(top = FALSE, 
    screened_in = paste0("(n = ", n_screened_in, ")"),
    screened_out = paste0("(n = ", n_screened_out, ")")
  ) %>% 
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  
  # Adjust the borders around the header
  border_remove() %>% 
  hline_top(part = "header", border = fp_border(width = 1)) %>%
  hline_bottom(part = "header", border = fp_border(width = 1)) %>%
  
  # # Bold variable names
  compose(
    i = 1, j = 1,
    value = as_paragraph(
      as_chunk("Age in years", props = header_fmt), ", mean (sd)"
    )
  ) %>%
  compose(
    i = 3, j = 1,
    value = as_paragraph(
      as_chunk("Gender", props = header_fmt), ", n(%)"
    )
  ) %>%
  compose(
    i = 8, j = 1,
    value = as_paragraph(
      as_chunk("Race", props = header_fmt), ", n(%)"
    )
  ) %>%
  compose(
    i = 13, j = 1,
    value = as_paragraph(
      as_chunk("Ethnicity", props = header_fmt), ", n(%)"
    )
  ) %>%
  
  # Indent categories
  padding(i = c(4:6, 9:11, 14:15), j = 1, padding.left = 10) %>%

  # Left align first column
  align(j = 1, align = "left", part = "body") %>%

  # Center align second and third column
  align(j = 2:3, align = "center", part = "all") %>%

  # Resize bottom border
  hline_bottom(border = fp_border(width = 1)) %>% 
  
  # Style with my theme
  # Remove vertical cell padding and TNR 11 font
  my_ft_theme() 

# table_1_ft
```

Clean up

```{r}
rm(
  t1_cat_stats_si, t1_cat_stats_so, t1_cont_stats_si, t1_cont_stats_so, table_1,
  table_1_si, table_1_so
)
```

## Table 2

Table 2. Distribution of reasons for screen-out

```{r}
unique(screened_out$reason_1)
```

```{r}
table_2 <- screened_out %>%
  pivot_longer(
    reason_1:reason_3,
    names_to = "reason_number",
    names_prefix = "reason_",
    values_to = "reason"
  ) %>% 
  filter(!is.na(reason)) %>% 
  freq_table(reason) %>% 
  arrange(desc(n)) %>% 
  # Get n from n_total column
  add_row(cat = "Total", n = max(.$n_total), percent = 100.0) %>% 
  freq_format("n (percent)", digits = 1) %>%
  select(cat, formatted_stats)
```

Create flextable object

```{r}
table_2_ft <- flextable(table_2) %>% 
  
  # Change column widths
  width(width = 3.5) %>% 
  
  # Format the header row
  set_header_labels(
    cat = "Reason For Screen Out",
    formatted_stats = "n (%)"
  ) %>%
  bold(part = "header") %>%
  
  # Adjust the borders around the header
  border_remove() %>% 
  hline_top(part = "header", border = fp_border(width = 1)) %>%
  hline_bottom(part = "header", border = fp_border(width = 1)) %>% 
  
  # Center align second column
  align(j = 2, align = "center", part = "all") %>%

  # Adjust bottom borders
  hline(i = 7, border = fp_border(width = 1)) %>% 
  hline_bottom(border = fp_border(width = 1)) %>% 
  
  # Style with my theme
  # Remove vertical cell padding and TNR 11 font
  my_ft_theme()
  
# table_2_ft
```

### üìåNOTES on automation

2021-05-11. I spent an entire day getting table 1 formatted correctly. At this point, I'm going to try to improve the code by cleaning up the data management and the organization of the code. I probably won't have time to automate all the output with flextable and officer. That will have to wait for the next report. 

Also, delete all these separate Word documents with tables after you make the big automated report.

## Table 3

Table 3. Payment card and phone loss. 

2021-05-11: Filled in manually.

Total number of ClinCards distributed

```{r}
sum(master_log_screened_in$n_clincards, na.rm = TRUE)
```

Total number of participants with ClinCard replacements

```{r}
sum(master_log_screened_in$n_clincards > 1, na.rm = TRUE)
```

Total number of phones distributed

```{r}
sum(master_log_screened_in$phone_n_distributed, na.rm = TRUE)
```

Total number of participants with phone replacements

```{r}
sum(master_log_screened_in$phone_n_distributed > 1, na.rm = TRUE)
```

Number of ClinCard replacements

```{r}
master_log_screened_in %>% 
  freq_table(n_clincards)
```

## Table 4

Table 4. Phone distribution and replacement.

2021-05-11: Filled in manually.

Total # of phones distributed overall

```{r}
sum(master_log_screened_in$phone_n_distributed, na.rm = TRUE)
```

Total # of participants in phone groups

NOTES: 2020-12-03, from James, Phone groups are L2C and UCM+SP only.

```{r}
master_log_screened_in %>% 
  filter(group == "L2C" | group == "UCM+SP") %>% 
  nrow()
```

Total number of participants with phone replacements

```{r}
sum(master_log_screened_in$phone_n_distributed > 1, na.rm = TRUE)
```

Number of participants w/ phone replacement (UCM+SP)

```{r}
master_log_screened_in %>% 
  filter(group == "UCM+SP") %>% 
  summarise(sum(phone_n_distributed > 1, na.rm = TRUE))
```

Number of participants w/ phone replacement (L2C)

```{r}
master_log_screened_in %>% 
  filter(group == "L2C") %>% 
  summarise(sum(phone_n_distributed > 1, na.rm = TRUE))
```

Number of participants in UCM+SP w/ >1 phone replacement

```{r}
master_log_screened_in %>% 
  filter(group == "UCM+SP") %>% 
  summarise(sum(phone_n_distributed > 2, na.rm = TRUE))
```

Number of Participants in L2C w/ >1 phone replacement

```{r}
master_log_screened_in %>% 
  filter(group == "L2C") %>% 
  summarise(sum(phone_n_distributed > 2, na.rm = TRUE))
```

Footnote: Number of participants had phone replaced 1 time (2 phones per participant total).

```{r}
sum(master_log_screened_in$phone_n_distributed == 2, na.rm = TRUE)
```

Footnote: N by group and ids for 2 or more phone replacements due to malfunctions in the UCM+SP and L2C groups

The footnote under Table 4 that I'm trying to recreate says, "3 UCM+SP participants (2010, 2165, 2168) & 3 L2C participants (2099, 2124, 2189) replaced phone 2 times (3 phones per participant total) due to phone malfunctions."

NOTES: I tried importing the issues and notes file to see if I could recreate this information. I could not find consistent use of a word like "malfunction" that I could search for to systematically update this number. Therefore, I'm going to leave a comment on the report asking James to update it manually.

NOTES: 2020-12-10, James and Addison changed how "Defective" is coded. It should appear more often now.

NOTES: 2021-05-11, I took this footnote out of the report. I don't think it's that informative. If you need the code for it, you can look through previous versions on GitHub.

## Figure 1

Figure 1. Reasons for phone terminations overall.

```{r}
n_phone_terminations <- phone_terminations_long %>% 
  filter(!is.na(reason_f)) %>% 
  nrow()
```

```{r}
fig_1 <- phone_terminations_long %>% 
  filter(!is.na(reason_f)) %>% 
  freq_table(reason_f) %>% 
  mutate(
    cat_f = factor(cat),
    cat_f = fct_reorder(cat_f, n)
  ) %>% 
  ggplot(aes(cat_f, n)) +
    geom_bar(stat = "identity", fill = "#00519B") +
    geom_label(aes(label = n)) +
    coord_flip() +
    labs(
      # X in plot, but Y before flipping coordinates
      y = "Number of Phones"
    ) +
    theme_classic() +
    theme(
      axis.title.y = element_blank(),
      axis.text.y = element_text(color = "black"),
      axis.text.x = element_text(color = "black")
    ) 
```

Save figure for copy and paste into report

```{r}
ggsave("fig_1.jpeg", width = 7, height = 4)
```

## Table 5

Table 5. Reasons for phone terminations by informed consent form iteration

2021-05-11: Filled in manually. Can come back and do this one line table 6 below if I don't fully automate right away.

By ICF. ICF 1 and 2 should not change over time.

```{r}
table_5 <- phone_terminations_long %>%
  filter(!is.na(reason_f)) %>% 
  # Arrange reasons in the same order they appear in the table
  mutate(reason_ordered = fct_relevel(
    reason_f,
    "Stolen", "Completed Study", "Non-Compliance", "Lost", "Defective", 
    "Sold or Gifted", "Returned to Staff", "Broken"
  )) %>% 
  freq_table(icf, reason_ordered) %>%
  freq_format("n (percent_row)", digits = 1) %>% 
  select(row_cat, col_cat, formatted_stats) %>% 
  pivot_wider(
    names_from = "row_cat",
    values_from = c("formatted_stats")
  )
```

Create flextable

```{r}
table_5_ft <- flextable(table_5) %>% 
  my_ft_theme()
```

Output Word document for easy copy paste into template (DELETE)
* Bold  total manually.

```{r}
read_docx() %>%
  body_add_flextable(table_5_ft) %>% 
  print("table_5_ft.docx")
```

Add a total row to the bottom of the table. Again, filling this in by hand for now.

```{r}
phone_terminations_long %>%
  filter(!is.na(reason_f)) %>%
  freq_table(icf, reason_f) %>% 
  group_by(row_cat) %>% 
  filter(row_number() == 1) %>% 
  select(row_var:row_cat, n_row, n_total)
```

NOTES: 
1. Figure out why this doesn't add up to the total number of phone terminations in table 4 and figure 1. I'm assuming there are two terminations with no reason given. 
2. Table 5 "non-compliance" and "completed" n for ICF#1 needs to be updated manually. This is done to show how many PT's would have been terminated if non-compliance protocol was in place during IFC#1 and compare to ICF#2 and #3. 

## Table 6

Table 6. Number and percent of participants per L2C group.

2021-05-11: Filled in manually.

Create a tibble that contains randomized participants only.

```{r}
# Data check. As of 2021-12-04, the group column in the master log should only
# contain "L2C", "UCM+SP", "UCM", and NA.
if (!identical(unique(master_log_screened_in$group), c("L2C", "UCM+SP", "UCM", NA))) {
  stop("We expect the group column in the master log to contain only L2C, ", 
       "UCM+SP, UCM, and NA. Instead, it contains ", 
       paste0(unique(master_log_screened_in$group), collapse = ", "),
       ". This condition is tested in the Table 6 section of code.")
}
```

```{r}
master_log_randomized <- filter(master_log_screened_in, !is.na(group))
n_randomized <- nrow(master_log_randomized)
```

```{r}
# Use participants randomized to a L2C group only.
table_6 <- master_log_randomized %>%
  # Order groups in the same order they appear in the table
  mutate(
    group_ordered = factor(
      group,
      c("UCM+SP", "UCM", "L2C"),
      c("UCM+SP", "UCM", "L2C")
    )
  ) %>%
  freq_table(group_ordered) %>% 
  freq_format("n (percent)", digits = 1) %>%
  select(cat, formatted_stats) %>% 
  rename(`L2C Group` = cat, `n (percent)` = formatted_stats)
```

Create flextable

```{r}
table_6_ft <- flextable(table_6) %>% 
  my_ft_theme()
```

Output Word document for easy copy paste into template (DELETE)
* Bold  total manually.

```{r}
read_docx() %>%
  body_add_flextable(table_6_ft) %>% 
  print("table_6_ft.docx")
```

## Table 7

Table 7. Number and percent of participants who completed visits 1 through 5.

```{r}
table_7_overall <- master_log_screened_in %>% 
  pivot_longer(
    cols = v1:v5,
    names_to = "visit",
    names_prefix = "v",
    values_to = "complete"
  ) %>% 
  # Coerce complete to numeric to calculate prop below
  mutate(complete = if_else(complete == "Yes", 1L, 0L)) %>% 
  group_by(visit) %>% 
  summarise(
    n = sum(complete == 1, na.rm = TRUE),
    mean = mean(complete, na.rm = TRUE),
    percent = round(mean * 100, 1),
    .groups = "drop"
  ) %>% 
  freq_format("n (percent)", digits = 1) %>% 
  select(visit, formatted_stats)
```

Add visit compliance Excluding No Show V2 PTs

```{r}
table_7_w_v2 <- master_log_screened_in %>%
  filter(v2 == "Yes") %>% 
  pivot_longer(
    cols = v1:v5,
    names_to = "visit",
    names_prefix = "v",
    values_to = "complete"
  ) %>% 
  # Coerce complete to numeric to calculate prop below
  mutate(complete = if_else(complete == "Yes", 1L, 0L)) %>%
  group_by(visit) %>% 
  summarise(
    n = sum(complete == 1, na.rm = TRUE),
    mean = mean(complete, na.rm = TRUE),
    percent = round(mean * 100, 1),
    .groups = "drop"
  ) %>% 
  freq_format("n (percent)", digits = 1) %>% 
  select(visit, formatted_stats)
```

Merged 7 overall and 7 with V2 together and make flextable.

```{r}
table_7_ft <- table_7_overall %>% 
  left_join(table_7_w_v2, by = "visit") %>% 
  flextable() %>% 
  my_ft_theme()
```

Output Word document for easy copy paste

NOTES: Delete all these separate Word documents with tables after you make the big automated report.

```{r}
read_docx() %>%
  body_add_flextable(table_7_ft) %>% 
  print("table_7_ft.docx")
```

## Table 8

Table 8. COVID-19 phone interviews (N={see below}) since protocol change on 3/17/2020. 

2021-05-11: Filled in manually.

Total interviews by mode (phone vs. redcap)

```{r}
remote %>% 
  count(mode) %>% 
  add_row(mode = "Total", n = sum(.$n))
```

Total

```{r}
remote %>% 
  summarise(
    n = n(), # 81
    n_unique = length(unique(id)) # 58
  )
```

By group

```{r}
count(remote, group_f) %>% 
  add_row(group_f = "Total", n = sum(.$n))
```

By visit

```{r}
count(remote, visit)
```

## Table 9

Table 9. Ecological Momentary Assessment (EMA) completion metrics by 15-day cycle and payment approach.

NOTES: Rather than do this analysis this way, it might be interesting to graph the median completed by period. According to Jenn (2020-12-14), the important thing to show here is that: 1.) How many EMAs are being completed, 2.) Important piece is to show old payment approach vs. new payment approach, and 3.) Show the bimodal distribution.

Table of emas completed by cycle and payment approach

```{r rows.print=12}
table_9_medians <- ema_combined_long %>% 
  group_by(cycle_f, pay_approach) %>% 
  summarise(
    median = median(n_completed) %>% format(nsmall = 1),
    .groups = "drop"
  ) %>% 
  pivot_wider(
    names_from = "pay_approach",
    values_from = "median"
  )
```

Percent who completed zero emas by cycle and payment approach

```{r rows.print=12}
table_9_percents <- ema_combined_long %>% 
  group_by(cycle_f, pay_approach) %>% 
  summarise(
    rows = n(),
    zeros = sum(n_completed == 0),
    seven_plus = sum(n_completed == 7),
    .groups = "drop"
  ) %>% 
  mutate(
    percent_zero = round(zeros / rows * 100, 1) %>% format(nsmall = 1),
    percent_seven_plus = round(seven_plus / rows * 100, 1) %>% format(nsmall = 1),
    n_percent_zero = paste0(zeros, " (", percent_zero, ")"),
    n_percent_seven_plus = paste0(seven_plus, " (", percent_seven_plus, ")")
  ) %>% 
  select(cycle_f, pay_approach, n_percent_zero, n_percent_seven_plus) %>% 
  pivot_wider(
    names_from = "pay_approach",
    values_from = c("n_percent_zero", "n_percent_seven_plus")
  )
```

Merge medians and percentges together into a single table, and create flextable object.

```{r}
table_9_ft <- table_9_medians %>% 
  left_join(table_9_percents, by = "cycle_f") %>% 
  flextable() %>% 
   my_ft_theme()
```

Totals

```{r}
ema_combined_long %>% 
  group_by(pay_approach) %>% 
  summarise(
    median = median(n_completed) %>% format(nsmall = 1),
    .groups = "drop"
  ) %>% 
  pivot_wider(
    names_from = "pay_approach",
    values_from = "median"
  )
```

```{r rows.print=12}
ema_combined_long %>% 
  group_by(pay_approach) %>% 
  summarise(
    rows = n(),
    zeros = sum(n_completed == 0),
    seven_plus = sum(n_completed == 7),
    .groups = "drop"
  ) %>% 
  mutate(
    percent_zero = round(zeros / rows * 100, 1) %>% format(nsmall = 1),
    percent_seven_plus = round(seven_plus / rows * 100, 1) %>% format(nsmall = 1),
    n_percent_zero = paste0(zeros, " (", percent_zero, ")"),
    n_percent_seven_plus = paste0(seven_plus, " (", percent_seven_plus, ")")
  ) %>% 
  select(pay_approach, n_percent_zero, n_percent_seven_plus) %>% 
  pivot_wider(
    names_from = "pay_approach",
    values_from = c("n_percent_zero", "n_percent_seven_plus")
  )
```

Output Word document for easy copy paste

NOTES: Delete all these separate Word documents with tables after you make the big automated report.

```{r}
read_docx() %>%
  body_add_flextable(table_9_ft) %>%
  print("table_9_ft.docx")
```

Footnote 1: "IPA = Initial payment approach. Includes PTs 2001-2073 and included payments at study visits only (n = 47)." This doesn't change.

Footnote 2: "Revised payment approach. Includes PTs 2074 and above (n = XXX). The protocol change became effective on 11/21/2018."

```{r}
ema %>% filter(id > 2074) %>% nrow()
```

## Table 10

Table 10. Arrests by treatment arm 12 months after enrollment.

2021-05-11: Filled in manually.

Overall

```{r}
arrest %>% 
  freq_table(arrested) %>% 
  freq_format("n (percent)", digits = 2) %>% 
  select(var, cat, formatted_stats, n_total)
```

By L2C group

```{r}
arrest %>% 
  freq_table(group, arrested) %>% 
  filter(col_cat == "Yes") %>% 
  arrange(desc(n)) %>% 
  freq_format("n (percent_row)", digits = 1) %>% 
  select(row_cat, formatted_stats, n_row)
```

## Table 12

Table 12. Number and percent of participants who used Bridge case management.

2021-05-11: Filled in manually.

Column totals

```{r}
bridge %>% 
  filter(row == 1) %>% 
  count(group_f) %>% 
  mutate(cum = cumsum(n))
```

This table only needs one row per id.

Include only randomized participants.

```{r}
case_mgmt_vars <- quos(
  any_case_management, any_crisis_management, any_other, all_none
)
```

Overall

```{r}
table_12_overall <- map_df(
  case_mgmt_vars,
  function(x) {
    bridge_wide %>% 
      freq_table({{ x }}) %>% 
      filter(cat == TRUE) %>% 
      freq_format("n (percent)", digits = 1) %>% 
      select(var, formatted_stats)
  }
)
```

By Group

```{r}
table_12_by_group <- map_df(
  case_mgmt_vars,
  function(x) {
    bridge_wide %>% 
      freq_table(group_f, {{ x }}) %>% 
      filter(col_cat == TRUE) %>% 
      select(row_cat, col_var, n, n_row, n_total, percent_row) %>% 
      freq_format("n (percent_row)", digits = 1)
  }
) %>% 
  select(row_cat, col_var, formatted_stats) %>% 
  pivot_wider(
    names_from = "row_cat",
    values_from = "formatted_stats"
  )
```

Merge together and create flextable object.

```{r}
table_12_ft <- table_12_overall %>% 
  left_join(table_12_by_group, by = c("var" = "col_var")) %>% 
  flextable() %>% 
  my_ft_theme()
```

Output Word document for easy copy paste

NOTES: Delete all these separate Word documents with tables after you make the big automated report.

```{r}
read_docx() %>%
  body_add_flextable(table_12_ft) %>% 
  print("table_12_ft.docx")
```

## Table 13

Table 13. Number and duration of case management sessions used.

2021-05-11: Filled in manually.

Case management of any type

Overall

```{r}
bridge_wide %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes),
    minutes_min = min(total_minutes),
    minutes_max = max(total_minutes)
  ) %>%
  pivot_longer(
    everything(),
    names_to = c(".value", "measure"),
    names_sep = "_",
    values_to = "stat"
  )
```

UCM

```{r}
bridge_wide %>% 
  filter(group_f == "UCM") %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes),
    minutes_min = min(total_minutes),
    minutes_max = max(total_minutes)
  ) %>%
  pivot_longer(
    everything(),
    names_to = c(".value", "measure"),
    names_sep = "_",
    values_to = "stat"
  )
```

UCM+SP

```{r}
bridge_wide %>% 
  filter(group_f == "UCM+SP") %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes),
    minutes_min = min(total_minutes),
    minutes_max = max(total_minutes)
  ) %>%
  pivot_longer(
    everything(),
    names_to = c(".value", "measure"),
    names_sep = "_",
    values_to = "stat"
  )
```

L2C

```{r}
bridge_wide %>% 
  filter(group_f == "L2C") %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes),
    minutes_min = min(total_minutes),
    minutes_max = max(total_minutes)
  ) %>%
  pivot_longer(
    everything(),
    names_to = c(".value", "measure"),
    names_sep = "_",
    values_to = "stat"
  )
```

```{r}
bridge %>% 
  filter(type_f == "case_management") %>% 
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = n(),
    total_minutes = sum(duration)
  ) %>% 
  ungroup() %>% 
  filter(row == 1) %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes),
    minutes_min = min(total_minutes),
    minutes_max = max(total_minutes)
  ) %>% 
  pivot_longer(
    everything(),
    names_to = c(".value", "measure"),
    names_sep = "_",
    values_to = "stat"
  )
```

```{r}
bridge %>% 
  filter(type_f == "case_management") %>% 
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = n(),
    total_minutes = sum(duration)
  ) %>% 
  ungroup() %>% 
  filter(row == 1) %>% 
  group_by(group_f) %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes),
    minutes_min = min(total_minutes),
    minutes_max = max(total_minutes),
    .groups = "drop"
  ) 
```

```{r}
bridge %>% 
  filter(type_f == "crisis_management") %>% 
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = n(),
    total_minutes = sum(duration)
  ) %>% 
  ungroup() %>% 
  filter(row == 1) %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes, na.rm = TRUE),
    minutes_min = min(total_minutes, na.rm = TRUE),
    minutes_max = max(total_minutes, na.rm = TRUE)
  ) %>% 
  pivot_longer(
    everything(),
    names_to = c(".value", "measure"),
    names_sep = "_",
    values_to = "stat"
  )
```

```{r}
bridge %>% 
  filter(type_f == "crisis_management") %>% 
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = n(),
    total_minutes = sum(duration)
  ) %>% 
  ungroup() %>% 
  filter(row == 1) %>% 
  group_by(group_f) %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes, na.rm = TRUE),
    minutes_min = min(total_minutes, na.rm = TRUE),
    minutes_max = max(total_minutes, na.rm = TRUE),
    .groups = "drop"
  ) 
```

```{r}
bridge %>% 
  filter(type_f == "other") %>% 
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = n(),
    total_minutes = sum(duration)
  ) %>% 
  ungroup() %>% 
  filter(row == 1) %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes, na.rm = TRUE),
    minutes_min = min(total_minutes, na.rm = TRUE),
    minutes_max = max(total_minutes, na.rm = TRUE)
  ) %>% 
  pivot_longer(
    everything(),
    names_to = c(".value", "measure"),
    names_sep = "_",
    values_to = "stat"
  )
```

```{r}
bridge %>% 
  filter(type_f == "other") %>% 
  group_by(id) %>% 
  mutate(
    row = row_number(),
    total_sessions = n(),
    total_minutes = sum(duration)
  ) %>% 
  ungroup() %>% 
  filter(row == 1) %>% 
  group_by(group_f) %>% 
  summarise(
    sessions_median = median(total_sessions),
    sessions_min = min(total_sessions),
    sessions_max = max(total_sessions),
    minutes_median = median(total_minutes, na.rm = TRUE),
    minutes_min = min(total_minutes, na.rm = TRUE),
    minutes_max = max(total_minutes, na.rm = TRUE),
    .groups = "drop"
  ) 
```

## Figure 2

Figure 2. Recruitment by month.

1. Recruitment began on April 17, 2018 and ended temporarily on March 17, 2020 due to COVID-19 and began again on July 6, 2020
2. Graph does not include participants that screened out during baseline assessment

* Can't just count calls by month because months will be combined across years.
* Can't just paste month and year together because they will be displayed in alphabetical order rather than chronological order.
* Need to create a factor for year and month.

```{r}
baseline_per_month <- master_log_screened_in %>% 
  select(date_baseline) %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  # Fill in the missing months and set n to zero.
  complete(
    date = seq.Date(as.Date("2018-04-01"), Sys.Date(), "months"), 
    fill = list(n = 0)
  )
```

```{r}
ggplot(baseline_per_month, aes(date, n, group = 1)) +
  geom_vline(xintercept = as.Date("2020-03-17"), alpha = 0.5, color = "red", linetype = "dashed") +
  geom_vline(xintercept = as.Date("2020-07-06"), alpha = 0.5, color = "red", linetype = "dashed") +
  geom_line() +
  geom_label(aes(label = n)) +
  scale_x_date("Date", date_label = "%Y-%b", 
  # Make sure the x-axis includes the earliest date and today with other breaks
  # coming at 2 month intervals.
  breaks = seq(min(baseline_per_month$date), Sys.Date(), "2 months")
  ) +
  scale_y_continuous("Number of Participants Enrolled") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Save figure for copy and paste into report

```{r}
ggsave("fig_2.jpeg", width = 7, height = 4)
```

Footnotes

2021-05-11: Filled in manually.

Average recruitment by month

Overall

```{r}
recruitment %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  summarise(mean = mean(n))
```

Pre-covid

```{r}
recruitment %>% 
  filter(covid == "pre") %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  arrange(date) %>% 
  summarise(mean = mean(n))
```

Post-covid

```{r}
recruitment %>% 
  filter(covid == "post") %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  arrange(date) %>% 
  summarise(mean = mean(n))
```

## Figure 3

Figure 3. Monthly recruitment stratified by year.

* Can't just count calls by month because months will be combined across years.
* Can't just paste month and year together because they will be displayed in alphabetical order rather than chronological order.
* Need to create a factor for year and month.

```{r}
baseline_per_month_by_year <- master_log_screened_in %>% 
  select(date_baseline) %>% 
  mutate(year_month = format(date_baseline, "%Y-%b")) %>% 
  count(year_month) %>% 
  mutate(date = ymd(year_month, truncated = 1)) %>% 
  # Fill in the missing months and set n to zero.
  complete(
    date = seq.Date(as.Date("2018-04-01"), Sys.Date(), "months"), 
    fill = list(n = 0)
  ) %>% 
  mutate(
    month = format(date, "%b"),
    month_f = factor(month, month.abb),
    year = year(date),
    year_f = factor(year)
  )
```

```{r}
ggplot(baseline_per_month_by_year, aes(month_f, n, group = year_f)) +
  geom_line(aes(color = year_f)) +
  scale_x_discrete("Month") +
  scale_y_continuous("Number of Participants Enrolled") +
  scale_color_discrete("Year") +
  theme_classic() 
```

Save figure for copy and paste into report

```{r}
ggsave("fig_3.jpeg", width = 7, height = 4)
```


# üìÑCompile into Word Report

* Make adjustments to page 1 (i.e., quarter, date, action items) directly in the Word template.   
* Make adjustments to page 2 (i.e., TOC) directly in the Word template.  
* Make table and figure titles and footnotes directly in the Word template.   

```{r}
# Read in template
doc <- read_docx("template_l2c_quarterly_report.docx")

# Pg. 3
## Add number of participants screened-in and the date
doc <- doc %>% 
  body_replace_text_at_bkm("n_participants", as.character(n_screened_in)) %>% 
  body_replace_text_at_bkm("date", format(Sys.Date(), "%B %d, %Y"))

## Add Table 1. Demographic characteristics of all people screened-in.
doc <- body_replace_flextable_at_bkm(doc, "table_demographics", table_1_ft)

## Add Table 2. Distribution of reasons for screen-out.
doc <- body_replace_flextable_at_bkm(doc, "table_screen_out", table_2_ft)

## Add Figure 1. Reasons for phone terminations overall.
doc <- doc %>% 
  body_replace_text_at_bkm("n_phone_terminations", as.character(n_phone_terminations)) %>% 
  body_replace_img_at_bkm(
    "fig_phone_terminations", 
    external_img("fig_1.jpeg", width = 7, height = 4)
  )

## Add n randomized to title of Table 6
doc <- doc %>% 
  body_replace_text_at_bkm("n_randomized", as.character(n_randomized))

## Add Figure 2. Recruitment by month.
doc <- doc %>% 
  body_replace_img_at_bkm(
    "fig_recruitment_by_month", 
    external_img("fig_2.jpeg", width = 7, height = 4)
  )

## Add Figure 3. Recruitment by year.
doc <- doc %>% 
  body_replace_img_at_bkm(
    "fig_recruitment_by_year", 
    external_img("fig_3.jpeg", width = 7, height = 4)
  )
```

## üñ®Output Word document

Update the year and month in the file name dynamically

```{r}
print(
  doc, 
  paste0(Sys.Date() %>% format("%Y_%m"), " L2C Quarterly Report.docx")
)
```


# üóëClean up

```{r eval=FALSE}
rm(list = ls())
```

```{r echo=FALSE}
sessionInfo()
```
