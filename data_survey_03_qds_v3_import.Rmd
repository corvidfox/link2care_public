---
title: "Import Link2Care Survey Data - QDS Visit 3"
date: "2021-04-24 <br> Updated: `r Sys.Date()`"
---

# ‚≠êÔ∏èOverview

This file is used to import the Link2Care follow-up visit survey data and do some initial data cleaning. 

**NOTE on using multiple import code files:**
Previously, I was trying to clean all the separate data frames (i.e, QDS v3-v5, REDCap, and Master Log) in a single Rmd file. 

In theory, this is more efficient than importing and cleaning each visit file separately. For example, we can clean "race" instead of cleaning "race_v3", "race_v3", etc.

However, there are at least two issues with that approach:   
1. There are intentional differences in the variable names (e.g., "V1" and "V2"), and unintentional errors (e.g., HEIGHT_3) in the variable names, from data frame to data frame that make combining them very difficult.   
2. These differences and errors can be "fixed"; however, doing so makes the variable names so different from the codebook that the codebook is barely usable.

For now, I'm going to try importing and cleaning each data file using a separate code file. There may be opportunities to make this more efficient in the future.

**NOTE on data sources:**
* The QDS data is exported from QDS in SPSS data format. The data has to be exported by visit (i.e., v1, v2, ... v5). The SPSS data is then added to the UTHealth servers.

* Some of the v3-v5 visits are also done using REDCap. That data is exported from REDCap and added to the UTHealth servers.

**NOTE on Kiteworks:**
Currently, I'm importing all of this data from the UTHealth server. The data should also be available on Kiteworks if you are unable to connect to the server for some reason.


# üì¶Load packages

```{r message=FALSE}
library(dplyr)
library(haven)
library(officer)
library(readr)
library(tidyr)
library(stringr)
library(testthat)
```

# üåéConnect to UTH server 

```{bash eval=FALSE}
# Don't drill all the way down to live documents because not all of the data is in live documents.
open 'smb://islgpcifs.uthouston.edu/sph_research/Link2Care/'
```


# üì•Import data 

```{r}
v3 <- read_sav("/Volumes/Link2Care/Participant Data/SPSS Data/QDS Data/Visit_3_Data.SAV")

# Print a message for when this file is being sourced
cat(
  paste0(Sys.Date(), ":"),
  "QDS Visit 3 imported with", nrow(v3), "rows and", ncol(v3), "columns.\n"
)

# 2021-07-09: QDS Visit 3 imported with 194 rows and 542 columns.
```


# Clean variable names

_See "Notes on cleaning individual L2C data sets for merging" for the rationale, style guidelines, and instructions for this section._
  
## Extract content from Word codebook

```{r}
v3_cb_content <- read_docx("docs/codebooks/L2C_v3 Codebook.docx") %>% 
  docx_summary()
```

### Keep the variables of interest only

```{r}
v3_cb_col_names <- v3_cb_content %>%
  filter(style_name %in% c("section_name", "cb_col_name", "col_name")) %>% 
  select(doc_index, style_name:text) %>% 
  pivot_wider(
    names_from = "style_name",
    values_from = "text"
  )
```

### Clean section names

```{r}
v3_cb_col_names <- v3_cb_col_names %>%
  mutate(
    # Remove "Sect-number."
    section_name = str_remove(section_name, "Sect-\\d{1,}."),
    # Remove asterisks
    section_name = str_remove_all(section_name, "\\*"),
    # Remove empty spaces
    section_name = str_trim(section_name)
  ) %>% 
  # Fill section down across rows
  fill(section_name)
```

### Record the sections that are completed at visit 3

We will use this for checking to make sure all of the correct questionnaire sections merge later.

**NOTE:** q_sections was created in data_survey_01_qds_v1_import.Rmd

```{r}
q_sections <- read_rds("data/questionnaire_section.rds")
```

```{r}
q_sections[["v3"]] <- unique(v3_cb_col_names$section_name)
# q_sections[["v3"]]
```

```{r}
write_rds(q_sections, "data/questionnaire_section.rds")
```

```{r}
rm(q_sections)
```

### Reduce to one row per column

Currently, cb_col_name and col_name are on separate rows. We will spread the different column names vertically across rows so that we can reduce the data frame down to one row per column.

```{r}
v3_cb_col_names <- v3_cb_col_names %>%
  # Spread cb_col_name across rows
  fill(cb_col_name) %>% 
  # Spread col_name across rows within cb_col_name
  group_by(cb_col_name) %>% 
  fill(col_name, .direction = "up") %>% 
  # # For data checking
  # filter(section_name == "Self-Rated Health Questionnaire") %>%
  # ungroup() %>%
  # slice(-1) %>%
  # summarise(
  #   length(unique(cb_col_name)),
  #   length(unique(col_name))
  # )
  group_by(cb_col_name) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  # Remove first row
  slice(-1)
```

```{r}
dim(v3_cb_col_names) # 449   4
```

### Standardize new column names

* Remove _v3 and v3 from column names
* Replace spaces with underscores
* Convert to lower case
* Add underscore in-between the abbreviated tool name and question number

```{r}
v3_cb_col_names <- v3_cb_col_names %>%
  mutate(
    # Remove _v3 from column name
    # Remove v3 at end of column name (e.g., DEM1v3)
    # Don't include values for col_name that were changed in the Word
    # document.
    col_name = if_else(
      is.na(col_name),
      str_replace(cb_col_name, "_V3|V3", ""),
      as.character(col_name)
    ),
    # Replace spaces with underscores
    col_name = str_replace_all(col_name, " ", "_"),
    # Convert to lower case
    col_name = str_to_lower(col_name),
    # Add underscore in-between the abbreviated tool name and question number
    col_name = str_replace(col_name, "([a-z])(\\d)", "\\1_\\2")
  )
```

## New column: Visit type

On 2021-06-10, VISIT_TYPE was added to QDS, but not the codebook. Therefore, we will create a new row for v3_cb_col_names that will include the VISIT_TYPE variables that would have been there if it were in the codebook. 

```{r}
v3_cb_col_names <- v3_cb_col_names %>%
  add_row(
    doc_index    = NA,
    section_name = "Admin",
    cb_col_name  = "VISIT_TYPE",
    col_name     = "visit_type",
    .after       = which(v3_cb_col_names$cb_col_name == "TODAY_V3")
  )
```

## New columns: Tobacco 26 questions

```{r}
v3 %>% select(starts_with("t26"))
```


On 2021-06-05, Joe Waring found a discrepancy between the way Tobacco 26 was being asked in QDS and REDCap. 

In QDS, T26_V1, T26_V3, T26_V4, and T26_V5 read:

Which option would give you the best chance for quitting smoking?
1	=	Medications
2	=	Counseling
3	=	Both medications and counseling
4	=	Smartphone app
5	=	Both smartphone app and medications
6	=	Quitting "cold turkey" - without counseling or medications
9	=	skipped

And only one answer choice was possible.

In REDCap, t26_v1 reads:

If you were to try to quit smoking, which of the following wouldyou prefer to receive: (select all that apply)

1 t26_v1___1 Medications
2 t26_v1___2 Group Counseling
3 t26_v1___3 Smartphone app
4 t26_v1___4 In person individual counseling
5 t26_v1___5 Helpline phone counseling
6 t26_v1___6 None of the above

Where multiple answers are possible and t26_v1___1 - t26_v1___6 are dummy variables.

On 2021-06-30 the QDS survey was changed to be more like the REDCap survey. The QDS data now has T26A_V3, T26A_V3A, T26A_V3B, T26A_V3C, T26A_V3D, T26A_V3E, and T26A_V3F that correspond to t26_v1___1 - t26_v1___6 in REDCap. 

These variables will not exist in the Word codebooks, so we will manually add them to v3_cb_col_names and manually make sure they follow naming conventions.

Changing "T26_V3" (the name that appears in the outdated codebook) to "T26A_V3" (the name that actually appears in the data frame now).

```{r}
v3_cb_col_names <- v3_cb_col_names %>% 
  mutate(cb_col_name = if_else(cb_col_name == "T26_V3", "T26A_V3", cb_col_name))
```

Next, create new rows for v3_cb_col_names that will add the T26 dummy variables that would have been there if the new variables were in the codebook. 

```{r}
v3_cb_col_names <- v3_cb_col_names %>%
  add_row(
    doc_index    = NA,
    section_name = "Tobacco History Questionnaire",
    cb_col_name  = c(
      "T26A_V3A", "T26A_V3B", "T26A_V3C", "T26A_V3D", "T26A_V3E", "T26A_V3F"
    ),
    col_name     = c("t_27a", "t_27b", "t_27c", "t_27d", "t_27e", "t_27f"),
    .after       = which(v3_cb_col_names$cb_col_name == "T26A_V3")
  )
```

## Create a column name key

That we can use to rename columns in the v3 data using column names already used at previous visits. 

In the process of cleaning the visit 1 and visit 2 data, we have already created some new column names. Here we will load those previously created column names and apply them to the visit 3 data where applicable. The goal is to have matching column names for matching variables across all the survey data to facilitate joining them together into a single data frame.

Load the previously used column names.

**NOTE:** col_name_keys.rds was created in data_survey_01_qds_v1_import.Rmd

```{r}
col_name_keys <- read_rds("data/col_name_keys.rds")
```

```{r}
established_col_names <- col_name_keys[["v1"]] %>%
  bind_rows(col_name_keys[["v2"]])
```

Prepare the visit 3 column names to be compared to the previously established column names.

```{r}
v3_cols_compare <- v3_cb_col_names %>% 
  # Don't need doc_index
  select(-doc_index, -section_name) %>% 
  # If we just join on col_name below, we can't see how col_name in the 
  # current visit data and col_name in the past visit data differ.
  # If we try to join on the codebook col_names, we don't get many joins
  # because of the visit numbers (e.g., TODAY_V1 and TODAY_V3).
  # Dropping the visit numbers from the codebook column names and joining
  # on that.
  # It isn't perfect, but it gets us really close.
  mutate(cb_col_name_join = str_remove(cb_col_name, "_V3|V3")) %>%
  select(section_name, cb_col_name_join, cb_col_name, col_name_v3 = col_name)
```

Prepare the previously established column names to be compared to the visit 3 column names.

```{r}
established_cols_compare <- established_col_names %>% 
  # Don't need doc_index or section_name
  select(cb_col_name, col_name) %>% 
  # Values of col_name can repeat across visits.
  # For our current purposes, we only need the unique values of col_name.
  distinct(col_name, .keep_all = TRUE) %>% 
  # If we just join on col_name below, we can't see how col_name in the 
  # current visit data and col_name in the past visit data differ.
  # If we try to join on the codebook col_names, we don't get many joins
  # because of the visit numbers (e.g., TODAY_V1 and TODAY_V3).
  # Dropping the visit numbers from the codebook column names and joining
  # on that.
  # It isn't perfect, but it gets us really close.
  mutate(cb_col_name_join = str_remove(cb_col_name, "_V\\d|V\\d")) %>%
  select(cb_col_name_join, col_name_saved = col_name)
```

```{r}
# Helper function
not_match <- function(x, y) {
  out <- (x == y) | (is.na(x) & is.na(y))
  out[is.na(out)] <- FALSE
  !out
}
```

Manually review the differences in column names and correct typos in the visit 3 codebook as needed. However, don't create new col_name values in the visit 3 codebook if we can just grab them from the "columns" data frame. Doing so makes typos less likely if we make changes to the column names in the future, we only have to make those changes in one place. For example, if we decided to change "dem_employ_status" to "dem_employ", we would only have to make that change in the visit 1 codebook -- not the visit 3 codebook.



```{r}
v3_col_names_key <- v3_cols_compare %>%
  left_join(established_cols_compare, by = "cb_col_name_join") %>%
  # For manual data checking
  mutate(diff = not_match(col_name_v3, col_name_saved)) %>%
  filter(diff) %>%
  mutate(
    col_name = col_name_saved,
    col_name = if_else(is.na(col_name), col_name_v3, col_name)
  ) %>% 
  # For manual data checking
  # select(cb_col_name, col_name_v3:col_name_saved, col_name)
  select(section_name, cb_col_name, col_name)
```

* Use the saved, previously used column names except except where noted below.

* Use the visit 3 column names for the following variables:
  - Group - not used in previous visits.   
  - Weight-waist - fixed typos in the visit 3 codebook   
  - DEM14GV3 - there was a typo in the visit 1 codebook   
  - DEM14HV3 - not used in previous visits.   
  - BH14BV3D - not used in previous visits.   
  - HSI2_V13 - fixed typo in the visit 3 codebook
  - MS4_V3 - there was a typo in the visit 1 codebook   
  - PV1_V3 & PV2_V3 - discrepancy is just caused by the way cb_col_name_join was created.   
  - All of Treatment Quality and Satisfaction Survey - not used in previous visits.   
  - ENDTIME3 - fix typos in the visit 3 codebook  
  
## Check for duplicate column names

Check to make sure this process didn't accidentally create any duplicate column names

```{r}
v3_col_names_key %>% 
  group_by(col_name) %>% 
  filter(max(row_number()) > 1)
```

When we remove "_V3" from the visit 3 codebook column names to do the join above, T31_V3B and T31B_V3 both become T31B. This causes both columns to join with both t32b and t33 from the previously used column names data frame. 

In reality, T31_V3B should be t32b (change made in visit 1 codebook, T31_V1B -> t32b) and T31B_V3 should be t33 (change made in visit 1 codebook, T31B_V1 -> t33). We will manually make those changes below.

```{r}
v3_col_names_key <- v3_col_names_key %>% 
  # Drop the row with cb_col_name == "T31_V3B" & col_name == "t_33"
  # Keep the row with cb_col_name == "T31_V3B" & col_name == "t32b"
  filter(!(cb_col_name == "T31_V3B" & col_name == "t_33")) %>% 
  # Drop the row with cb_col_name == "T31B_V3" & col_name == "t32b"
  # Keep the row with cb_col_name == "T31B_V3" & col_name == "t_33"
  filter(!(cb_col_name == "T31B_V3" & col_name == "t_32b"))
```

```{r}
test_that("No duplicate col_names were created in the visit 3 data.", {
  check_dup_col_name <- v3_col_names_key %>% 
    group_by(col_name) %>% 
    filter(max(row_number()) > 1) %>% 
    pull(col_name)
  
  expect_length(check_dup_col_name, 0)
})
```

## Save column names

Save v3_col_names_key as a key that maps the new names to the old names in case we need that information in the future. Possibly for the codebook.

```{r}
v3_col_names_key <- v3_col_names_key %>% 
  # Add df identifier
  mutate(df = "v3") %>% 
  select(df, everything())
```

```{r}
col_name_keys[["v3"]] <- v3_col_names_key
# col_name_keys[["v3"]]
```

```{r}
write_rds(col_name_keys, "data/col_name_keys.rds")
```

```{r}
rm(
  col_name_keys, established_cols_compare, established_col_names, v3_cb_col_names, 
  v3_cb_content, v3_cols_compare, not_match
)
```

## Differences between codebook columns and data columns

Check to see what differences, if any, exist between the columns in the codebook and the columns in the actual data frame.

```{r}
in_cb_not_df <- setdiff(v3_col_names_key$cb_col_name, names(v3))
in_cb_not_df
```

There are **0** column names in the codebook that don't appear in the data.  

```{r}
# Future proof this by checking to see if the variables have changed over time.
# If this test fails in the future, come back and make adjustments to how we 
# handle columns as needed.
test_that("The expected columns exist in the codebook, but not the v3 df.", {
  expect_equal(
    length(in_cb_not_df),
    0L
  )
})
```

Now, check for columns that exist in the data frame, but not the codebook.

```{r}
in_df_not_cb <- setdiff(names(v3), v3_col_names_key$cb_col_name)
in_df_not_cb
```

```{r}
# Future proof this by checking to see if the variables have changed over time.
# If this test fails in the future, come back and make adjustments to how we 
# handle columns as needed.
test_that("The expected columns exist in the v3 df, but not the v3 codebook.", {
  expect_equal(
    length(in_df_not_cb),
    77L
  )
})
```

The remainder of these variables are calculated variables created by the SPSS export script. We will save them in a separate data frame and deal with them later. 

```{r}
v3_spss_calc_vars <- v3 %>% 
  select(id = SUBJECT, visit = VISIT_V3, all_of(in_df_not_cb))
```

```{r}
write_sav(v3_spss_calc_vars, "data/v3_spss_calc_vars.sav")
```

Remove calculated variables from the v3 data. This makes it easier to merge with the other QDS data frames later.

```{r}
v3 <- v3 %>% select(!all_of(in_df_not_cb))
```

```{r}
# Future proof this by checking to see if the variables have changed over time.
# If this test fails in the future, come back and make adjustments to how we 
# handle columns as needed.
test_that("The expected number of columns exist in the v3 df after cleaning.", {
  expect_equal(
    length(names(v3)),
    449L
  )
})
```

Clean up

```{r}
rm(v3_spss_calc_vars, in_cb_not_df, in_df_not_cb)
```

## Replace variable names in the full data frame

Put them in the same order used in the codebook.

```{r}
v3 <- v3 %>% 
  select(all_of(v3_col_names_key$cb_col_name))

names(v3) <- v3_col_names_key$col_name
```


# üíæSave the data frame

```{r}
path <- "/Volumes/Link2Care/Participant Data/R Data/qds_v3_import.rds"
```

```{r}
write_rds(v3, path)
```

Print a message for when this file is being sourced

```{r}
cat(
  paste0(Sys.Date(), ":"),
  "QDS Visit 3 saved to", path
)
```


# üóëClean up

```{r}
rm(v3_col_names_key, path)
```


# üñ®Print a message for when this file is being sourced

```{r}
cat(
  paste0(Sys.Date(), ":"),
  "QDS Visit 3 cleaned with", nrow(v3), "rows and", ncol(v3), "columns.\n"
)

# 2021-04-28: QDS Visit 3 cleaned with 180 rows and 449 columns.
```

```{r echo=FALSE}
sessionInfo()
```
